/**
 * data-structure-typed
 *
 * @author Tyler Zeng
 * @copyright Copyright (c) 2022 Tyler Zeng <zrwusa@gmail.com>
 * @license MIT License
 */
export class SegmentTreeNode {
    constructor(start, end, sum, val) {
        this._start = 0;
        this._end = 0;
        this._val = null;
        this._sum = 0;
        this._left = null;
        this._right = null;
        this._start = start;
        this._end = end;
        this._sum = sum;
        this._val = val || null;
    }
    get start() {
        return this._start;
    }
    set start(v) {
        this._start = v;
    }
    get end() {
        return this._end;
    }
    set end(v) {
        this._end = v;
    }
    get val() {
        return this._val;
    }
    set val(v) {
        this._val = v;
    }
    get sum() {
        return this._sum;
    }
    set sum(v) {
        this._sum = v;
    }
    get left() {
        return this._left;
    }
    set left(v) {
        this._left = v;
    }
    get right() {
        return this._right;
    }
    set right(v) {
        this._right = v;
    }
}
export class SegmentTree {
    /**
     * The constructor initializes the values, start, end, and root properties of an object.
     * @param {number[]} values - An array of numbers that will be used to build a binary search tree.
     * @param {number} [start] - The `start` parameter is the index of the first element in the `values` array that should
     * be included in the range. If no value is provided for `start`, it defaults to 0, which means the range starts from
     * the beginning of the array.
     * @param {number} [end] - The "end" parameter is the index of the last element in the "values" array that should be
     * included in the range. If not provided, it defaults to the index of the last element in the "values" array.
     */
    constructor(values, start, end) {
        this._values = [];
        this._start = 0;
        start = start || 0;
        end = end || values.length - 1;
        this._values = values;
        this._start = start;
        this._end = end;
        if (values.length > 0) {
            this._root = this.build(start, end);
        }
        else {
            this._root = null;
            this._values = [];
        }
    }
    get values() {
        return this._values;
    }
    get start() {
        return this._start;
    }
    get end() {
        return this._end;
    }
    get root() {
        return this._root;
    }
    /**
     * The build function creates a segment tree by recursively dividing the given range into smaller segments and assigning
     * the sum of values to each segment.
     * @param {number} start - The `start` parameter represents the starting index of the segment or range for which we are
     * building the segment tree.
     * @param {number} end - The "end" parameter represents the ending index of the segment or range for which we want to
     * build a segment tree.
     * @returns a SegmentTreeNode object.
     */
    build(start, end) {
        if (start > end) {
            return new SegmentTreeNode(start, end, 0);
        }
        if (start === end)
            return new SegmentTreeNode(start, end, this._values[start]);
        const mid = start + Math.floor((end - start) / 2);
        const left = this.build(start, mid);
        const right = this.build(mid + 1, end);
        const cur = new SegmentTreeNode(start, end, left.sum + right.sum);
        cur.left = left;
        cur.right = right;
        return cur;
    }
    /**
     * The function updates the value of a node in a segment tree and recalculates the sum of its children if they exist.
     * @param {number} index - The index parameter represents the index of the node in the segment tree that needs to be
     * updated.
     * @param {number} sum - The `sum` parameter represents the new value that should be assigned to the `sum` property of
     * the `SegmentTreeNode` at the specified `index`.
     * @param {SegmentTreeNodeVal} [val] - The `val` parameter is an optional value that can be assigned to the `val`
     * property of the `SegmentTreeNode` object. It is not currently used in the code, but you can uncomment the line `//
     * cur.val = val;` and pass a value for `val` in the
     * @returns The function does not return anything.
     */
    updateNode(index, sum, val) {
        const root = this.root || null;
        if (!root) {
            return;
        }
        const dfs = (cur, index, sum, val) => {
            if (cur.start === cur.end && cur.start === index) {
                cur.sum = sum;
                if (val !== undefined)
                    cur.val = val;
                return;
            }
            const mid = cur.start + Math.floor((cur.end - cur.start) / 2);
            if (index <= mid) {
                if (cur.left) {
                    dfs(cur.left, index, sum, val);
                }
            }
            else {
                if (cur.right) {
                    dfs(cur.right, index, sum, val);
                }
            }
            if (cur.left && cur.right) {
                cur.sum = cur.left.sum + cur.right.sum;
            }
        };
        dfs(root, index, sum, val);
    }
    /**
     * The function `querySumByRange` calculates the sum of values within a given range in a segment tree.
     * @param {number} indexA - The starting index of the range for which you want to calculate the sum.
     * @param {number} indexB - The parameter `indexB` represents the ending index of the range for which you want to
     * calculate the sum.
     * @returns The function `querySumByRange` returns a number.
     */
    querySumByRange(indexA, indexB) {
        const root = this.root || null;
        if (!root) {
            return 0;
        }
        if (indexA < 0 || indexB >= this.values.length || indexA > indexB) {
            return NaN;
        }
        const dfs = (cur, i, j) => {
            if (i <= cur.start && j >= cur.end) {
                // The range [i, j] completely covers the current node's range [cur.start, cur.end]
                return cur.sum;
            }
            const mid = cur.start + Math.floor((cur.end - cur.start) / 2);
            if (j <= mid) {
                if (cur.left) {
                    return dfs(cur.left, i, j);
                }
                else {
                    return NaN;
                }
            }
            else if (i > mid) {
                if (cur.right) {
                    return dfs(cur.right, i, j);
                }
                else {
                    return NaN;
                }
            }
            else {
                // Query both left and right subtrees
                let leftSum = 0;
                let rightSum = 0;
                if (cur.left) {
                    leftSum = dfs(cur.left, i, mid);
                }
                if (cur.right) {
                    rightSum = dfs(cur.right, mid + 1, j);
                }
                return leftSum + rightSum;
            }
        };
        return dfs(root, indexA, indexB);
    }
    _setValues(value) {
        this._values = value;
    }
    _setStart(value) {
        this._start = value;
    }
    _setEnd(value) {
        this._end = value;
    }
    _setRoot(v) {
        this._root = v;
    }
}
