/*! For license information please see bundle.min.js.LICENSE.txt */
!function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e():"function"==typeof define&&define.amd?define([],e):"object"==typeof exports?exports.dataStructureTyped=e():t.dataStructureTyped=e()}(self,(()=>(()=>{"use strict";var t={d:(e,s)=>{for(var r in s)t.o(s,r)&&!t.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:s[r]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},e={};t.r(e),t.d(e,{AVLTree:()=>et,AVLTreeNode:()=>tt,AbstractEdge:()=>A,AbstractGraph:()=>z,AbstractVertex:()=>V,ArrayDeque:()=>x,BST:()=>J,BSTNode:()=>Y,BinaryIndexedTree:()=>X,BinaryTree:()=>Q,BinaryTreeNode:()=>W,CP:()=>q,Character:()=>pt,CoordinateMap:()=>i,CoordinateSet:()=>n,Deque:()=>v,DirectedEdge:()=>O,DirectedGraph:()=>L,DirectedVertex:()=>C,DoublyLinkedList:()=>f,DoublyLinkedListNode:()=>c,FamilyPosition:()=>U,HashMap:()=>l,HashTable:()=>r,HashTableNode:()=>s,Heap:()=>S,LinkedListQueue:()=>_,LoopType:()=>j,MapEdge:()=>D,MapGraph:()=>H,MapVertex:()=>F,Matrix2D:()=>gt,MatrixNTI2D:()=>ct,MaxHeap:()=>ot,MaxPriorityQueue:()=>ut,MinHeap:()=>lt,MinPriorityQueue:()=>at,Navigator:()=>_t,ObjectDeque:()=>m,PriorityQueue:()=>N,Queue:()=>y,RBColor:()=>G,RBTree:()=>rt,RBTreeNode:()=>st,SegmentTree:()=>$,SegmentTreeNode:()=>Z,SinglyLinkedList:()=>u,SinglyLinkedListNode:()=>a,SkipList:()=>g,SkipListNode:()=>d,Stack:()=>p,THUNK_SYMBOL:()=>b,TopologicalProperty:()=>K,TreeMap:()=>h,TreeMultiset:()=>nt,TreeMultisetNode:()=>it,TreeNode:()=>ht,TreeSet:()=>o,Trie:()=>vt,TrieNode:()=>yt,UndirectedEdge:()=>I,UndirectedGraph:()=>B,UndirectedVertex:()=>P,Vector2D:()=>ft,arrayRemove:()=>E,isThunk:()=>w,toThunk:()=>T,trampoline:()=>M,trampolineAsync:()=>R,uuidV4:()=>k});class s{constructor(t,e){this.key=t,this.val=e,this.next=null}}class r{get hashFn(){return this._hashFn}set hashFn(t){this._hashFn=t}get buckets(){return this._buckets}set buckets(t){this._buckets=t}get capacity(){return this._capacity}set capacity(t){this._capacity=t}constructor(t=r.DEFAULT_CAPACITY,e){this._hashFn=e||this._defaultHashFn,this._capacity=Math.max(t,r.DEFAULT_CAPACITY),this._size=0,this._buckets=new Array(this._capacity).fill(null)}_defaultHashFn(t){return("string"==typeof t?this._murmurStringHashFn(t):this._objectHash(t))%this._capacity}_multiplicativeStringHashFn(t){const e=String(t);let s=0;for(let t=0;t<e.length;t++)s=(.618033988749895*s+e.charCodeAt(t))%(1<<30);return Math.abs(s)}_murmurStringHashFn(t){const e=String(t);let s=0;for(let t=0;t<e.length;t++)s=1540483477*(s^e.charCodeAt(t)),s=668265261*(s^s>>>15),s^=s>>>15;return Math.abs(s)}_hash(t){return this.hashFn(t)}_stringHash(t){let e=0;for(let s=0;s<t.length;s++)e=31*e+t.charCodeAt(s)&4294967295;return e}_objectHash(t){return this._stringHash(JSON.stringify(t))}set(t,e){const i=this._hash(t),n=new s(t,e);if(this._buckets[i]){let s=this._buckets[i];for(;s;){if(s.key===t)return void(s.val=e);if(!s.next)break;s=s.next}s.next=n}else this._buckets[i]=n;this._size++,this._size/this._capacity>=r.LOAD_FACTOR&&this._expand()}get(t){const e=this._hash(t);let s=this._buckets[e];for(;s;){if(s.key===t)return s.val;s=s.next}}remove(t){const e=this._hash(t);let s=this._buckets[e],r=null;for(;s;){if(s.key===t)return r?r.next=s.next:this._buckets[e]=s.next,this._size--,void(s.next=null);r=s,s=s.next}}_expand(){const t=2*this._capacity,e=new Array(t).fill(null);for(const t of this._buckets){let r=t;for(;r;){const t=this._hash(r.key),i=new s(r.key,r.val);if(e[t]){let s=e[t];for(;s.next;)s=s.next;s.next=i}else e[t]=i;r=r.next}}this._buckets=e,this._capacity=t}get size(){return this._size}}r.DEFAULT_CAPACITY=16,r.LOAD_FACTOR=.75;class i extends Map{constructor(t){super(),this._joint="_",void 0!==t&&(this._joint=t)}get joint(){return this._joint}has(t){return super.has(t.join(this._joint))}set(t,e){return super.set(t.join(this._joint),e)}get(t){return super.get(t.join(this._joint))}delete(t){return super.delete(t.join(this._joint))}_setJoint(t){this._joint=t}}class n extends Set{constructor(t){super(),this._joint="_",void 0!==t&&(this._joint=t)}get joint(){return this._joint}has(t){return super.has(t.join(this._joint))}add(t){return super.add(t.join(this._joint))}delete(t){return super.delete(t.join(this._joint))}_setJoint(t){this._joint=t}}class h{}class o{}class l{get hashFn(){return this._hashFn}set hashFn(t){this._hashFn=t}get table(){return this._table}set table(t){this._table=t}get capacityMultiplier(){return this._capacityMultiplier}set capacityMultiplier(t){this._capacityMultiplier=t}get loadFactor(){return this._loadFactor}set loadFactor(t){this._loadFactor=t}get initialCapacity(){return this._initialCapacity}set initialCapacity(t){this._initialCapacity=t}get size(){return this._size}set size(t){this._size=t}constructor(t=16,e=.75,s){this._initialCapacity=t,this._loadFactor=e,this._capacityMultiplier=2,this._size=0,this._table=new Array(t),this._hashFn=s||(t=>{const e=String(t);let s=0;for(let t=0;t<e.length;t++)s+=e.charCodeAt(t);return s%this.table.length})}_hash(t){return this._hashFn(t)}resizeTable(t){const e=new Array(t);for(const s of this._table)if(s)for(const[r,i]of s){const s=this._hash(r)%t;e[s]||(e[s]=[]),e[s].push([r,i])}this._table=e}set(t,e){this.size/this.table.length>=this.loadFactor&&this.resizeTable(this.table.length*this.capacityMultiplier);const s=this._hash(t);this.table[s]||(this.table[s]=[]);for(let r=0;r<this.table[s].length;r++)if(this.table[s][r][0]===t)return void(this.table[s][r][1]=e);this.table[s].push([t,e]),this.size++}get(t){const e=this._hash(t);if(this.table[e])for(const[s,r]of this.table[e])if(s===t)return r}remove(t){const e=this._hash(t);if(this.table[e])for(let s=0;s<this.table[e].length;s++)if(this.table[e][s][0]===t)return this.table[e].splice(s,1),this.size--,void(this.size/this.table.length<this.loadFactor/this.capacityMultiplier&&this.resizeTable(this.table.length/this.capacityMultiplier))}*entries(){for(const t of this.table)if(t)for(const[e,s]of t)yield[e,s]}[Symbol.iterator](){return this.entries()}clear(){this.size=0,this.table=new Array(this.initialCapacity)}isEmpty(){return 0===this.size}}class a{constructor(t){this._val=t,this._next=null}get val(){return this._val}set val(t){this._val=t}get next(){return this._next}set next(t){this._next=t}}class u{constructor(){this._head=null,this._tail=null,this._length=0}get head(){return this._head}set head(t){this._head=t}get tail(){return this._tail}set tail(t){this._tail=t}get length(){return this._length}static fromArray(t){const e=new u;for(const s of t)e.push(s);return e}getLength(){return this._length}push(t){const e=new a(t);this.head?(this.tail.next=e,this.tail=e):(this.head=e,this.tail=e),this._length++}pop(){if(!this.head)return;if(this.head===this.tail){const t=this.head.val;return this.head=null,this.tail=null,this._length--,t}let t=this.head;for(;t.next!==this.tail;)t=t.next;const e=this.tail.val;return t.next=null,this.tail=t,this._length--,e}shift(){if(!this.head)return;const t=this.head;return this.head=this.head.next,this._length--,t.val}unshift(t){const e=new a(t);this.head?(e.next=this.head,this.head=e):(this.head=e,this.tail=e),this._length++}getAt(t){if(t<0||t>=this.length)return;let e=this.head;for(let s=0;s<t;s++)e=e.next;return e.val}getNodeAt(t){let e=this.head;for(let s=0;s<t;s++)e=e.next;return e}deleteAt(t){if(t<0||t>=this.length)return;if(0===t)return this.shift();if(t===this.length-1)return this.pop();const e=this.getNodeAt(t-1),s=e.next;return e.next=s.next,this._length--,s.val}delete(t){let e;e=t instanceof a?t.val:t;let s=this.head,r=null;for(;s;){if(s.val===e)return null===r?(this.head=s.next,s===this.tail&&(this.tail=null)):(r.next=s.next,s===this.tail&&(this.tail=r)),this._length--,!0;r=s,s=s.next}return!1}insertAt(t,e){if(t<0||t>this.length)return!1;if(0===t)return this.unshift(e),!0;if(t===this.length)return this.push(e),!0;const s=new a(e),r=this.getNodeAt(t-1);return s.next=r.next,r.next=s,this._length++,!0}isEmpty(){return 0===this.length}clear(){this._head=null,this._tail=null,this._length=0}toArray(){const t=[];let e=this.head;for(;e;)t.push(e.val),e=e.next;return t}reverse(){if(!this.head||this.head===this.tail)return;let t=null,e=this.head,s=null;for(;e;)s=e.next,e.next=t,t=e,e=s;[this.head,this.tail]=[this.tail,this.head]}find(t){let e=this.head;for(;e;){if(t(e.val))return e.val;e=e.next}return null}indexOf(t){let e=0,s=this.head;for(;s;){if(s.val===t)return e;e++,s=s.next}return-1}findNode(t){let e=this.head;for(;e;){if(e.val===t)return e;e=e.next}return null}insertBefore(t,e){if(!this.head)return!1;let s;if(s=t instanceof a?t.val:t,this.head.val===s)return this.unshift(e),!0;let r=this.head;for(;r.next;){if(r.next.val===s){const t=new a(e);return t.next=r.next,r.next=t,this._length++,!0}r=r.next}return!1}insertAfter(t,e){let s;if(s=t instanceof a?t:this.findNode(t),s){const t=new a(e);return t.next=s.next,s.next=t,s===this.tail&&(this.tail=t),this._length++,!0}return!1}countOccurrences(t){let e=0,s=this.head;for(;s;)s.val===t&&e++,s=s.next;return e}*[Symbol.iterator](){let t=this.head;for(;t;)yield t.val,t=t.next}}class c{constructor(t){this._val=t,this._next=null,this._prev=null}get val(){return this._val}set val(t){this._val=t}get next(){return this._next}set next(t){this._next=t}get prev(){return this._prev}set prev(t){this._prev=t}}class f{constructor(){this._head=null,this._tail=null,this._length=0}get head(){return this._head}set head(t){this._head=t}get tail(){return this._tail}set tail(t){this._tail=t}get length(){return this._length}static fromArray(t){const e=new f;for(const s of t)e.push(s);return e}push(t){const e=new c(t);this.head?(e.prev=this.tail,this.tail.next=e,this.tail=e):(this.head=e,this.tail=e),this._length++}addLast(t){this.push(t)}pop(){if(!this.tail)return;const t=this.tail;return this.head===this.tail?(this.head=null,this.tail=null):(this.tail=t.prev,this.tail.next=null),this._length--,t.val}pollLast(){return this.pop()}shift(){if(!this.head)return;const t=this.head;return this.head===this.tail?(this.head=null,this.tail=null):(this.head=t.next,this.head.prev=null),this._length--,t.val}pollFirst(){return this.shift()}unshift(t){const e=new c(t);this.head?(e.next=this.head,this.head.prev=e,this.head=e):(this.head=e,this.tail=e),this._length++}addFirst(t){this.unshift(t)}peekFirst(){var t;return null===(t=this.head)||void 0===t?void 0:t.val}peekLast(){var t;return null===(t=this.tail)||void 0===t?void 0:t.val}get size(){return this.length}getAt(t){if(t<0||t>=this.length)return;let e=this.head;for(let s=0;s<t;s++)e=e.next;return e.val}getNodeAt(t){if(t<0||t>=this.length)return null;let e=this.head;for(let s=0;s<t;s++)e=e.next;return e}findNode(t){let e=this.head;for(;e;){if(e.val===t)return e;e=e.next}return null}insertAt(t,e){if(t<0||t>this.length)return!1;if(0===t)return this.unshift(e),!0;if(t===this.length)return this.push(e),!0;const s=new c(e),r=this.getNodeAt(t-1),i=r.next;return s.prev=r,s.next=i,r.next=s,i.prev=s,this._length++,!0}deleteAt(t){if(t<0||t>=this.length)return;if(0===t)return this.shift();if(t===this.length-1)return this.pop();const e=this.getNodeAt(t),s=e.prev,r=e.next;return s.next=r,r.prev=s,this._length--,e.val}delete(t){let e;if(e=t instanceof c?t:this.findNode(t),e){if(e===this.head)this.shift();else if(e===this.tail)this.pop();else{const t=e.prev,s=e.next;t.next=s,s.prev=t,this._length--}return!0}return!1}toArray(){const t=[];let e=this.head;for(;e;)t.push(e.val),e=e.next;return t}isEmpty(){return 0===this.length}clear(){this._head=null,this._tail=null,this._length=0}find(t){let e=this.head;for(;e;){if(t(e.val))return e.val;e=e.next}return null}indexOf(t){let e=0,s=this.head;for(;s;){if(s.val===t)return e;e++,s=s.next}return-1}findLast(t){let e=this.tail;for(;e;){if(t(e.val))return e.val;e=e.prev}return null}toArrayReverse(){const t=[];let e=this.tail;for(;e;)t.push(e.val),e=e.prev;return t}reverse(){let t=this.head;for([this.head,this.tail]=[this.tail,this.head];t;){const e=t.next;[t.prev,t.next]=[t.next,t.prev],t=e}}forEach(t){let e=this.head,s=0;for(;e;)t(e.val,s),e=e.next,s++}map(t){const e=new f;let s=this.head;for(;s;)e.push(t(s.val)),s=s.next;return e}filter(t){const e=new f;let s=this.head;for(;s;)t(s.val)&&e.push(s.val),s=s.next;return e}reduce(t,e){let s=e,r=this.head;for(;r;)s=t(s,r.val),r=r.next;return s}insertAfter(t,e){let s;if(s=t instanceof c?t:this.findNode(t),s){const t=new c(e);return t.next=s.next,s.next&&(s.next.prev=t),t.prev=s,s.next=t,s===this.tail&&(this.tail=t),this._length++,!0}return!1}insertBefore(t,e){let s;if(s=t instanceof c?t:this.findNode(t),s){const t=new c(e);return t.prev=s.prev,s.prev&&(s.prev.next=t),t.next=s,s.prev=t,s===this.head&&(this.head=t),this._length++,!0}return!1}}class d{constructor(t,e,s){this.key=t,this.value=e,this.forward=new Array(s)}}class g{get probability(){return this._probability}set probability(t){this._probability=t}get maxLevel(){return this._maxLevel}set maxLevel(t){this._maxLevel=t}get level(){return this._level}set level(t){this._level=t}get head(){return this._head}set head(t){this._head=t}constructor(t=16,e=.5){this._head=new d(null,null,t),this._level=0,this._maxLevel=t,this._probability=e}randomLevel(){let t=1;for(;Math.random()<this.probability&&t<this.maxLevel;)t++;return t}add(t,e){const s=new d(t,e,this.randomLevel()),r=new Array(this.maxLevel).fill(this.head);let i=this.head;for(let e=this.level-1;e>=0;e--){for(;i.forward[e]&&i.forward[e].key<t;)i=i.forward[e];r[e]=i}for(let t=0;t<s.forward.length;t++)s.forward[t]=r[t].forward[t],r[t].forward[t]=s;null!==s.forward[0]&&(this.level=Math.max(this.level,s.forward.length))}get(t){let e=this.head;for(let s=this.level-1;s>=0;s--)for(;e.forward[s]&&e.forward[s].key<t;)e=e.forward[s];if(e=e.forward[0],e&&e.key===t)return e.value}remove(t){const e=new Array(this.maxLevel).fill(this.head);let s=this.head;for(let r=this.level-1;r>=0;r--){for(;s.forward[r]&&s.forward[r].key<t;)s=s.forward[r];e[r]=s}if(s=s.forward[0],s&&s.key===t){for(let t=0;t<this.level&&e[t].forward[t]===s;t++)e[t].forward[t]=s.forward[t];for(;this.level>0&&null===this.head.forward[this.level-1];)this.level--;return!0}return!1}}class p{constructor(t){this._elements=Array.isArray(t)?t:[]}static fromArray(t){return new p(t)}isEmpty(){return 0===this._elements.length}size(){return this._elements.length}peek(){return this.isEmpty()?null:this._elements[this._elements.length-1]}push(t){return this._elements.push(t),this}pop(){return this.isEmpty()?null:this._elements.pop()||null}toArray(){return this._elements.slice()}clear(){this._elements=[]}clone(){return new p(this._elements.slice())}}class _ extends u{enqueue(t){this.push(t)}dequeue(){return this.shift()}peek(){var t;return null===(t=this.head)||void 0===t?void 0:t.val}}class y{constructor(t){this._nodes=t||[],this._offset=0}get nodes(){return this._nodes}set nodes(t){this._nodes=t}get offset(){return this._offset}set offset(t){this._offset=t}get size(){return this.nodes.length-this.offset}static fromArray(t){return new y(t)}push(t){return this.nodes.push(t),this}shift(){if(0===this.size)return;const t=this.peek();return this.offset+=1,2*this.offset<this.nodes.length||(this.nodes=this.nodes.slice(this.offset),this.offset=0),t}peek(){return this.size>0?this.nodes[this.offset]:void 0}peekLast(){return this.size>0?this.nodes[this.nodes.length-1]:void 0}enqueue(t){this.push(t)}dequeue(){return this.shift()}getAt(t){return this.nodes[t]}isEmpty(){return 0===this.size}toArray(){return this.nodes.slice(this.offset)}clear(){this.nodes=[],this.offset=0}clone(){return new y(this.nodes.slice(this.offset))}*[Symbol.iterator](){for(const t of this.nodes)yield t}}class v extends f{}class m{constructor(t){this._nodes={},this._capacity=Number.MAX_SAFE_INTEGER,this._first=-1,this._last=-1,this._size=0,void 0!==t&&(this._capacity=t)}get nodes(){return this._nodes}get capacity(){return this._capacity}set capacity(t){this._capacity=t}get first(){return this._first}set first(t){this._first=t}get last(){return this._last}set last(t){this._last=t}get size(){return this._size}addFirst(t){if(0===this._size){const t=Math.floor(this._capacity/2);this._first=t,this._last=t}else this._first--;this._nodes[this._first]=t,this._size++}addLast(t){if(0===this._size){const t=Math.floor(this._capacity/2);this._first=t,this._last=t}else this._last++;this._nodes[this._last]=t,this._size++}pollFirst(){if(!this._size)return;const t=this.peekFirst();return delete this._nodes[this._first],this._first++,this._size--,t}peekFirst(){if(this._size)return this._nodes[this._first]}pollLast(){if(!this._size)return;const t=this.peekLast();return delete this._nodes[this._last],this._last--,this._size--,t}peekLast(){if(this._size)return this._nodes[this._last]}get(t){return this._nodes[this._first+t]||null}isEmpty(){return this._size<=0}_seNodes(t){this._nodes=t}_setSize(t){this._size=t}}class x{constructor(){this._nodes=[]}get size(){return this._nodes.length}addLast(t){return this._nodes.push(t)}pollLast(){var t;return null!==(t=this._nodes.pop())&&void 0!==t?t:null}pollFirst(){var t;return null!==(t=this._nodes.shift())&&void 0!==t?t:null}addFirst(t){return this._nodes.unshift(t)}peekFirst(){var t;return null!==(t=this._nodes[0])&&void 0!==t?t:null}peekLast(){var t;return null!==(t=this._nodes[this._nodes.length-1])&&void 0!==t?t:null}get(t){var e;return null!==(e=this._nodes[t])&&void 0!==e?e:null}set(t,e){return this._nodes[t]=e}insert(t,e){return this._nodes.splice(t,0,e)}remove(t){return this._nodes.splice(t,1)}isEmpty(){return 0===this._nodes.length}}const k=function(){return"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx".replace(/[x]/g,(function(t){const e=16*Math.random()|0;return("x"==t?e:3&e|8).toString(16)}))},E=function(t,e){let s=-1,r=t?t.length:0;const i=[];for(;++s<r;){const n=t[s];e(n,s,t)&&(i.push(n),Array.prototype.splice.call(t,s--,1),r--)}return i},b=Symbol("thunk"),w=t=>"function"==typeof t&&t.__THUNK__===b,T=t=>{const e=()=>t();return e.__THUNK__=b,e},M=t=>Object.assign(((...e)=>{let s=t(...e);for(;w(s)&&"function"==typeof s;)s=s();return s}),{cont:(...e)=>T((()=>t(...e)))}),R=t=>Object.assign(((...e)=>{return s=void 0,r=void 0,n=function*(){let s=yield t(...e);for(;w(s)&&"function"==typeof s;)s=yield s();return s},new((i=void 0)||(i=Promise))((function(t,e){function h(t){try{l(n.next(t))}catch(t){e(t)}}function o(t){try{l(n.throw(t))}catch(t){e(t)}}function l(e){var s;e.done?t(e.value):(s=e.value,s instanceof i?s:new i((function(t){t(s)}))).then(h,o)}l((n=n.apply(s,r||[])).next())}));var s,r,i,n}),{cont:(...e)=>T((()=>t(...e)))});class S{constructor(t){this.nodes=[],this.comparator=t}add(t){return this.nodes.push(t),this.bubbleUp(this.nodes.length-1),this}poll(){if(0===this.nodes.length)return null;if(1===this.nodes.length)return this.nodes.pop();const t=this.nodes[0];return this.nodes[0]=this.nodes.pop(),this.sinkDown(0),t}bubbleUp(t){const e=this.nodes[t];for(;t>0;){const s=Math.floor((t-1)/2),r=this.nodes[s];if(!(this.comparator(e,r)<0))break;this.nodes[t]=r,this.nodes[s]=e,t=s}}sinkDown(t){const e=2*t+1,s=2*t+2,r=this.nodes.length;let i=t;if(e<r&&this.comparator(this.nodes[e],this.nodes[i])<0&&(i=e),s<r&&this.comparator(this.nodes[s],this.nodes[i])<0&&(i=s),i!==t){const e=this.nodes[t];this.nodes[t]=this.nodes[i],this.nodes[i]=e,this.sinkDown(i)}}fix(){for(let t=Math.floor(this.size/2);t>=0;t--)this.sinkDown(t)}peek(){return 0===this.nodes.length?null:this.nodes[0]}get size(){return this.nodes.length}get leaf(){var t;return null!==(t=this.nodes[this.size-1])&&void 0!==t?t:null}isEmpty(){return 0===this.size}clear(){this.nodes=[]}refill(t){this.nodes=t,this.fix()}has(t){return this.nodes.includes(t)}dfs(t){const e=[],s=r=>{r<this.size&&("in"===t?(s(2*r+1),e.push(this.nodes[r]),s(2*r+2)):"pre"===t?(e.push(this.nodes[r]),s(2*r+1),s(2*r+2)):"post"===t&&(s(2*r+1),s(2*r+2),e.push(this.nodes[r])))};return s(0),e}toArray(){return[...this.nodes]}getNodes(){return this.nodes}clone(){const t=new S(this.comparator);return t.nodes=[...this.nodes],t}sort(){const t=[],e=this.clone();for(;0!==e.size;){const s=e.poll();s&&t.push(s)}return t}static heapify(t,e){const s=new S(e);return s.nodes=[...t],s.fix(),s}}class N extends S{constructor(t){super(t)}}class V{constructor(t,e){this._key=t,this._val=e}get key(){return this._key}set key(t){this._key=t}get val(){return this._val}set val(t){this._val=t}}class A{constructor(t,e){this._weight=void 0!==t?t:1,this._val=e,this._hashCode=k()}get val(){return this._val}set val(t){this._val=t}get weight(){return this._weight}set weight(t){this._weight=t}get hashCode(){return this._hashCode}_setHashCode(t){this._hashCode=t}}class z{constructor(){this._vertices=new Map}get vertices(){return this._vertices}getVertex(t){return this._vertices.get(t)||null}hasVertex(t){return this._vertices.has(this._getVertexKey(t))}addVertex(t,e){if(t instanceof V)return this._addVertexOnly(t);{const s=this.createVertex(t,e);return this._addVertexOnly(s)}}removeVertex(t){const e=this._getVertexKey(t);return this._vertices.delete(e)}removeAllVertices(t){const e=[];for(const s of t)e.push(this.removeVertex(s));return e.length>0}hasEdge(t,e){return!!this.getEdge(t,e)}addEdge(t,e,s,r){if(t instanceof A)return this._addEdgeOnly(t);if(e instanceof V||"string"==typeof e||"number"==typeof e){if(!this.hasVertex(t)||!this.hasVertex(e))return!1;t instanceof V&&(t=t.key),e instanceof V&&(e=e.key);const i=this.createEdge(t,e,s,r);return this._addEdgeOnly(i)}throw new Error("dest must be a Vertex or vertex key while srcOrEdge is an Edge")}setEdgeWeight(t,e,s){const r=this.getEdge(t,e);return!!r&&(r.weight=s,!0)}getAllPathsBetween(t,e){const s=[],r=this._getVertex(t),i=this._getVertex(e);if(!r||!i)return[];const n=(t,e,i,h)=>{i.set(t,!0),t===e&&s.push([r,...h]);const o=this.getNeighbors(t);for(const t of o)i.get(t)||(h.push(t),n(t,e,i,h),E(h,(e=>e===t)));i.set(t,!1)};return n(r,i,new Map,[]),s}getPathSumWeight(t){var e;let s=0;for(let r=0;r<t.length;r++)s+=(null===(e=this.getEdge(t[r],t[r+1]))||void 0===e?void 0:e.weight)||0;return s}getMinCostBetween(t,e,s){if(void 0===s&&(s=!1),s){const s=this.getAllPathsBetween(t,e);let r=1/0;for(const t of s)r=Math.min(this.getPathSumWeight(t),r);return r}{const s=this._getVertex(e),r=this._getVertex(t);if(!r||!s)return null;const i=new Map,n=[r];i.set(r,!0);let h=0;for(;n.length>0;){for(let t=0;t<n.length;t++){const t=n.shift();if(t===s)return h;if(void 0!==t){const e=this.getNeighbors(t);for(const t of e)i.has(t)||(i.set(t,!0),n.push(t))}}h++}return null}}getMinPathBetween(t,e,s){if(void 0===s&&(s=!1),s){const s=this.getAllPathsBetween(t,e);let r=1/0,i=-1,n=0;for(const t of s){const e=this.getPathSumWeight(t);e<r&&(r=e,i=n),n++}return s[i]||null}{let s=[];const r=this._getVertex(t),i=this._getVertex(e);if(!r||!i)return[];const n=(t,e,i,h)=>{if(i.set(t,!0),t===e)return void(s=[r,...h]);const o=this.getNeighbors(t);for(const t of o)i.get(t)||(h.push(t),n(t,e,i,h),E(h,(e=>e===t)));i.set(t,!1)};return n(r,i,new Map,[]),s}}dijkstraWithoutHeap(t,e,s,r){void 0===s&&(s=!1),void 0===r&&(r=!1),void 0===e&&(e=null);let i=1/0,n=null,h=[];const o=[],l=this._vertices,a=new Map,u=new Set,c=new Map,f=this._getVertex(t),d=e?this._getVertex(e):null;if(!f)return null;for(const t of l){const e=t[1];e instanceof V&&a.set(e,1/0)}a.set(f,0),c.set(f,null);const g=()=>{let t=1/0,e=null;for(const[s,r]of a)u.has(s)||r<t&&(t=r,e=s);return e},p=t=>{for(const e of l){const s=e[1];if(s instanceof V){const r=[s];let i=c.get(s);for(;i;)r.push(i),i=c.get(i);const n=r.reverse();e[1]===t&&(h=n),o.push(n)}}};for(let t=1;t<l.size;t++){const t=g();if(t){if(u.add(t),d&&d===t)return s&&(i=a.get(d)||1/0),r&&p(d),{distMap:a,preMap:c,seen:u,paths:o,minDist:i,minPath:h};const e=this.getNeighbors(t);for(const s of e)if(!u.has(s)){const e=this.getEdge(t,s);if(e){const r=a.get(t),i=a.get(s);void 0!==r&&void 0!==i&&e.weight+r<i&&(a.set(s,e.weight+r),c.set(s,t))}}}}return s&&a.forEach(((t,e)=>{e!==f&&t<i&&(i=t,r&&(n=e))})),r&&p(n),{distMap:a,preMap:c,seen:u,paths:o,minDist:i,minPath:h}}dijkstra(t,e,s,r){var i;void 0===s&&(s=!1),void 0===r&&(r=!1),void 0===e&&(e=null);let n=1/0,h=null,o=[];const l=[],a=this._vertices,u=new Map,c=new Set,f=new Map,d=this._getVertex(t),g=e?this._getVertex(e):null;if(!d)return null;for(const t of a){const e=t[1];e instanceof V&&u.set(e,1/0)}const p=new N(((t,e)=>t.key-e.key));p.add({key:0,val:d}),u.set(d,0),f.set(d,null);const _=t=>{for(const e of a){const s=e[1];if(s instanceof V){const r=[s];let i=f.get(s);for(;i;)r.push(i),i=f.get(i);const n=r.reverse();e[1]===t&&(o=n),l.push(n)}}};for(;p.size>0;){const t=p.poll(),e=null==t?void 0:t.key,h=null==t?void 0:t.val;if(void 0!==e&&h){if(c.add(h),g&&g===h)return s&&(n=u.get(g)||1/0),r&&_(g),{distMap:u,preMap:f,seen:c,paths:l,minDist:n,minPath:o};const t=this.getNeighbors(h);for(const s of t)if(!c.has(s)){const t=null===(i=this.getEdge(h,s))||void 0===i?void 0:i.weight;if("number"==typeof t){const r=u.get(s);r&&e+t<r&&(p.add({key:e+t,val:s}),f.set(s,h),u.set(s,e+t))}}}}return s&&u.forEach(((t,e)=>{e!==d&&t<n&&(n=t,r&&(h=e))})),r&&_(h),{distMap:u,preMap:f,seen:c,paths:l,minDist:n,minPath:o}}bellmanFord(t,e,s,r){void 0===s&&(s=!1),void 0===r&&(r=!1);const i=this._getVertex(t),n=[],h=new Map,o=new Map;let l,a=1/0,u=[];if(e&&(l=!1),!i)return{hasNegativeCycle:l,distMap:h,preMap:o,paths:n,min:a,minPath:u};const c=this._vertices,f=c.size,d=this.edgeSet(),g=d.length;this._vertices.forEach((t=>{h.set(t,1/0)})),h.set(i,0);for(let t=1;t<f;++t)for(let t=0;t<g;++t){const e=this.getEndsOfEdge(d[t]);if(e){const[s,i]=e,n=d[t].weight,l=h.get(s),a=h.get(i);void 0!==l&&void 0!==a&&h.get(s)!==1/0&&l+n<a&&(h.set(i,l+n),r&&o.set(i,s))}}let p=null;if(s&&h.forEach(((t,e)=>{e!==i&&t<a&&(a=t,r&&(p=e))})),r)for(const t of c){const e=t[1];if(e instanceof V){const s=[e];let r=o.get(e);for(;void 0!==r;)s.push(r),r=o.get(r);const i=s.reverse();t[1]===p&&(u=i),n.push(i)}}for(let t=0;t<g;++t){const e=this.getEndsOfEdge(d[t]);if(e){const[s]=e,r=d[t].weight,i=h.get(s);i&&i!==1/0&&i+r<i&&(l=!0)}}return{hasNegativeCycle:l,distMap:h,preMap:o,paths:n,min:a,minPath:u}}floyd(){var t;const e=[...this._vertices],s=e.length,r=[],i=[];for(let t=0;t<s;t++){r[t]=[],i[t]=[];for(let e=0;e<s;e++)i[t][e]=null}for(let i=0;i<s;i++)for(let n=0;n<s;n++)r[i][n]=(null===(t=this.getEdge(e[i][1],e[n][1]))||void 0===t?void 0:t.weight)||1/0;for(let t=0;t<s;t++)for(let n=0;n<s;n++)for(let h=0;h<s;h++)r[n][h]>r[n][t]+r[t][h]&&(r[n][h]=r[n][t]+r[t][h],i[n][h]=e[t][1]);return{costs:r,predecessor:i}}tarjan(t,e,s,r){const i=!1;void 0===t&&(t=i),void 0===e&&(e=i),void 0===s&&(s=i),void 0===r&&(r=i);const n=new Map,h=new Map,o=this._vertices;o.forEach((t=>{n.set(t,-1),h.set(t,1/0)}));const[l]=o.values(),a=[],u=[];let c=0;const f=(s,r)=>{c++,n.set(s,c),h.set(s,c);const i=this.getNeighbors(s);let o=0;for(const c of i)if(c!==r){-1===n.get(c)&&(o++,f(c,s));const r=h.get(c),i=h.get(s);void 0!==i&&void 0!==r&&h.set(s,Math.min(i,r));const d=n.get(s);if(void 0!==r&&void 0!==d&&(t&&(s===l&&o>=2||s!==l&&r>=d)&&a.push(s),e&&r>d)){const t=this.getEdge(s,c);t&&u.push(t)}}};f(l,null);let d=new Map;const g=()=>{const t=new Map;return h.forEach(((e,s)=>{var r;t.has(e)?null===(r=t.get(e))||void 0===r||r.push(s):t.set(e,[s])})),t};s&&(d=g());const p=new Map;if(r){let t=new Map;t.size<1&&(t=g()),t.forEach(((t,e)=>{t.length>1&&p.set(e,t)}))}return{dfnMap:n,lowMap:h,bridges:u,articulationPoints:a,SCCs:d,cycles:p}}_addVertexOnly(t){return!this.hasVertex(t)&&(this._vertices.set(t.key,t),!0)}_getVertex(t){const e=this._getVertexKey(t);return this._vertices.get(e)||null}_getVertexKey(t){return t instanceof V?t.key:t}_setVertices(t){this._vertices=t}}class C extends V{constructor(t,e){super(t,e)}}class O extends A{constructor(t,e,s,r){super(s,r),this._src=t,this._dest=e}get src(){return this._src}set src(t){this._src=t}get dest(){return this._dest}set dest(t){this._dest=t}}class L extends z{constructor(){super(),this._outEdgeMap=new Map,this._inEdgeMap=new Map}get outEdgeMap(){return this._outEdgeMap}get inEdgeMap(){return this._inEdgeMap}createVertex(t,e){return new C(t,null!=e?e:t)}createEdge(t,e,s,r){return new O(t,e,null!=s?s:1,r)}getEdge(t,e){let s=[];if(null!==t&&null!==e){const r=this._getVertex(t),i=this._getVertex(e);if(r&&i){const t=this._outEdgeMap.get(r);t&&(s=t.filter((t=>t.dest===i.key)))}}return s[0]||null}removeEdgeSrcToDest(t,e){const s=this._getVertex(t),r=this._getVertex(e);let i=null;if(!s||!r)return null;const n=this._outEdgeMap.get(s);n&&E(n,(t=>t.dest===r.key));const h=this._inEdgeMap.get(r);return h&&(i=E(h,(t=>t.src===s.key))[0]||null),i}removeEdge(t){let e=null;const s=this._getVertex(t.src),r=this._getVertex(t.dest);if(s&&r){const t=this._outEdgeMap.get(s);t&&t.length>0&&E(t,(t=>t.src===s.key));const i=this._inEdgeMap.get(r);i&&i.length>0&&(e=E(i,(t=>t.dest===r.key))[0])}return e}removeEdgesBetween(t,e){const s=[];if(t&&e){const r=this.removeEdgeSrcToDest(t,e),i=this.removeEdgeSrcToDest(e,t);r&&s.push(r),i&&s.push(i)}return s}incomingEdgesOf(t){const e=this._getVertex(t);return e&&this.inEdgeMap.get(e)||[]}outgoingEdgesOf(t){const e=this._getVertex(t);return e&&this._outEdgeMap.get(e)||[]}degreeOf(t){return this.outDegreeOf(t)+this.inDegreeOf(t)}inDegreeOf(t){return this.incomingEdgesOf(t).length}outDegreeOf(t){return this.outgoingEdgesOf(t).length}edgesOf(t){return[...this.outgoingEdgesOf(t),...this.incomingEdgesOf(t)]}getEdgeSrc(t){return this._getVertex(t.src)}getEdgeDest(t){return this._getVertex(t.dest)}getDestinations(t){if(null===t)return[];const e=[],s=this.outgoingEdgesOf(t);for(const t of s){const s=this.getEdgeDest(t);s&&e.push(s)}return e}topologicalSort(t){t=null!=t?t:"key";const e=new Map;for(const t of this.vertices)e.set(t[1],0);let s=[],r=!1;const i=t=>{e.set(t,1);const n=this.getDestinations(t);for(const t of n){const s=e.get(t);0===s?i(t):1===s&&(r=!0)}e.set(t,2),s.push(t)};for(const t of this.vertices)0===e.get(t[1])&&i(t[1]);return r?null:("key"===t&&(s=s.map((t=>t instanceof C?t.key:t))),s.reverse())}edgeSet(){let t=[];return this._outEdgeMap.forEach((e=>{t=[...t,...e]})),t}getNeighbors(t){const e=[],s=this._getVertex(t);if(s){const t=this.outgoingEdgesOf(s);for(const s of t){const t=this._getVertex(s.dest);t&&e.push(t)}}return e}getEndsOfEdge(t){if(!this.hasEdge(t.src,t.dest))return null;const e=this._getVertex(t.src),s=this._getVertex(t.dest);return e&&s?[e,s]:null}_addEdgeOnly(t){if(!this.hasVertex(t.src)||!this.hasVertex(t.dest))return!1;const e=this._getVertex(t.src),s=this._getVertex(t.dest);if(e&&s){const r=this._outEdgeMap.get(e);r?r.push(t):this._outEdgeMap.set(e,[t]);const i=this._inEdgeMap.get(s);return i?i.push(t):this._inEdgeMap.set(s,[t]),!0}return!1}_setOutEdgeMap(t){this._outEdgeMap=t}_setInEdgeMap(t){this._inEdgeMap=t}}class P extends V{constructor(t,e){super(t,e)}}class I extends A{constructor(t,e,s,r){super(s,r),this._vertices=[t,e]}get vertices(){return this._vertices}set vertices(t){this._vertices=t}}class B extends z{constructor(){super(),this._edges=new Map}get edges(){return this._edges}createVertex(t,e){return new P(t,null!=e?e:t)}createEdge(t,e,s,r){return new I(t,e,null!=s?s:1,r)}getEdge(t,e){var s;let r=[];if(null!==t&&null!==e){const i=this._getVertex(t),n=this._getVertex(e);i&&n&&(r=null===(s=this._edges.get(i))||void 0===s?void 0:s.filter((t=>t.vertices.includes(n.key))))}return r&&r[0]||null}removeEdgeBetween(t,e){const s=this._getVertex(t),r=this._getVertex(e);if(!s||!r)return null;const i=this._edges.get(s);let n=null;i&&(n=E(i,(t=>t.vertices.includes(r.key)))[0]||null);const h=this._edges.get(r);return h&&E(h,(t=>t.vertices.includes(s.key))),n}removeEdge(t){return this.removeEdgeBetween(t.vertices[0],t.vertices[1])}degreeOf(t){var e;const s=this._getVertex(t);return s&&(null===(e=this._edges.get(s))||void 0===e?void 0:e.length)||0}edgesOf(t){const e=this._getVertex(t);return e&&this._edges.get(e)||[]}edgeSet(){const t=new Set;return this._edges.forEach((e=>{e.forEach((e=>{t.add(e)}))})),[...t]}getNeighbors(t){const e=[],s=this._getVertex(t);if(s){const t=this.edgesOf(s);for(const r of t){const t=this._getVertex(r.vertices.filter((t=>t!==s.key))[0]);t&&e.push(t)}}return e}getEndsOfEdge(t){if(!this.hasEdge(t.vertices[0],t.vertices[1]))return null;const e=this._getVertex(t.vertices[0]),s=this._getVertex(t.vertices[1]);return e&&s?[e,s]:null}_addEdgeOnly(t){for(const e of t.vertices){const s=this._getVertex(e);if(null===s)return!1;if(s){const e=this._edges.get(s);e?e.push(t):this._edges.set(s,[t])}}return!0}_setEdges(t){this._edges=t}}class F extends C{constructor(t,e,s,r){super(t,r),this._lat=e,this._long=s}get lat(){return this._lat}set lat(t){this._lat=t}get long(){return this._long}set long(t){this._long=t}}class D extends O{constructor(t,e,s,r){super(t,e,s,r)}}class H extends L{constructor(t,e){super(),this._origin=[0,0],this._origin=t,this._bottomRight=e}get origin(){return this._origin}set origin(t){this._origin=t}get bottomRight(){return this._bottomRight}set bottomRight(t){this._bottomRight=t}createVertex(t,e,s=this.origin[0],r=this.origin[1]){return new F(t,s,r,e)}createEdge(t,e,s,r){return new D(t,e,s,r)}}var j,U,q,G,K;!function(t){t.ITERATIVE="ITERATIVE",t.RECURSIVE="RECURSIVE"}(j||(j={})),function(t){t.ROOT="ROOT",t.LEFT="LEFT",t.RIGHT="RIGHT",t.ROOT_LEFT="ROOT_LEFT",t.ROOT_RIGHT="ROOT_RIGHT",t.ISOLATED="ISOLATED",t.MAL_NODE="MAL_NODE"}(U||(U={})),function(t){t.lt="lt",t.eq="eq",t.gt="gt"}(q||(q={})),function(t){t.RED="RED",t.BLACK="BLACK"}(G||(G={})),function(t){t.VAL="VAL",t.NODE="NODE",t.ID="ID"}(K||(K={}));class W{constructor(t,e){this.key=t,this.val=e}get left(){return this._left}set left(t){t&&(t.parent=this),this._left=t}get right(){return this._right}set right(t){t&&(t.parent=this),this._right=t}get familyPosition(){const t=this;return t.parent?t.parent.left===t?t.left||t.right?U.ROOT_LEFT:U.LEFT:t.parent.right===t?t.left||t.right?U.ROOT_RIGHT:U.RIGHT:U.MAL_NODE:t.left||t.right?U.ROOT:U.ISOLATED}}class Q{constructor(t){if(this._root=null,this._size=0,this._loopType=j.ITERATIVE,this.visitedKey=[],this.visitedVal=[],this.visitedNode=[],void 0!==t){const{loopType:e=j.ITERATIVE}=t;this._loopType=e}}createNode(t,e){return new W(t,e)}get root(){return this._root}get size(){return this._size}get loopType(){return this._loopType}swapLocation(t,e){const{key:s,val:r}=e,i=this.createNode(s,r);return i&&(e.key=t.key,e.val=t.val,t.key=i.key,t.val=i.val),e}clear(){this._root=null,this._size=0,this._clearResults()}isEmpty(){return 0===this.size}add(t,e){let s,r;if(null===t)r=null;else if("number"==typeof t)r=this.createNode(t,e);else{if(!(t instanceof W))return;r=t}const i=t?this.get(t,"key"):void 0;return this.root?i?(i.val=e,s=i):s=((t,e)=>{const s=[t];for(;s.length>0;){const t=s.shift();if(!t)return;{if(e&&t.key===e.key)return;const r=this._addTo(e,t);if(void 0!==r)return r;t.left&&s.push(t.left),t.right&&s.push(t.right)}}})(this.root,r):(this._setRoot(r),null!==r?this._setSize(1):this._setSize(0),s=this.root),s}addMany(t,e){const s=[];for(let r=0;r<t.length;r++){const i=t[r];if(i instanceof W){s.push(this.add(i.key,i.val));continue}if(null===i){s.push(this.add(null));continue}const n=null==e?void 0:e[r];s.push(this.add(i,n))}return s}refill(t,e){return this.clear(),t.length===this.addMany(t,e).length}remove(t){const e=[];if(!this.root)return e;const s="number"==typeof t?this.get(t):t;if(!s)return e;const r=(null==s?void 0:s.parent)?s.parent:null;let i=null,n=s;if(s.left){const t=s.left?this.getRightMost(s.left):null;if(t){const e=t.parent;n=this.swapLocation(s,t),e&&(e.right===t?e.right=t.left:e.left=t.left,i=e)}}else if(r){const{familyPosition:t}=s;t===U.LEFT||t===U.ROOT_LEFT?r.left=s.right:t!==U.RIGHT&&t!==U.ROOT_RIGHT||(r.right=s.right),i=r}else void 0!==s.right&&this._setRoot(s.right);return this._setSize(this.size-1),e.push({deleted:n,needBalanced:i}),e}getDepth(t,e=this.root){"number"==typeof t&&(t=this.get(t,"key")),"number"==typeof e&&(e=this.get(e,"key"));let s=0;for(;null==t?void 0:t.parent;){if(t===e)return s;s++,t=t.parent}return s}getHeight(t=this.root){if("number"==typeof t&&(t=this.get(t,"key")),!t)return-1;if(this._loopType===j.RECURSIVE){const e=t=>{if(!t)return-1;const s=e(t.left),r=e(t.right);return Math.max(s,r)+1};return e(t)}{if(!t)return-1;const e=[{node:t,depth:0}];let s=0;for(;e.length>0;){const{node:t,depth:r}=e.pop();t.left&&e.push({node:t.left,depth:r+1}),t.right&&e.push({node:t.right,depth:r+1}),s=Math.max(s,r)}return s}}getMinHeight(t=this.root){var e,s,r;if(!t)return-1;if(this._loopType===j.RECURSIVE){const e=t=>{if(!t)return 0;if(!t.left&&!t.right)return 0;const s=e(t.left),r=e(t.right);return Math.min(s,r)+1};return e(t)}{const i=[];let n=t,h=null;const o=new Map;for(;i.length>0||n;)if(n)i.push(n),n=n.left;else if(n=i[i.length-1],n.right&&h!==n.right)n=n.right;else if(n=i.pop(),n){const t=n.left&&null!==(e=o.get(n.left))&&void 0!==e?e:-1,r=n.right&&null!==(s=o.get(n.right))&&void 0!==s?s:-1;o.set(n,1+Math.min(t,r)),h=n,n=null}return null!==(r=o.get(t))&&void 0!==r?r:-1}}isPerfectlyBalanced(t=this.root){return this.getMinHeight(t)+1>=this.getHeight(t)}getNodes(t,e="key",s=!1){if(!this.root)return[];const r=[];if(this.loopType===j.RECURSIVE){const i=n=>{this._pushByPropertyNameStopOrNot(n,r,t,e,s)||(n.left||n.right)&&(n.left&&i(n.left),n.right&&i(n.right))};i(this.root)}else{const i=[this.root];for(;i.length>0;){const n=i.shift();if(n){if(this._pushByPropertyNameStopOrNot(n,r,t,e,s))return r;n.left&&i.push(n.left),n.right&&i.push(n.right)}}}return r}has(t,e="key"){return this.getNodes(t,e).length>0}get(t,e="key"){var s;return null!==(s=this.getNodes(t,e,!0)[0])&&void 0!==s?s:null}getPathToRoot(t,e=!0){const s=[];for(;t.parent;)s.push(t),t=t.parent;return s.push(t),e?s.reverse():s}getLeftMost(t=this.root){if("number"==typeof t&&(t=this.get(t,"key")),!t)return t;if(this._loopType===j.RECURSIVE){const e=t=>t.left?e(t.left):t;return e(t)}{const e=M((t=>t.left?e.cont(t.left):t));return e(t)}}getRightMost(t=this.root){if(!t)return t;if(this._loopType===j.RECURSIVE){const e=t=>t.right?e(t.right):t;return e(t)}{const e=M((t=>t.right?e.cont(t.right):t));return e(t)}}isSubtreeBST(t){if(!t)return!0;if(this._loopType===j.RECURSIVE){const e=(t,s,r)=>!t||!(t.key<=s||t.key>=r)&&e(t.left,s,t.key)&&e(t.right,t.key,r);return e(t,Number.MIN_SAFE_INTEGER,Number.MAX_SAFE_INTEGER)}{const e=[];let s=Number.MIN_SAFE_INTEGER,r=t;for(;r||e.length>0;){for(;r;)e.push(r),r=r.left;if(r=e.pop(),!r||s>=r.key)return!1;s=r.key,r=r.right}return!0}}isBST(){return this.isSubtreeBST(this.root)}getSubTreeSize(t){let e=0;if(!t)return e;if(this._loopType===j.RECURSIVE){const s=t=>{e++,t.left&&s(t.left),t.right&&s(t.right)};return s(t),e}{const s=[t];for(;s.length>0;){const t=s.pop();e++,t.right&&s.push(t.right),t.left&&s.push(t.left)}return e}}subTreeSum(t,e="key"){if("number"==typeof t&&(t=this.get(t,"key")),!t)return 0;let s=0;const r=t=>{let s;switch(e){case"key":default:s=t.key;break;case"val":s="number"==typeof t.val?t.val:0}return s};if(this._loopType===j.RECURSIVE){const e=t=>{s+=r(t),t.left&&e(t.left),t.right&&e(t.right)};e(t)}else{const e=[t];for(;e.length>0;){const t=e.pop();s+=r(t),t.right&&e.push(t.right),t.left&&e.push(t.left)}}return s}subTreeAdd(t,e,s="key"){if("number"==typeof t&&(t=this.get(t,"key")),!t)return!1;const r=t=>{t.key+=e};if(this._loopType===j.RECURSIVE){const e=t=>{r(t),t.left&&e(t.left),t.right&&e(t.right)};e(t)}else{const e=[t];for(;e.length>0;){const t=e.pop();r(t),t.right&&e.push(t.right),t.left&&e.push(t.left)}}return!0}bfs(t="key"){this._clearResults();const e=[this.root];for(;0!==e.length;){const s=e.shift();s&&(this._accumulatedByPropertyName(s,t),null!==(null==s?void 0:s.left)&&e.push(s.left),null!==(null==s?void 0:s.right)&&e.push(s.right))}return this._getResultByPropertyName(t)}dfs(t="in",e="key"){this._clearResults();const s=r=>{switch(t){case"in":r.left&&s(r.left),this._accumulatedByPropertyName(r,e),r.right&&s(r.right);break;case"pre":this._accumulatedByPropertyName(r,e),r.left&&s(r.left),r.right&&s(r.right);break;case"post":r.left&&s(r.left),r.right&&s(r.right),this._accumulatedByPropertyName(r,e)}};return this.root&&s(this.root),this._getResultByPropertyName(e)}dfsIterative(t="in",e="key"){if(this._clearResults(),!this.root)return this._getResultByPropertyName(e);const s=[{opt:0,node:this.root}];for(;s.length>0;){const r=s.pop();if(r&&r.node)if(1===r.opt)this._accumulatedByPropertyName(r.node,e);else switch(t){case"in":default:s.push({opt:0,node:r.node.right}),s.push({opt:1,node:r.node}),s.push({opt:0,node:r.node.left});break;case"pre":s.push({opt:0,node:r.node.right}),s.push({opt:0,node:r.node.left}),s.push({opt:1,node:r.node});break;case"post":s.push({opt:1,node:r.node}),s.push({opt:0,node:r.node.right}),s.push({opt:0,node:r.node.left})}}return this._getResultByPropertyName(e)}levelIterative(t=this.root,e="key"){if(!t)return[];this._clearResults();const s=[t];for(;s.length>0;){const t=s.shift();t&&(this._accumulatedByPropertyName(t,e),t.left&&s.push(t.left),t.right&&s.push(t.right))}return this._getResultByPropertyName(e)}listLevels(t=this.root,e="key"){if(!t)return[];const s=[],r=(t,r)=>{switch(e){case"key":default:s[r].push(t.key);break;case"val":s[r].push(t.val);break;case"node":s[r].push(t)}};if(this.loopType===j.RECURSIVE){const e=(t,i)=>{s[i]||(s[i]=[]),r(t,i),t.left&&e(t.left,i+1),t.right&&e(t.right,i+1)};e(t,0)}else{const e=[[t,0]];for(;e.length>0;){const t=e.pop(),[i,n]=t;s[n]||(s[n]=[]),r(i,n),i.right&&e.push([i.right,n+1]),i.left&&e.push([i.left,n+1])}}return s}getPredecessor(t){if(t.left){let e=t.left;for(;!e||e.right&&e.right!==t;)e&&(e=e.right);return e}return t}morris(t="in",e="key"){if(null===this.root)return[];this._clearResults();let s=this.root;const r=t=>{let e=null,s=null;for(;t;)s=t.right,t.right=e,e=t,t=s;return e},i=t=>{const s=r(t);let i=s;for(;i;)this._accumulatedByPropertyName(i,e),i=i.right;r(s)};switch(t){case"in":for(;s;){if(s.left){const t=this.getPredecessor(s);if(!t.right){t.right=s,s=s.left;continue}t.right=null}this._accumulatedByPropertyName(s,e),s=s.right}break;case"pre":for(;s;){if(s.left){const t=this.getPredecessor(s);if(!t.right){t.right=s,this._accumulatedByPropertyName(s,e),s=s.left;continue}t.right=null}else this._accumulatedByPropertyName(s,e);s=s.right}break;case"post":for(;s;){if(s.left){const t=this.getPredecessor(s);if(null===t.right){t.right=s,s=s.left;continue}t.right=null,i(s.left)}s=s.right}i(this.root)}return this._getResultByPropertyName(e)}_addTo(t,e){return e?void 0===e.left?(e.left=t,t&&this._setSize(this.size+1),e.left):void 0===e.right?(e.right=t,t&&this._setSize(this.size+1),e.right):void 0:void 0}_setLoopType(t){this._loopType=t}_setRoot(t){t&&(t.parent=void 0),this._root=t}_setSize(t){this._size=t}_clearResults(){this.visitedKey=[],this.visitedVal=[],this.visitedNode=[]}_pushByPropertyNameStopOrNot(t,e,s,r="key",i=!1){switch(r){case"key":default:if(t.key===s)return e.push(t),i;break;case"val":if(t.val===s)return e.push(t),i}}_accumulatedByPropertyName(t,e="key"){switch(e){case"key":default:this.visitedKey.push(t.key);break;case"val":this.visitedVal.push(t.val);break;case"node":this.visitedNode.push(t)}}_getResultByPropertyName(t="key"){switch(t){case"key":default:return this.visitedKey;case"val":return this.visitedVal;case"node":return this.visitedNode}}}class Y extends W{constructor(t,e){super(t,e)}}class J extends Q{constructor(t){if(super(t),this._comparator=(t,e)=>t-e,void 0!==t){const{comparator:e}=t;void 0!==e&&(this._comparator=e)}}createNode(t,e){return new Y(t,e)}add(t,e){let s=null,r=null;if(t instanceof Y?r=t:"number"==typeof t?r=this.createNode(t,e):null===t&&(r=null),null===this.root)this._setRoot(r),this._setSize(this.size+1),s=this.root;else{let t=this.root,e=!0;for(;e;)null!==t&&null!==r?this._compare(t.key,r.key)===q.eq?(r&&(t.val=r.val),e=!1,s=t):this._compare(t.key,r.key)===q.gt?void 0===t.left?(r&&(r.parent=t),t.left=r,this._setSize(this.size+1),e=!1,s=t.left):t.left&&(t=t.left):this._compare(t.key,r.key)===q.lt&&(void 0===t.right?(r&&(r.parent=t),t.right=r,this._setSize(this.size+1),e=!1,s=t.right):t.right&&(t=t.right)):e=!1}return s}addMany(t,e,s=!1){if(!s||-1!==t.indexOf(null))return super.addMany(t,e);const r=[],i=t.map(((t,s)=>[t,null==e?void 0:e[s]]));let n=[],h=[],o=[];if(function(t){for(const[e]of t)if(e instanceof Y)return!0;return!1}(i))n=i.sort(((t,e)=>t[0].key-e[0].key));else{if(!function(t){for(const[e]of t)if("number"==typeof e)return!0;return!1}(i))throw new Error("Invalid input keysOrNodes");n=i.sort(((t,e)=>t[0]-e[0]))}h=n.map((([t])=>t)),o=n.map((([,t])=>t));const l=(t,e)=>{if(0===t.length)return;const s=Math.floor((t.length-1)/2),i=this.add(t[s],null==e?void 0:e[s]);r.push(i),l(t.slice(0,s),null==e?void 0:e.slice(0,s)),l(t.slice(s+1),null==e?void 0:e.slice(s+1))};return this.loopType===j.RECURSIVE?l(h,o):(()=>{const t=[[0,n.length-1]];for(;t.length>0;){const e=t.pop();if(e){const[s,i]=e;if(s<=i){const e=s+Math.floor((i-s)/2),n=this.add(h[e],null==o?void 0:o[e]);r.push(n),t.push([e+1,i]),t.push([s,e-1])}}}})(),r}get(t,e="key"){var s;return null!==(s=this.getNodes(t,e,!0)[0])&&void 0!==s?s:null}lastKey(){var t,e,s,r,i,n;return this._compare(0,1)===q.lt?null!==(e=null===(t=this.getRightMost())||void 0===t?void 0:t.key)&&void 0!==e?e:0:this._compare(0,1)===q.gt?null!==(r=null===(s=this.getLeftMost())||void 0===s?void 0:s.key)&&void 0!==r?r:0:null!==(n=null===(i=this.getRightMost())||void 0===i?void 0:i.key)&&void 0!==n?n:0}getNodes(t,e="key",s=!1){if(!this.root)return[];const r=[];if(this.loopType===j.RECURSIVE){const i=n=>{this._pushByPropertyNameStopOrNot(n,r,t,e,s)||(n.left||n.right)&&("key"===e?(this._compare(n.key,t)===q.gt&&n.left&&i(n.left),this._compare(n.key,t)===q.lt&&n.right&&i(n.right)):(n.left&&i(n.left),n.right&&i(n.right)))};i(this.root)}else{const i=[this.root];for(;i.length>0;){const n=i.shift();if(n){if(this._pushByPropertyNameStopOrNot(n,r,t,e,s))return r;"key"===e?(this._compare(n.key,t)===q.gt&&n.left&&i.push(n.left),this._compare(n.key,t)===q.lt&&n.right&&i.push(n.right)):(n.left&&i.push(n.left),n.right&&i.push(n.right))}}}return r}lesserSum(t,e="key"){if("number"==typeof t&&(t=this.get(t,"key")),!t)return 0;if(!this.root)return 0;const s=t.key,r=t=>{let e;return e=t.key,e};let i=0;if(this.loopType===j.RECURSIVE){const t=n=>{const h=this._compare(n.key,s);if(h!==q.eq)if(h===q.lt){if(n.left&&(i+=this.subTreeSum(n.left,e)),i+=r(n),!n.right)return;t(n.right)}else{if(!n.left)return;t(n.left)}else n.right&&(i+=this.subTreeSum(n.right,e))};t(this.root)}else{const t=[this.root];for(;t.length>0;){const n=t.shift();if(n){const h=this._compare(n.key,s);if(h===q.eq)return n.right&&(i+=this.subTreeSum(n.right,e)),i;if(h===q.lt){if(n.left&&(i+=this.subTreeSum(n.left,e)),i+=r(n),!n.right)return i;t.push(n.right)}else{if(!n.left)return i;t.push(n.left)}}}}return i}allGreaterNodesAdd(t,e,s="key"){if("number"==typeof t&&(t=this.get(t,"key")),!t)return!1;const r=t.key;if(!this.root)return!1;const i=t=>{t.key+=e};if(this.loopType===j.RECURSIVE){const t=e=>{this._compare(e.key,r)===q.gt&&i(e),(e.left||e.right)&&(e.left&&this._compare(e.left.key,r)===q.gt&&t(e.left),e.right&&this._compare(e.right.key,r)===q.gt&&t(e.right))};return t(this.root),!0}{const t=[this.root];for(;t.length>0;){const e=t.shift();e&&(this._compare(e.key,r)===q.gt&&i(e),e.left&&this._compare(e.left.key,r)===q.gt&&t.push(e.left),e.right&&this._compare(e.right.key,r)===q.gt&&t.push(e.right))}return!0}}perfectlyBalance(){const t=this.dfs("in","node"),e=t.length;if(this.clear(),t.length<1)return!1;if(this.loopType===j.RECURSIVE){const s=(e,r)=>{if(e>r)return;const i=e+Math.floor((r-e)/2),n=t[i];this.add(n.key,n.val),s(e,i-1),s(i+1,r)};return s(0,e-1),!0}{const s=[[0,e-1]];for(;s.length>0;){const e=s.pop();if(e){const[r,i]=e;if(r<=i){const e=r+Math.floor((i-r)/2),n=t[e];this.add(n.key,n.val),s.push([e+1,i]),s.push([r,e-1])}}}return!0}}isAVLBalanced(){var t,e;if(!this.root)return!0;let s=!0;if(this.loopType===j.RECURSIVE){const t=e=>{if(!e)return 0;const r=t(e.left),i=t(e.right);return Math.abs(r-i)>1&&(s=!1),Math.max(r,i)+1};t(this.root)}else{const s=[];let r=this.root,i=null;const n=new Map;for(;s.length>0||r;)if(r)s.push(r),r=r.left;else if(r=s[s.length-1],r.right&&i!==r.right)r=r.right;else if(r=s.pop(),r){const s=r.left&&null!==(t=n.get(r.left))&&void 0!==t?t:-1,h=r.right&&null!==(e=n.get(r.right))&&void 0!==e?e:-1;if(Math.abs(s-h)>1)return!1;n.set(r,1+Math.max(s,h)),i=r,r=null}}return s}_compare(t,e){const s=this._comparator(t,e);return s>0?q.gt:s<0?q.lt:q.eq}}class X{constructor(t){this._sumTree=new Array(t+1).fill(0)}get sumTree(){return this._sumTree}static lowBit(t){return t&-t}update(t,e){for(;t<this._sumTree.length;)this._sumTree[t]+=e,t+=X.lowBit(t)}getPrefixSum(t){let e=0;for(;t>0;)e+=this._sumTree[t],t-=X.lowBit(t);return e}getRangeSum(t,e){if(!(0<=t&&t<=e&&e<=this._sumTree.length))throw"Index out of bounds";return this.getPrefixSum(e)-this.getPrefixSum(t)}_setSumTree(t){this._sumTree=t}}class Z{constructor(t,e,s,r){this._start=0,this._end=0,this._val=null,this._sum=0,this._left=null,this._right=null,this._start=t,this._end=e,this._sum=s,this._val=r||null}get start(){return this._start}set start(t){this._start=t}get end(){return this._end}set end(t){this._end=t}get val(){return this._val}set val(t){this._val=t}get sum(){return this._sum}set sum(t){this._sum=t}get left(){return this._left}set left(t){this._left=t}get right(){return this._right}set right(t){this._right=t}}class ${constructor(t,e,s){this._values=[],this._start=0,e=e||0,s=s||t.length-1,this._values=t,this._start=e,this._end=s,t.length>0?this._root=this.build(e,s):(this._root=null,this._values=[])}get values(){return this._values}get start(){return this._start}get end(){return this._end}get root(){return this._root}build(t,e){if(t>e)return new Z(t,e,0);if(t===e)return new Z(t,e,this._values[t]);const s=t+Math.floor((e-t)/2),r=this.build(t,s),i=this.build(s+1,e),n=new Z(t,e,r.sum+i.sum);return n.left=r,n.right=i,n}updateNode(t,e,s){const r=this.root||null;if(!r)return;const i=(t,e,s,r)=>{if(t.start===t.end&&t.start===e)return t.sum=s,void(void 0!==r&&(t.val=r));e<=t.start+Math.floor((t.end-t.start)/2)?t.left&&i(t.left,e,s,r):t.right&&i(t.right,e,s,r),t.left&&t.right&&(t.sum=t.left.sum+t.right.sum)};i(r,t,e,s)}querySumByRange(t,e){const s=this.root||null;if(!s)return 0;if(t<0||e>=this.values.length||t>e)return NaN;const r=(t,e,s)=>{if(e<=t.start&&s>=t.end)return t.sum;const i=t.start+Math.floor((t.end-t.start)/2);if(s<=i)return t.left?r(t.left,e,s):NaN;if(e>i)return t.right?r(t.right,e,s):NaN;{let n=0,h=0;return t.left&&(n=r(t.left,e,i)),t.right&&(h=r(t.right,i+1,s)),n+h}};return r(s,t,e)}_setValues(t){this._values=t}_setStart(t){this._start=t}_setEnd(t){this._end=t}_setRoot(t){this._root=t}}class tt extends Y{constructor(t,e){super(t,e),this.height=0}}class et extends J{constructor(t){super(t)}swapLocation(t,e){const{key:s,val:r,height:i}=e,n=this.createNode(s,r);return n&&(n.height=i,e.key=t.key,e.val=t.val,e.height=t.height,t.key=n.key,t.val=n.val,t.height=n.height),e}createNode(t,e){return new tt(t,e)}add(t,e){const s=super.add(t,e);return s&&this._balancePath(s),s}remove(t){const e=super.remove(t);for(const{needBalanced:t}of e)t&&this._balancePath(t);return e}_balanceFactor(t){return t.right?t.left?t.right.height-t.left.height:+t.height:-t.height}_updateHeight(t){if(t.left||t.right)if(t.left)t.right?t.height=1+Math.max(t.right.height,t.left.height):t.height=1+t.left.height;else{const e=t.right?t.right.height:0;t.height=1+e}else t.height=0}_balancePath(t){const e=this.getPathToRoot(t,!1);for(let t=0;t<e.length;t++){const s=e[t];switch(this._updateHeight(s),this._balanceFactor(s)){case-2:s&&s.left&&(this._balanceFactor(s.left)<=0?this._balanceLL(s):this._balanceLR(s));break;case 2:s&&s.right&&(this._balanceFactor(s.right)>=0?this._balanceRR(s):this._balanceRL(s))}}}_balanceLL(t){const e=t.parent,s=t.left;t.parent=s,s&&s.right&&(s.right.parent=t),s&&(s.parent=e),t===this.root?s&&this._setRoot(s):(null==e?void 0:e.left)===t?e.left=s:e&&(e.right=s),s&&(t.left=s.right,s.right=t),this._updateHeight(t),s&&this._updateHeight(s)}_balanceLR(t){const e=t.parent,s=t.left;let r=null;s&&(r=s.right),t&&(t.parent=r),s&&(s.parent=r),r&&(r.left&&(r.left.parent=s),r.right&&(r.right.parent=t),r.parent=e),t===this.root?r&&this._setRoot(r):e&&(e.left===t?e.left=r:e.right=r),r&&(t.left=r.right,s&&(s.right=r.left),r.left=s,r.right=t),this._updateHeight(t),s&&this._updateHeight(s),r&&this._updateHeight(r)}_balanceRR(t){const e=t.parent,s=t.right;t.parent=s,s&&(s.left&&(s.left.parent=t),s.parent=e),t===this.root?s&&this._setRoot(s):e&&(e.left===t?e.left=s:e.right=s),s&&(t.right=s.left,s.left=t),this._updateHeight(t),s&&this._updateHeight(s)}_balanceRL(t){const e=t.parent,s=t.right;let r=null;s&&(r=s.left),t.parent=r,s&&(s.parent=r),r&&(r.left&&(r.left.parent=t),r.right&&(r.right.parent=s),r.parent=e),t===this.root?r&&this._setRoot(r):e&&(e.left===t?e.left=r:e.right=r),r&&(t.right=r.left),s&&r&&(s.left=r.right),r&&(r.left=t),r&&(r.right=s),this._updateHeight(t),s&&this._updateHeight(s),r&&this._updateHeight(r)}}class st extends Y{constructor(t,e){super(t,e),this._color=G.RED}get color(){return this._color}set color(t){this._color=t}}class rt extends J{constructor(t){super(t)}createNode(t,e){return new st(t,e)}}class it extends tt{constructor(t,e,s=1){super(t,e),this.count=s}}class nt extends et{constructor(t){super(t),this._count=0}get count(){return this._count}createNode(t,e,s){return new it(t,e,s)}swapLocation(t,e){const{key:s,val:r,count:i,height:n}=e,h=this.createNode(s,r,i);return h&&(h.height=n,e.key=t.key,e.val=t.val,e.count=t.count,e.height=t.height,t.key=h.key,t.val=h.val,t.count=h.count,t.height=h.height),e}add(t,e,s=1){let r,i;if(i=t instanceof it?this.createNode(t.key,t.val,t.count):null===t?null:this.createNode(t,e,s),this.root){let t=this.root,e=!0;for(;e;)t?i&&(this._compare(t.key,i.key)===q.eq?(t.val=i.val,t.count+=i.count,this._setCount(this.count+i.count),e=!1,r=t):this._compare(t.key,i.key)===q.gt?void 0===t.left?(t.left=i,this._setSize(this.size+1),this._setCount(this.count+i.count),e=!1,r=t.left):t.left&&(t=t.left):this._compare(t.key,i.key)===q.lt&&(void 0===t.right?(t.right=i,this._setSize(this.size+1),this._setCount(this.count+i.count),e=!1,r=t.right):t.right&&(t=t.right))):e=!1}else this._setRoot(i),this._setSize(this.size+1),i&&this._setCount(this.count+i.count),r=this.root;return r&&this._balancePath(r),r}_addTo(t,e){return e?void 0===e.left?(e.left=t,null!==t&&(this._setSize(this.size+1),this._setCount(this.count+t.count)),e.left):void 0===e.right?(e.right=t,null!==t&&(this._setSize(this.size+1),this._setCount(this.count+t.count)),e.right):void 0:void 0}addMany(t,e){const s=[];for(let r=0;r<t.length;r++){const i=t[r];i instanceof it?s.push(this.add(i.key,i.val,i.count)):null!==i?s.push(this.add(i,null==e?void 0:e[r],1)):s.push(this.add(NaN,null,0))}return s}perfectlyBalance(){const t=this.dfs("in","node"),e=t.length;if(t.length<1)return!1;if(this.clear(),this.loopType===j.RECURSIVE){const s=(e,r)=>{if(e>r)return;const i=e+Math.floor((r-e)/2),n=t[i];this.add(n.key,n.val,n.count),s(e,i-1),s(i+1,r)};return s(0,e-1),!0}{const s=[[0,e-1]];for(;s.length>0;){const e=s.pop();if(e){const[r,i]=e;if(r<=i){const e=r+Math.floor((i-r)/2),n=t[e];this.add(n.key,n.val,n.count),s.push([e+1,i]),s.push([r,e-1])}}}return!0}}remove(t,e=!1){const s=[];if(!this.root)return s;const r=this.get(t);if(!r)return s;const i=(null==r?void 0:r.parent)?r.parent:null;let n=null,h=r;if(r.count>1&&!e)r.count--,this._setCount(this.count-1);else{if(r.left){const t=r.left?this.getRightMost(r.left):null;if(t){const e=t.parent;h=this.swapLocation(r,t),e&&(e.right===t?e.right=t.left:e.left=t.left,n=e)}}else if(i){const{familyPosition:t}=r;t===U.LEFT||t===U.ROOT_LEFT?i.left=r.right:t!==U.RIGHT&&t!==U.ROOT_RIGHT||(i.right=r.right),n=i}else void 0!==r.right&&this._setRoot(r.right);this._setSize(this.size-1),this._setCount(this.count-h.count)}return s.push({deleted:h,needBalanced:n}),n&&this._balancePath(n),s}getSubTreeCount(t){const e=[0,0];if(!t)return e;if(this.loopType===j.RECURSIVE){const s=t=>{e[0]++,e[1]+=t.count,t.left&&s(t.left),t.right&&s(t.right)};return s(t),e}{const s=[t];for(;s.length>0;){const t=s.pop();e[0]++,e[1]+=t.count,t.right&&s.push(t.right),t.left&&s.push(t.left)}return e}}subTreeSumCount(t){if("number"==typeof t&&(t=this.get(t,"key")),!t)return 0;let e=0;if(this.loopType===j.RECURSIVE){const s=t=>{e+=t.count,t.left&&s(t.left),t.right&&s(t.right)};s(t)}else{const s=[t];for(;s.length>0;){const t=s.pop();e+=t.count,t.right&&s.push(t.right),t.left&&s.push(t.left)}}return e}subTreeAddCount(t,e){if("number"==typeof t&&(t=this.get(t,"key")),!t)return!1;const s=t=>{t.count+=e,this._setCount(this.count+e)};if(this.loopType===j.RECURSIVE){const e=t=>{s(t),t.left&&e(t.left),t.right&&e(t.right)};e(t)}else{const e=[t];for(;e.length>0;){const t=e.pop();s(t),t.right&&e.push(t.right),t.left&&e.push(t.left)}}return!0}getNodesByCount(t,e=!1){if(!this.root)return[];const s=[];if(this.loopType===j.RECURSIVE){const r=i=>{i.count===t&&(s.push(i),e)||(i.left||i.right)&&(i.left&&r(i.left),i.right&&r(i.right))};r(this.root)}else{const r=[this.root];for(;r.length>0;){const i=r.shift();if(i){if(i.count===t&&(s.push(i),e))return s;i.left&&r.push(i.left),i.right&&r.push(i.right)}}}return s}BFSCount(){return super.bfs("node").map((t=>t.count))}listLevelsCount(t){return super.listLevels(t,"node").map((t=>t.map((t=>t.count))))}morrisCount(t="in"){return super.morris(t,"node").map((t=>t.count))}dfsCountIterative(t="in"){return super.dfsIterative(t,"node").map((t=>t.count))}dfsCount(t="in"){return super.dfs(t,"node").map((t=>t.count))}lesserSumCount(t){if("number"==typeof t&&(t=this.get(t,"key")),!t)return 0;if(!this.root)return 0;const e=t.key;let s=0;if(this.loopType===j.RECURSIVE){const t=r=>{const i=this._compare(r.key,e);if(i!==q.eq)if(i===q.lt){if(r.left&&(s+=this.subTreeSumCount(r.left)),s+=r.count,!r.right)return;t(r.right)}else{if(!r.left)return;t(r.left)}else r.right&&(s+=this.subTreeSumCount(r.right))};t(this.root)}else{const t=[this.root];for(;t.length>0;){const r=t.shift();if(r){const i=this._compare(r.key,e);if(i===q.eq)return r.right&&(s+=this.subTreeSumCount(r.right)),s;if(i===q.lt){if(r.left&&(s+=this.subTreeSumCount(r.left)),s+=r.count,!r.right)return s;t.push(r.right)}else{if(!r.left)return s;t.push(r.left)}}}}return s}allGreaterNodesAddCount(t,e){if("number"==typeof t&&(t=this.get(t,"key")),!t)return!1;const s=t.key;if(!this.root)return!1;if(this.loopType===j.RECURSIVE){const t=r=>{this._compare(r.key,s)===q.gt&&(r.count+=e),(r.left||r.right)&&(r.left&&this._compare(r.left.key,s)===q.gt&&t(r.left),r.right&&this._compare(r.right.key,s)===q.gt&&t(r.right))};return t(this.root),!0}{const t=[this.root];for(;t.length>0;){const r=t.shift();r&&(this._compare(r.key,s)===q.gt&&(r.count+=e),r.left&&this._compare(r.left.key,s)===q.gt&&t.push(r.left),r.right&&this._compare(r.right.key,s)===q.gt&&t.push(r.right))}return!0}}clear(){super.clear(),this._setCount(0)}_setCount(t){this._count=t}}class ht{constructor(t,e,s){this._key=t,this._value=e||void 0,this._children=s||[]}get key(){return this._key}set key(t){this._key=t}get value(){return this._value}set value(t){this._value=t}get children(){return this._children}set children(t){this._children=t}addChildren(t){this.children||(this.children=[]),t instanceof ht?this.children.push(t):this.children=this.children.concat(t)}getHeight(){let t=0;if(this){const e=(s,r)=>{r>t&&(t=r);const{children:i}=s;if(i)for(let t=0,s=i.length;t<s;t++)e(i[t],r+1)};e(this,0)}return t}}class ot extends S{constructor(t=((t,e)=>{if("number"!=typeof t||"number"!=typeof e)throw new Error("The a, b params of compare function must be number");return e-t})){super(t)}}class lt extends S{constructor(t=((t,e)=>{if("number"!=typeof t||"number"!=typeof e)throw new Error("The a, b params of compare function must be number");return t-e})){super(t)}}class at extends N{constructor(t=((t,e)=>{if("number"!=typeof t||"number"!=typeof e)throw new Error("The a, b params of compare function must be number");return t-e})){super(t)}}class ut extends N{constructor(t=((t,e)=>{if("number"!=typeof t||"number"!=typeof e)throw new Error("The a, b params of compare function must be number");return e-t})){super(t)}}class ct{constructor(t){const{row:e,col:s,initialVal:r}=t;this._matrix=new Array(e).fill(void 0).map((()=>new Array(s).fill(r||0)))}toArray(){return this._matrix}}class ft{constructor(t=0,e=0,s=1){this.x=t,this.y=e,this.w=s}get isZero(){return 0===this.x&&0===this.y}get length(){return Math.sqrt(this.x*this.x+this.y*this.y)}get lengthSq(){return this.x*this.x+this.y*this.y}get rounded(){return new ft(Math.round(this.x),Math.round(this.y))}static add(t,e){return new ft(t.x+e.x,t.y+e.y)}static subtract(t,e){return new ft(t.x-e.x,t.y-e.y)}static subtractValue(t,e){return new ft(t.x-e,t.y-e)}static multiply(t,e){return new ft(t.x*e,t.y*e)}static divide(t,e){return new ft(t.x/e,t.y/e)}static equals(t,e){return t.x===e.x&&t.y===e.y}static equalsRounded(t,e,s=12){const r=ft.abs(ft.subtract(t,e));return r.x<s&&r.y<s}static normalize(t){const e=t.length;return e>2220446049250313e-31?ft.divide(t,e):t}static truncate(t,e){return t.length>e?ft.multiply(ft.normalize(t),e):t}static perp(t){return new ft(-t.y,t.x)}static reverse(t){return new ft(-t.x,-t.y)}static abs(t){return new ft(Math.abs(t.x),Math.abs(t.y))}static dot(t,e){return t.x*e.x+t.y*e.y}static distance(t,e){const s=e.y-t.y,r=e.x-t.x;return Math.sqrt(s*s+r*r)}static distanceSq(t,e){const s=e.y-t.y,r=e.x-t.x;return s*s+r*r}static sign(t,e){return t.y*e.x>t.x*e.y?-1:1}static angle(t){const e=new ft(0,-1),s=Math.acos(ft.dot(t,e)/(t.length*e.length));return 1===ft.sign(t,e)?2*Math.PI-s:s}static random(t,e){const s=Math.floor(Math.random()*t-t/2),r=Math.floor(Math.random()*e-e/2);return new ft(s,r)}zero(){this.x=0,this.y=0}}const dt=ft;class gt{constructor(t){void 0===t?this._matrix=gt.identity:t instanceof dt?(this._matrix=gt.identity,this._matrix[0][0]=t.x,this._matrix[1][0]=t.y,this._matrix[2][0]=t.w):this._matrix=t}static get empty(){return[[],[],[]]}static get identity(){return[[1,0,0],[0,1,0],[0,0,1]]}get m(){return this._matrix}toVector(){return new dt(this._matrix[0][0],this._matrix[1][0])}static add(t,e){const s=gt.empty;for(let r=0;r<3;r++)for(let i=0;i<3;i++)s[r][i]=t.m[r][i]+e.m[r][i];return new gt(s)}static subtract(t,e){const s=gt.empty;for(let r=0;r<3;r++)for(let i=0;i<3;i++)s[r][i]=t.m[r][i]-e.m[r][i];return new gt(s)}static multiply(t,e){const s=gt.empty;for(let r=0;r<3;r++)for(let i=0;i<3;i++){s[r][i]=0;for(let n=0;n<3;n++)s[r][i]+=t.m[r][n]*e.m[n][i]}return new gt(s)}static multiplyByValue(t,e){const s=gt.empty;for(let r=0;r<3;r++)for(let i=0;i<3;i++)s[r][i]=t.m[r][i]*e;return new gt(s)}static multiplyByVector(t,e){return gt.multiply(t,new gt(e)).toVector()}static view(t,e){const s=t/2,r=e/2,i=Math.cos(Math.PI);return new gt([[1,0,s],[0,1*i,r],[0,0,1]])}static scale(t){return gt.multiplyByValue(new gt,t)}static rotate(t){const e=Math.cos(t),s=Math.sin(t);return new gt([[e,-s,0],[s,e,0],[0,0,1]])}static translate(t){return new gt([[1,0,t.x],[0,1,t.y],[0,0,t.w]])}}class pt{constructor(t,e){this.direction=t,this.turn=()=>new pt(e[t],e)}}class _t{constructor({matrix:t,turning:e,onMove:s,init:{cur:r,charDir:i,VISITED:n}}){this._matrix=t,this._cur=r,this._character=new pt(i,e),this.onMove=s,this.onMove&&this.onMove(this._cur),this._VISITED=n,this._matrix[this._cur[0]][this._cur[1]]=this._VISITED}start(){for(;this.check(this._character.direction)||this.check(this._character.turn().direction);){const{direction:t}=this._character;this.check(t)?this.move(t):this.check(this._character.turn().direction)&&(this._character=this._character.turn())}}check(t){let e,s;const r=this._matrix,[i,n]=this._cur;switch(t){case"up":if(s=r[i-1],!s)return!1;e=s[n];break;case"right":e=r[i][n+1];break;case"down":if(s=r[i+1],!s)return!1;e=s[n];break;case"left":e=r[i][n-1]}return void 0!==e&&e!==this._VISITED}move(t){switch(t){case"up":this._cur[0]--;break;case"right":this._cur[1]++;break;case"down":this._cur[0]++;break;case"left":this._cur[1]--}const[e,s]=this._cur;this._matrix[e][s]=this._VISITED,this.onMove&&this.onMove(this._cur)}}class yt{constructor(t){this._key=t,this._isEnd=!1,this._children=new Map}get key(){return this._key}set key(t){this._key=t}get children(){return this._children}set children(t){this._children=t}get isEnd(){return this._isEnd}set isEnd(t){this._isEnd=t}}class vt{constructor(t,e=!0){if(this._root=new yt(""),this._caseSensitive=e,t)for(const e of t)this.add(e)}get root(){return this._root}set root(t){this._root=t}add(t){t=this._caseProcess(t);let e=this.root;for(const s of t){let t=e.children.get(s);t||(t=new yt(s),e.children.set(s,t)),e=t}return e.isEnd=!0,!0}has(t){t=this._caseProcess(t);let e=this.root;for(const s of t){const t=e.children.get(s);if(!t)return!1;e=t}return e.isEnd}_caseProcess(t){return this._caseSensitive||(t=t.toLowerCase()),t}remove(t){t=this._caseProcess(t);let e=!1;const s=(r,i)=>{const n=t[i],h=r.children.get(n);return!!h&&(i===t.length-1?!!h.isEnd&&(h.children.size>0?h.isEnd=!1:r.children.delete(n),e=!0,!0):!(!s(h,i+1)||r.isEnd||0!==h.children.size||(r.children.delete(n),0)))};return s(this.root,0),e}getHeight(){const t=this.root;let e=0;if(t){const s=(t,r)=>{r>e&&(e=r);const{children:i}=t;if(i)for(const t of i.entries())s(t[1],r+1)};s(t,0)}return e}hasPurePrefix(t){t=this._caseProcess(t);let e=this.root;for(const s of t){const t=e.children.get(s);if(!t)return!1;e=t}return!e.isEnd}hasPrefix(t){t=this._caseProcess(t);let e=this.root;for(const s of t){const t=e.children.get(s);if(!t)return!1;e=t}return!0}hasCommonPrefix(t){t=this._caseProcess(t);let e="";const s=r=>{e+=r.key,e!==t&&(r.isEnd||r&&r.children&&1===r.children.size&&s(Array.from(r.children.values())[0]))};return s(this.root),e===t}getLongestCommonPrefix(){let t="";const e=s=>{t+=s.key,s.isEnd||s&&s.children&&1===s.children.size&&e(Array.from(s.children.values())[0])};return e(this.root),t}getWords(t="",e=Number.MAX_SAFE_INTEGER){t=this._caseProcess(t);const s=[];let r=0,i=this.root;if(t)for(const e of t){const t=i.children.get(e);t&&(i=t)}return i!==this.root&&function t(i,n){for(const e of i.children.keys()){const s=i.children.get(e);void 0!==s&&t(s,n.concat(e))}if(i.isEnd){if(r>e-1)return;s.push(n),r++}}(i,t),s}}return e})()));
//# sourceMappingURL=bundle.min.js.map