/**
 * data-structure-typed
 *
 * @author Tyler Zeng
 * @copyright Copyright (c) 2022 Tyler Zeng <zrwusa@gmail.com>
 * @license MIT License
 */
import type { BinaryTreeNodeKey, BinaryTreeNodePropertyName, BSTComparator, BSTNodeNested, BSTOptions } from '../../types';
import { CP } from '../../types';
import { BinaryTree, BinaryTreeNode } from './binary-tree';
import { IBinaryTree } from '../../interfaces';
export declare class BSTNode<V = any, FAMILY extends BSTNode<V, FAMILY> = BSTNodeNested<V>> extends BinaryTreeNode<V, FAMILY> {
    constructor(key: BinaryTreeNodeKey, val?: V);
}
export declare class BST<N extends BSTNode<N['val'], N> = BSTNode> extends BinaryTree<N> implements IBinaryTree<N> {
    /**
     * The constructor function initializes a binary search tree object with an optional comparator function.
     * @param {BSTOptions} [options] - An optional object that contains configuration options for the binary search tree.
     */
    constructor(options?: BSTOptions);
    /**
     * The function creates a new binary search tree node with the given key and value.
     * @param {BinaryTreeNodeKey} key - The `key` parameter is the identifier for the binary tree node. It is used to uniquely
     * identify each node in the binary tree.
     * @param [val] - The `val` parameter is an optional value that can be assigned to the node. It represents the value
     * that will be stored in the node.
     * @returns a new instance of the BSTNode class with the specified key and value.
     */
    createNode(key: BinaryTreeNodeKey, val?: N['val']): N;
    /**
     * The `add` function adds a new node to a binary search tree, either by creating a new node or by updating an existing
     * node with the same ID.
     * @param {BinaryTreeNodeKey | N | null} keyOrNode - The `keyOrNode` parameter can be either a `BinaryTreeNodeKey` or a `N`
     * (which represents a binary tree node) or `null`.
     * @param [val] - The `val` parameter is an optional value that can be assigned to the `val` property of the new node
     * being added to the binary search tree.
     * @returns The function `add` returns the inserted node (`inserted`) which can be of type `N`, `null`, or `undefined`.
     */
    add(keyOrNode: BinaryTreeNodeKey | N | null, val?: N['val']): N | null | undefined;
    /**
     * The `addMany` function overrides the base class method to add multiple nodes to a binary search tree in a balanced
     * manner.
     * @param {[BinaryTreeNodeKey | N , N['val']][]} keysOrNodes - The `keysOrNodes` parameter in the `addMany` function is an array of
     * `BinaryTreeNodeKey` or `N` (node) objects, or `null` values. It represents the nodes or node IDs that need to be added
     * to the binary search tree.
     * @param {N['val'][]} data - The values of tree nodes
     * @param {boolean} isBalanceAdd - If true the nodes will be balance inserted in binary search method.
     * @returns The function `addMany` returns an array of `N`, `null`, or `undefined` values.
     */
    addMany(keysOrNodes: (BinaryTreeNodeKey | null)[] | (N | null)[], data?: N['val'][], isBalanceAdd?: boolean): (N | null | undefined)[];
    /**
     * The function returns the first node in a binary tree that matches the given property name and value.
     * @param {BinaryTreeNodeKey | N} nodeProperty - The `nodeProperty` parameter can be either a `BinaryTreeNodeKey` or a
     * generic type `N`. It represents the property of the binary tree node that you want to search for.
     * @param {BinaryTreeNodePropertyName} [propertyName] - The `propertyName` parameter is an optional parameter that
     * specifies the property name to use for searching the binary tree nodes. If not provided, it defaults to `'key'`.
     * @returns The method is returning either a BinaryTreeNodeKey or N (generic type) or null.
     */
    get(nodeProperty: BinaryTreeNodeKey | N, propertyName?: BinaryTreeNodePropertyName): N | null;
    /**
     * The function returns the key of the rightmost node if the comparison between two values is less than, the key of the
     * leftmost node if the comparison is greater than, and the key of the rightmost node otherwise.
     * @returns The method `lastKey()` returns the key of the rightmost node in the binary tree if the comparison between
     * the values at index 0 and 1 is less than, otherwise it returns the key of the leftmost node. If the comparison is
     * equal, it returns the key of the rightmost node. If there are no nodes in the tree, it returns 0.
     */
    lastKey(): BinaryTreeNodeKey;
    /**
     * The function `getNodes` returns an array of nodes in a binary tree that match a given property value.
     * @param {BinaryTreeNodeKey | N} nodeProperty - The `nodeProperty` parameter can be either a `BinaryTreeNodeKey` or an
     * `N` type. It represents the property of the binary tree node that you want to compare with.
     * @param {BinaryTreeNodePropertyName} [propertyName] - The `propertyName` parameter is an optional parameter that
     * specifies the property name to use for comparison. If not provided, it defaults to `'key'`.
     * @param {boolean} [onlyOne] - The `onlyOne` parameter is an optional boolean parameter that determines whether to
     * return only one node that matches the given `nodeProperty` or all nodes that match the `nodeProperty`. If `onlyOne`
     * is set to `true`, the function will return an array with only one node (if
     * @returns an array of nodes (type N).
     */
    getNodes(nodeProperty: BinaryTreeNodeKey | N, propertyName?: BinaryTreeNodePropertyName, onlyOne?: boolean): N[];
    /**
     * The `lesserSum` function calculates the sum of property values in a binary tree for nodes that have a property value
     * less than a given node.
     * @param {N | BinaryTreeNodeKey | null} beginNode - The `beginNode` parameter can be one of the following:
     * @param {BinaryTreeNodePropertyName} [propertyName] - The `propertyName` parameter is an optional parameter that
     * specifies the property name to use for calculating the sum. If not provided, it defaults to `'key'`.
     * @returns The function `lesserSum` returns a number, which represents the sum of the values of the nodes in the
     * binary tree that have a lesser value than the specified `beginNode` based on the `propertyName`.
     */
    lesserSum(beginNode: N | BinaryTreeNodeKey | null, propertyName?: BinaryTreeNodePropertyName): number;
    /**
     * The `allGreaterNodesAdd` function adds a delta value to the specified property of all nodes in a binary tree that
     * have a greater value than a given node.
     * @param {N | BinaryTreeNodeKey | null} node - The `node` parameter can be either of type `N` (a generic type),
     * `BinaryTreeNodeKey`, or `null`. It represents the node in the binary tree to which the delta value will be added.
     * @param {number} delta - The `delta` parameter is a number that represents the amount by which the property value of
     * each greater node should be increased.
     * @param {BinaryTreeNodePropertyName} [propertyName] - The `propertyName` parameter is an optional parameter that
     * specifies the property name of the nodes in the binary tree that you want to update. If not provided, it defaults to
     * 'key'.
     * @returns a boolean value.
     */
    allGreaterNodesAdd(node: N | BinaryTreeNodeKey | null, delta: number, propertyName?: BinaryTreeNodePropertyName): boolean;
    /**
     * Balancing Adjustment:
     * Perfectly Balanced Binary Tree: Since the balance of a perfectly balanced binary tree is already fixed, no additional balancing adjustment is needed. Any insertion or deletion operation will disrupt the perfect balance, often requiring a complete reconstruction of the tree.
     * AVL Tree: After insertion or deletion operations, an AVL tree performs rotation adjustments based on the balance factor of nodes to restore the tree's balance. These rotations can be left rotations, right rotations, left-right rotations, or right-left rotations, performed as needed.
     *
     * Use Cases and Efficiency:
     * Perfectly Balanced Binary Tree: Perfectly balanced binary trees are typically used in specific scenarios such as complete binary heaps in heap sort or certain types of Huffman trees. However, they are not suitable for dynamic operations requiring frequent insertions and deletions, as these operations often necessitate full tree reconstruction.
     * AVL Tree: AVL trees are well-suited for scenarios involving frequent searching, insertion, and deletion operations. Through rotation adjustments, AVL trees maintain their balance, ensuring average and worst-case time complexity of O(log n).
     */
    /**
     * The `perfectlyBalance` function takes a binary tree, performs a depth-first search to sort the nodes, and then
     * constructs a balanced binary search tree using either a recursive or iterative approach.
     * @returns The function `perfectlyBalance()` returns a boolean value.
     */
    perfectlyBalance(): boolean;
    /**
     * The function `isAVLBalanced` checks if a binary tree is balanced according to the AVL tree property.
     * @returns a boolean value.
     */
    isAVLBalanced(): boolean;
    protected _comparator: BSTComparator;
    /**
     * The function compares two binary tree node IDs using a comparator function and returns whether the first ID is
     * greater than, less than, or equal to the second ID.
     * @param {BinaryTreeNodeKey} a - "a" is a BinaryTreeNodeKey, which represents the identifier of a binary tree node.
     * @param {BinaryTreeNodeKey} b - The parameter "b" in the above code refers to a BinaryTreeNodeKey.
     * @returns a value of type CP (ComparisonResult). The possible return values are CP.gt (greater than), CP.lt (less
     * than), or CP.eq (equal).
     */
    protected _compare(a: BinaryTreeNodeKey, b: BinaryTreeNodeKey): CP;
}
