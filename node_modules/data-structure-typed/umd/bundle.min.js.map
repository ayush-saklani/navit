{"version":3,"file":"bundle.min.js","mappings":"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","sources":["webpack://dataStructureTyped/webpack/universalModuleDefinition","webpack://dataStructureTyped/webpack/bootstrap","webpack://dataStructureTyped/webpack/runtime/define property getters","webpack://dataStructureTyped/webpack/runtime/hasOwnProperty shorthand","webpack://dataStructureTyped/webpack/runtime/make namespace object","webpack://dataStructureTyped/./src/data-structures/hash/hash-table.ts","webpack://dataStructureTyped/./src/data-structures/hash/coordinate-map.ts","webpack://dataStructureTyped/./src/data-structures/hash/coordinate-set.ts","webpack://dataStructureTyped/./src/data-structures/hash/tree-map.ts","webpack://dataStructureTyped/./src/data-structures/hash/tree-set.ts","webpack://dataStructureTyped/./src/data-structures/hash/hash-map.ts","webpack://dataStructureTyped/./src/data-structures/linked-list/singly-linked-list.ts","webpack://dataStructureTyped/./src/data-structures/linked-list/doubly-linked-list.ts","webpack://dataStructureTyped/./src/data-structures/linked-list/skip-linked-list.ts","webpack://dataStructureTyped/./src/data-structures/stack/stack.ts","webpack://dataStructureTyped/./src/data-structures/queue/queue.ts","webpack://dataStructureTyped/./src/data-structures/queue/deque.ts","webpack://dataStructureTyped/./src/utils/utils.ts","webpack://dataStructureTyped/./src/data-structures/heap/heap.ts","webpack://dataStructureTyped/./src/data-structures/priority-queue/priority-queue.ts","webpack://dataStructureTyped/./src/data-structures/graph/abstract-graph.ts","webpack://dataStructureTyped/./src/data-structures/graph/directed-graph.ts","webpack://dataStructureTyped/./src/data-structures/graph/undirected-graph.ts","webpack://dataStructureTyped/./src/data-structures/graph/map-graph.ts","webpack://dataStructureTyped/./src/types/data-structures/binary-tree.ts","webpack://dataStructureTyped/./src/types/data-structures/bst.ts","webpack://dataStructureTyped/./src/types/data-structures/rb-tree.ts","webpack://dataStructureTyped/./src/types/data-structures/directed-graph.ts","webpack://dataStructureTyped/./src/data-structures/binary-tree/binary-tree.ts","webpack://dataStructureTyped/./src/data-structures/binary-tree/bst.ts","webpack://dataStructureTyped/./src/data-structures/binary-tree/binary-indexed-tree.ts","webpack://dataStructureTyped/./src/data-structures/binary-tree/segment-tree.ts","webpack://dataStructureTyped/./src/data-structures/binary-tree/avl-tree.ts","webpack://dataStructureTyped/./src/data-structures/binary-tree/rb-tree.ts","webpack://dataStructureTyped/./src/data-structures/binary-tree/tree-multiset.ts","webpack://dataStructureTyped/./src/data-structures/tree/tree.ts","webpack://dataStructureTyped/./src/data-structures/heap/max-heap.ts","webpack://dataStructureTyped/./src/data-structures/heap/min-heap.ts","webpack://dataStructureTyped/./src/data-structures/priority-queue/min-priority-queue.ts","webpack://dataStructureTyped/./src/data-structures/priority-queue/max-priority-queue.ts","webpack://dataStructureTyped/./src/data-structures/matrix/matrix.ts","webpack://dataStructureTyped/./src/data-structures/matrix/vector2d.ts","webpack://dataStructureTyped/./src/data-structures/matrix/matrix2d.ts","webpack://dataStructureTyped/./src/data-structures/matrix/navigator.ts","webpack://dataStructureTyped/./src/data-structures/trie/trie.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"dataStructureTyped\"] = factory();\n\telse\n\t\troot[\"dataStructureTyped\"] = factory();\n})(self, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * data-structure-typed\n *\n * @author Tyler Zeng\n * @copyright Copyright (c) 2022 Tyler Zeng <zrwusa@gmail.com>\n * @license MIT License\n */\nexport class HashTableNode {\n    constructor(key, val) {\n        this.key = key;\n        this.val = val;\n        this.next = null;\n    }\n}\nexport class HashTable {\n    get hashFn() {\n        return this._hashFn;\n    }\n    set hashFn(value) {\n        this._hashFn = value;\n    }\n    get buckets() {\n        return this._buckets;\n    }\n    set buckets(value) {\n        this._buckets = value;\n    }\n    get capacity() {\n        return this._capacity;\n    }\n    set capacity(value) {\n        this._capacity = value;\n    }\n    constructor(capacity = HashTable.DEFAULT_CAPACITY, hashFn) {\n        this._hashFn = hashFn || this._defaultHashFn;\n        this._capacity = Math.max(capacity, HashTable.DEFAULT_CAPACITY);\n        this._size = 0;\n        this._buckets = new Array(this._capacity).fill(null);\n    }\n    /**\n     * The function `_defaultHashFn` calculates the hash value of a given key and returns the remainder when divided by the\n     * capacity of the data structure.\n     * @param {K} key - The `key` parameter is the input value that needs to be hashed. It can be of any type, but in this\n     * code snippet, it is checked whether the key is a string or an object. If it is a string, the `_murmurStringHashFn`\n     * function is used to\n     * @returns the hash value of the key modulo the capacity of the data structure.\n     */\n    _defaultHashFn(key) {\n        // Can be replaced with other hash functions as needed\n        const hashValue = typeof key === 'string' ? this._murmurStringHashFn(key) : this._objectHash(key);\n        return hashValue % this._capacity;\n    }\n    /**\n     * The `_multiplicativeStringHashFn` function calculates a hash value for a given string key using the multiplicative\n     * string hash function.\n     * @param {K} key - The `key` parameter is the input value for which we want to calculate the hash. It can be of any\n     * type, as it is generic (`K`). The function converts the `key` to a string using the `String()` function.\n     * @returns a number, which is the result of the multiplicative string hash function applied to the input key.\n     */\n    _multiplicativeStringHashFn(key) {\n        const keyString = String(key);\n        let hash = 0;\n        for (let i = 0; i < keyString.length; i++) {\n            const charCode = keyString.charCodeAt(i);\n            // Some constants for adjusting the hash function\n            const A = 0.618033988749895;\n            const M = 1 << 30; // 2^30\n            hash = (hash * A + charCode) % M;\n        }\n        return Math.abs(hash); // Take absolute value to ensure non-negative numbers\n    }\n    /**\n     * The function `_murmurStringHashFn` calculates a hash value for a given string key using the MurmurHash algorithm.\n     * @param {K} key - The `key` parameter is the input value for which you want to calculate the hash. It can be of any\n     * type, but it will be converted to a string using the `String()` function before calculating the hash.\n     * @returns a number, which is the hash value calculated for the given key.\n     */\n    _murmurStringHashFn(key) {\n        const keyString = String(key);\n        const seed = 0;\n        let hash = seed;\n        for (let i = 0; i < keyString.length; i++) {\n            const char = keyString.charCodeAt(i);\n            hash = (hash ^ char) * 0x5bd1e995;\n            hash = (hash ^ (hash >>> 15)) * 0x27d4eb2d;\n            hash = hash ^ (hash >>> 15);\n        }\n        return Math.abs(hash);\n    }\n    /**\n     * The _hash function takes a key and returns a number.\n     * @param {K} key - The parameter \"key\" is of type K, which represents the type of the key that will be hashed.\n     * @returns The hash function is returning a number.\n     */\n    _hash(key) {\n        return this.hashFn(key);\n    }\n    /**\n     * The function calculates a hash value for a given string using the djb2 algorithm.\n     * @param {string} key - The `key` parameter in the `stringHash` function is a string value that represents the input for\n     * which we want to calculate the hash value.\n     * @returns a number, which is the hash value of the input string.\n     */\n    _stringHash(key) {\n        let hash = 0;\n        for (let i = 0; i < key.length; i++) {\n            hash = (hash * 31 + key.charCodeAt(i)) & 0xffffffff;\n        }\n        return hash;\n    }\n    /**\n     * The function `_objectHash` takes a key and returns a hash value, using a custom hash function for objects.\n     * @param {K} key - The parameter \"key\" is of type \"K\", which means it can be any type. It could be a string, number,\n     * boolean, object, or any other type of value. The purpose of the objectHash function is to generate a hash value for\n     * the key, which can be used for\n     * @returns a number, which is the hash value of the key.\n     */\n    _objectHash(key) {\n        // If the key is an object, you can write a custom hash function\n        // For example, convert the object's properties to a string and use string hashing\n        // This is just an example; you should write a specific object hash function as needed\n        return this._stringHash(JSON.stringify(key));\n    }\n    /**\n     * The set function adds a key-value pair to the hash table, handling collisions and resizing if necessary.\n     * @param {K} key - The key parameter represents the key of the key-value pair that you want to insert into the hash\n     * table. It is of type K, which is a generic type representing the key's data type.\n     * @param {V} val - The parameter `val` represents the value that you want to associate with the given key in the hash\n     * table.\n     * @returns Nothing is being returned. The return type of the `put` method is `void`, which means it does not return any\n     * value.\n     */\n    set(key, val) {\n        const index = this._hash(key);\n        const newNode = new HashTableNode(key, val);\n        if (!this._buckets[index]) {\n            this._buckets[index] = newNode;\n        }\n        else {\n            // Handle collisions, consider using open addressing, etc.\n            let currentNode = this._buckets[index];\n            while (currentNode) {\n                if (currentNode.key === key) {\n                    // If the key already exists, update the value\n                    currentNode.val = val;\n                    return;\n                }\n                if (!currentNode.next) {\n                    break;\n                }\n                currentNode = currentNode.next;\n            }\n            // Add to the end of the linked list\n            currentNode.next = newNode;\n        }\n        this._size++;\n        // If the load factor is too high, resize the hash table\n        if (this._size / this._capacity >= HashTable.LOAD_FACTOR) {\n            this._expand();\n        }\n    }\n    /**\n     * The `get` function retrieves the value associated with a given key from a hash table.\n     * @param {K} key - The `key` parameter represents the key of the element that we want to retrieve from the data\n     * structure.\n     * @returns The method is returning the value associated with the given key if it exists in the hash table. If the key is\n     * not found, it returns `undefined`.\n     */\n    get(key) {\n        const index = this._hash(key);\n        let currentNode = this._buckets[index];\n        while (currentNode) {\n            if (currentNode.key === key) {\n                return currentNode.val;\n            }\n            currentNode = currentNode.next;\n        }\n        return undefined; // Key not found\n    }\n    /**\n     * The remove function removes a key-value pair from a hash table.\n     * @param {K} key - The `key` parameter represents the key of the key-value pair that needs to be removed from the hash\n     * table.\n     * @returns Nothing is being returned. The `remove` method has a return type of `void`, which means it does not return\n     * any value.\n     */\n    remove(key) {\n        const index = this._hash(key);\n        let currentNode = this._buckets[index];\n        let prevNode = null;\n        while (currentNode) {\n            if (currentNode.key === key) {\n                if (prevNode) {\n                    prevNode.next = currentNode.next;\n                }\n                else {\n                    this._buckets[index] = currentNode.next;\n                }\n                this._size--;\n                currentNode.next = null; // Release memory\n                return;\n            }\n            prevNode = currentNode;\n            currentNode = currentNode.next;\n        }\n    }\n    /**\n     * The `expand` function increases the capacity of a hash table by creating a new array of buckets with double the\n     * capacity and rehashing all the existing key-value pairs into the new buckets.\n     */\n    _expand() {\n        const newCapacity = this._capacity * 2;\n        const newBuckets = new Array(newCapacity).fill(null);\n        for (const bucket of this._buckets) {\n            let currentNode = bucket;\n            while (currentNode) {\n                const newIndex = this._hash(currentNode.key);\n                const newNode = new HashTableNode(currentNode.key, currentNode.val);\n                if (!newBuckets[newIndex]) {\n                    newBuckets[newIndex] = newNode;\n                }\n                else {\n                    let currentNewNode = newBuckets[newIndex];\n                    while (currentNewNode.next) {\n                        currentNewNode = currentNewNode.next;\n                    }\n                    currentNewNode.next = newNode;\n                }\n                currentNode = currentNode.next;\n            }\n        }\n        this._buckets = newBuckets;\n        this._capacity = newCapacity;\n    }\n    get size() {\n        return this._size;\n    }\n}\nHashTable.DEFAULT_CAPACITY = 16;\nHashTable.LOAD_FACTOR = 0.75;\n","/**\n * data-structure-typed\n *\n * @author Tyler Zeng\n * @copyright Copyright (c) 2022 Tyler Zeng <zrwusa@gmail.com>\n * @license MIT License\n */\nexport class CoordinateMap extends Map {\n    constructor(joint) {\n        super();\n        this._joint = '_';\n        if (joint !== undefined)\n            this._joint = joint;\n    }\n    get joint() {\n        return this._joint;\n    }\n    /**\n     * The \"has\" function overrides the base class's \"has\" function and checks if a key exists in the map by joining the\n     * key array with a specified delimiter.\n     * @param {number[]} key - The parameter \"key\" is an array of numbers.\n     * @returns The `has` method is being overridden to return the result of calling the `has` method of the superclass\n     * (`super.has`) with the `key` array joined together using the `_joint` property.\n     */\n    has(key) {\n        return super.has(key.join(this._joint));\n    }\n    /**\n     * The function overrides the set method of a Map object to convert the key from an array to a string using a specified\n     * delimiter before calling the original set method.\n     * @param {number[]} key - The key parameter is an array of numbers.\n     * @param {V} value - The value parameter is the value that you want to associate with the specified key.\n     * @returns The `set` method is returning the result of calling the `set` method of the superclass\n     * (`super.set(key.join(this._joint), value)`).\n     */\n    set(key, value) {\n        return super.set(key.join(this._joint), value);\n    }\n    /**\n     * The function overrides the get method to join the key array with a specified joint and then calls the super get\n     * method.\n     * @param {number[]} key - An array of numbers\n     * @returns The code is returning the value associated with the specified key in the map.\n     */\n    get(key) {\n        return super.get(key.join(this._joint));\n    }\n    /**\n     * The function overrides the delete method and joins the key array using a specified joint character before calling\n     * the super delete method.\n     * @param {number[]} key - An array of numbers that represents the key to be deleted.\n     * @returns The `delete` method is returning the result of calling the `delete` method on the superclass, with the\n     * `key` array joined together using the `_joint` property.\n     */\n    delete(key) {\n        return super.delete(key.join(this._joint));\n    }\n    _setJoint(v) {\n        this._joint = v;\n    }\n}\n","/**\n * data-structure-typed\n *\n * @author Tyler Zeng\n * @copyright Copyright (c) 2022 Tyler Zeng <zrwusa@gmail.com>\n * @license MIT License\n */\nexport class CoordinateSet extends Set {\n    constructor(joint) {\n        super();\n        this._joint = '_';\n        if (joint !== undefined)\n            this._joint = joint;\n    }\n    get joint() {\n        return this._joint;\n    }\n    /**\n     * The \"has\" function overrides the \"has\" method of the superclass and checks if a value exists in an array after\n     * joining its elements with a specified separator.\n     * @param {number[]} value - The parameter \"value\" is an array of numbers.\n     * @returns The overridden `has` method is returning the result of calling the `has` method of the superclass, passing\n     * in the joined value as an argument.\n     */\n    has(value) {\n        return super.has(value.join(this._joint));\n    }\n    /**\n     * The \"add\" function overrides the parent class's \"add\" function by joining the elements of the input array with a\n     * specified delimiter before calling the parent class's \"add\" function.\n     * @param {number[]} value - An array of numbers\n     * @returns The overridden `add` method is returning the result of calling the `add` method of the superclass\n     * (`super.add`) with the joined string representation of the `value` array (`value.join(this._joint)`).\n     */\n    add(value) {\n        return super.add(value.join(this._joint));\n    }\n    /**\n     * The function overrides the delete method and deletes an element from a Set by joining the elements of the input\n     * array with a specified joint and then calling the delete method of the parent class.\n     * @param {number[]} value - An array of numbers\n     * @returns The `delete` method is returning the result of calling the `delete` method of the superclass, with the\n     * `value` array joined together using the `_joint` property.\n     */\n    delete(value) {\n        return super.delete(value.join(this._joint));\n    }\n    _setJoint(v) {\n        this._joint = v;\n    }\n}\n","export class TreeMap {\n}\n","export class TreeSet {\n}\n","/**\n * data-structure-typed\n *\n * @author Tyler Zeng\n * @copyright Copyright (c) 2022 Tyler Zeng <zrwusa@gmail.com>\n * @license MIT License\n */\nexport class HashMap {\n    get hashFn() {\n        return this._hashFn;\n    }\n    set hashFn(value) {\n        this._hashFn = value;\n    }\n    get table() {\n        return this._table;\n    }\n    set table(value) {\n        this._table = value;\n    }\n    get capacityMultiplier() {\n        return this._capacityMultiplier;\n    }\n    set capacityMultiplier(value) {\n        this._capacityMultiplier = value;\n    }\n    get loadFactor() {\n        return this._loadFactor;\n    }\n    set loadFactor(value) {\n        this._loadFactor = value;\n    }\n    get initialCapacity() {\n        return this._initialCapacity;\n    }\n    set initialCapacity(value) {\n        this._initialCapacity = value;\n    }\n    get size() {\n        return this._size;\n    }\n    set size(value) {\n        this._size = value;\n    }\n    /**\n     * The constructor initializes the properties of a hash table, including the initial capacity, load factor, capacity\n     * multiplier, size, table array, and hash function.\n     * @param [initialCapacity=16] - The initial capacity is the initial size of the hash table. It determines the number of\n     * buckets or slots available for storing key-value pairs. The default value is 16.\n     * @param [loadFactor=0.75] - The load factor is a measure of how full the hash table can be before it is resized. It is\n     * a value between 0 and 1, where 1 means the hash table is completely full and 0 means it is completely empty. When the\n     * load factor is reached, the hash table will\n     * @param [hashFn] - The `hashFn` parameter is an optional parameter that represents the hash function used to calculate\n     * the index of a key in the hash table. If a custom hash function is not provided, a default hash function is used. The\n     * default hash function converts the key to a string, calculates the sum of the\n     */\n    constructor(initialCapacity = 16, loadFactor = 0.75, hashFn) {\n        this._initialCapacity = initialCapacity;\n        this._loadFactor = loadFactor;\n        this._capacityMultiplier = 2;\n        this._size = 0;\n        this._table = new Array(initialCapacity);\n        this._hashFn =\n            hashFn ||\n                ((key) => {\n                    const strKey = String(key);\n                    let hash = 0;\n                    for (let i = 0; i < strKey.length; i++) {\n                        hash += strKey.charCodeAt(i);\n                    }\n                    return hash % this.table.length;\n                });\n    }\n    _hash(key) {\n        return this._hashFn(key);\n    }\n    /**\n     * The `resizeTable` function resizes the table used in a hash map by creating a new table with a specified capacity and\n     * rehashing the key-value pairs from the old table into the new table.\n     * @param {number} newCapacity - The newCapacity parameter is the desired capacity for the resized table. It represents\n     * the number of buckets that the new table should have.\n     */\n    resizeTable(newCapacity) {\n        const newTable = new Array(newCapacity);\n        for (const bucket of this._table) {\n            // Note that this is this._table\n            if (bucket) {\n                for (const [key, value] of bucket) {\n                    const newIndex = this._hash(key) % newCapacity;\n                    if (!newTable[newIndex]) {\n                        newTable[newIndex] = [];\n                    }\n                    newTable[newIndex].push([key, value]);\n                }\n            }\n        }\n        this._table = newTable; // Again, here is this._table\n    }\n    set(key, value) {\n        const loadFactor = this.size / this.table.length;\n        if (loadFactor >= this.loadFactor) {\n            this.resizeTable(this.table.length * this.capacityMultiplier);\n        }\n        const index = this._hash(key);\n        if (!this.table[index]) {\n            this.table[index] = [];\n        }\n        // Check if the key already exists in the bucket\n        for (let i = 0; i < this.table[index].length; i++) {\n            if (this.table[index][i][0] === key) {\n                this.table[index][i][1] = value;\n                return;\n            }\n        }\n        this.table[index].push([key, value]);\n        this.size++;\n    }\n    get(key) {\n        const index = this._hash(key);\n        if (!this.table[index]) {\n            return undefined;\n        }\n        for (const [k, v] of this.table[index]) {\n            if (k === key) {\n                return v;\n            }\n        }\n        return undefined;\n    }\n    remove(key) {\n        const index = this._hash(key);\n        if (!this.table[index]) {\n            return;\n        }\n        for (let i = 0; i < this.table[index].length; i++) {\n            if (this.table[index][i][0] === key) {\n                this.table[index].splice(i, 1);\n                this.size--;\n                // Check if the table needs to be resized down\n                const loadFactor = this.size / this.table.length;\n                if (loadFactor < this.loadFactor / this.capacityMultiplier) {\n                    this.resizeTable(this.table.length / this.capacityMultiplier);\n                }\n                return;\n            }\n        }\n    }\n    *entries() {\n        for (const bucket of this.table) {\n            if (bucket) {\n                for (const [key, value] of bucket) {\n                    yield [key, value];\n                }\n            }\n        }\n    }\n    [Symbol.iterator]() {\n        return this.entries();\n    }\n    clear() {\n        this.size = 0;\n        this.table = new Array(this.initialCapacity);\n    }\n    isEmpty() {\n        return this.size === 0;\n    }\n}\n","/**\n * data-structure-typed\n *\n * @author Tyler Zeng\n * @copyright Copyright (c) 2022 Tyler Zeng <zrwusa@gmail.com>\n * @license MIT License\n */\nexport class SinglyLinkedListNode {\n    /**\n     * The constructor function initializes an instance of a class with a given value and sets the next property to null.\n     * @param {E} val - The \"val\" parameter is of type E, which means it can be any data type. It represents the value that\n     * will be stored in the node of a linked list.\n     */\n    constructor(val) {\n        this._val = val;\n        this._next = null;\n    }\n    get val() {\n        return this._val;\n    }\n    set val(value) {\n        this._val = value;\n    }\n    get next() {\n        return this._next;\n    }\n    set next(value) {\n        this._next = value;\n    }\n}\nexport class SinglyLinkedList {\n    /**\n     * The constructor initializes the linked list with an empty head, tail, and length.\n     */\n    constructor() {\n        this._head = null;\n        this._tail = null;\n        this._length = 0;\n    }\n    get head() {\n        return this._head;\n    }\n    set head(value) {\n        this._head = value;\n    }\n    get tail() {\n        return this._tail;\n    }\n    set tail(value) {\n        this._tail = value;\n    }\n    get length() {\n        return this._length;\n    }\n    /**\n     * The `fromArray` function creates a new SinglyLinkedList instance and populates it with the elements from the given\n     * array.\n     * @param {E[]} data - The `data` parameter is an array of elements of type `E`.\n     * @returns The `fromArray` function returns a `SinglyLinkedList` object.\n     */\n    static fromArray(data) {\n        const singlyLinkedList = new SinglyLinkedList();\n        for (const item of data) {\n            singlyLinkedList.push(item);\n        }\n        return singlyLinkedList;\n    }\n    getLength() {\n        return this._length;\n    }\n    /**\n     * The `push` function adds a new node with the given data to the end of a singly linked list.\n     * @param {E} data - The \"data\" parameter represents the value that you want to add to the linked list. It can be of\n     * any type (E) as specified in the generic type declaration of the class or function.\n     */\n    push(data) {\n        const newNode = new SinglyLinkedListNode(data);\n        if (!this.head) {\n            this.head = newNode;\n            this.tail = newNode;\n        }\n        else {\n            this.tail.next = newNode;\n            this.tail = newNode;\n        }\n        this._length++;\n    }\n    /**\n     * The `pop()` function removes and returns the value of the last element in a linked list, updating the head and tail\n     * pointers accordingly.\n     * @returns The method `pop()` returns the value of the node that is being removed from the end of the linked list. If\n     * the linked list is empty, it returns `null`.\n     */\n    pop() {\n        if (!this.head)\n            return undefined;\n        if (this.head === this.tail) {\n            const val = this.head.val;\n            this.head = null;\n            this.tail = null;\n            this._length--;\n            return val;\n        }\n        let current = this.head;\n        while (current.next !== this.tail) {\n            current = current.next;\n        }\n        const val = this.tail.val;\n        current.next = null;\n        this.tail = current;\n        this._length--;\n        return val;\n    }\n    /**\n     * The `shift()` function removes and returns the value of the first node in a linked list.\n     * @returns The value of the node that is being removed from the beginning of the linked list.\n     */\n    shift() {\n        if (!this.head)\n            return undefined;\n        const removedNode = this.head;\n        this.head = this.head.next;\n        this._length--;\n        return removedNode.val;\n    }\n    /**\n     * The unshift function adds a new node with the given value to the beginning of a singly linked list.\n     * @param {E} val - The parameter \"val\" represents the value of the new node that will be added to the beginning of the\n     * linked list.\n     */\n    unshift(val) {\n        const newNode = new SinglyLinkedListNode(val);\n        if (!this.head) {\n            this.head = newNode;\n            this.tail = newNode;\n        }\n        else {\n            newNode.next = this.head;\n            this.head = newNode;\n        }\n        this._length++;\n    }\n    /**\n     * The function `getAt` returns the value at a specified index in a linked list, or null if the index is out of range.\n     * @param {number} index - The index parameter is a number that represents the position of the element we want to\n     * retrieve from the list.\n     * @returns The method `getAt(index: number): E | null` returns the value at the specified index in the linked list, or\n     * `null` if the index is out of bounds.\n     */\n    getAt(index) {\n        if (index < 0 || index >= this.length)\n            return undefined;\n        let current = this.head;\n        for (let i = 0; i < index; i++) {\n            current = current.next;\n        }\n        return current.val;\n    }\n    /**\n     * The function `getNodeAt` returns the node at a given index in a singly linked list.\n     * @param {number} index - The `index` parameter is a number that represents the position of the node we want to\n     * retrieve from the linked list. It indicates the zero-based index of the node we want to access.\n     * @returns The method `getNodeAt(index: number)` returns a `SinglyLinkedListNode<E>` object if the node at the\n     * specified index exists, or `null` if the index is out of bounds.\n     */\n    getNodeAt(index) {\n        let current = this.head;\n        for (let i = 0; i < index; i++) {\n            current = current.next;\n        }\n        return current;\n    }\n    /**\n     * The `deleteAt` function removes an element at a specified index from a linked list and returns the removed element.\n     * @param {number} index - The index parameter represents the position of the element that needs to be deleted in the\n     * data structure. It is of type number.\n     * @returns The method `deleteAt` returns the value of the node that was deleted, or `null` if the index is out of\n     * bounds.\n     */\n    deleteAt(index) {\n        if (index < 0 || index >= this.length)\n            return undefined;\n        if (index === 0)\n            return this.shift();\n        if (index === this.length - 1)\n            return this.pop();\n        const prevNode = this.getNodeAt(index - 1);\n        const removedNode = prevNode.next;\n        prevNode.next = removedNode.next;\n        this._length--;\n        return removedNode.val;\n    }\n    /**\n     * The delete function removes a node with a specific value from a singly linked list.\n     * @param {E | SinglyLinkedListNode<E>} valueOrNode - The `valueOrNode` parameter can accept either a value of type `E`\n     * or a `SinglyLinkedListNode<E>` object.\n     * @returns The `delete` method returns a boolean value. It returns `true` if the value or node is found and\n     * successfully deleted from the linked list, and `false` if the value or node is not found in the linked list.\n     */\n    delete(valueOrNode) {\n        let value;\n        if (valueOrNode instanceof SinglyLinkedListNode) {\n            value = valueOrNode.val;\n        }\n        else {\n            value = valueOrNode;\n        }\n        let current = this.head, prev = null;\n        while (current) {\n            if (current.val === value) {\n                if (prev === null) {\n                    this.head = current.next;\n                    if (current === this.tail) {\n                        this.tail = null;\n                    }\n                }\n                else {\n                    prev.next = current.next;\n                    if (current === this.tail) {\n                        this.tail = prev;\n                    }\n                }\n                this._length--;\n                return true;\n            }\n            prev = current;\n            current = current.next;\n        }\n        return false;\n    }\n    /**\n     * The `insertAt` function inserts a value at a specified index in a singly linked list.\n     * @param {number} index - The index parameter represents the position at which the new value should be inserted in the\n     * linked list. It is of type number.\n     * @param {E} val - The `val` parameter represents the value that you want to insert into the linked list at the\n     * specified index.\n     * @returns The `insert` method returns a boolean value. It returns `true` if the insertion is successful, and `false`\n     * if the index is out of bounds.\n     */\n    insertAt(index, val) {\n        if (index < 0 || index > this.length)\n            return false;\n        if (index === 0) {\n            this.unshift(val);\n            return true;\n        }\n        if (index === this.length) {\n            this.push(val);\n            return true;\n        }\n        const newNode = new SinglyLinkedListNode(val);\n        const prevNode = this.getNodeAt(index - 1);\n        newNode.next = prevNode.next;\n        prevNode.next = newNode;\n        this._length++;\n        return true;\n    }\n    /**\n     * The function checks if the length of a data structure is equal to zero and returns a boolean value indicating\n     * whether it is empty or not.\n     * @returns A boolean value indicating whether the length of the object is equal to 0.\n     */\n    isEmpty() {\n        return this.length === 0;\n    }\n    /**\n     * The `clear` function resets the linked list by setting the head, tail, and length to null and 0 respectively.\n     */\n    clear() {\n        this._head = null;\n        this._tail = null;\n        this._length = 0;\n    }\n    /**\n     * The `toArray` function converts a linked list into an array.\n     * @returns The `toArray()` method is returning an array of type `E[]`.\n     */\n    toArray() {\n        const array = [];\n        let current = this.head;\n        while (current) {\n            array.push(current.val);\n            current = current.next;\n        }\n        return array;\n    }\n    /**\n     * The `reverse` function reverses the order of the nodes in a singly linked list.\n     * @returns The reverse() method does not return anything. It has a return type of void.\n     */\n    reverse() {\n        if (!this.head || this.head === this.tail)\n            return;\n        let prev = null;\n        let current = this.head;\n        let next = null;\n        while (current) {\n            next = current.next;\n            current.next = prev;\n            prev = current;\n            current = next;\n        }\n        [this.head, this.tail] = [this.tail, this.head];\n    }\n    /**\n     * The `find` function iterates through a linked list and returns the first element that satisfies a given condition.\n     * @param callback - A function that takes a value of type E as its parameter and returns a boolean value. This\n     * function is used to determine whether a particular value in the linked list satisfies a certain condition.\n     * @returns The method `find` returns the first element in the linked list that satisfies the condition specified by\n     * the callback function. If no element satisfies the condition, it returns `null`.\n     */\n    find(callback) {\n        let current = this.head;\n        while (current) {\n            if (callback(current.val)) {\n                return current.val;\n            }\n            current = current.next;\n        }\n        return null;\n    }\n    /**\n     * The `indexOf` function returns the index of the first occurrence of a given value in a linked list.\n     * @param {E} value - The value parameter is the value that you want to find the index of in the linked list.\n     * @returns The method is returning the index of the first occurrence of the specified value in the linked list. If the\n     * value is not found, it returns -1.\n     */\n    indexOf(value) {\n        let index = 0;\n        let current = this.head;\n        while (current) {\n            if (current.val === value) {\n                return index;\n            }\n            index++;\n            current = current.next;\n        }\n        return -1;\n    }\n    /**\n     * The function finds a node in a singly linked list by its value and returns the node if found, otherwise returns\n     * null.\n     * @param {E} value - The value parameter is the value that we want to search for in the linked list.\n     * @returns a `SinglyLinkedListNode<E>` if a node with the specified value is found in the linked list. If no node with\n     * the specified value is found, the function returns `null`.\n     */\n    findNode(value) {\n        let current = this.head;\n        while (current) {\n            if (current.val === value) {\n                return current;\n            }\n            current = current.next;\n        }\n        return null;\n    }\n    /**\n     * The `insertBefore` function inserts a new value before an existing value in a singly linked list.\n     * @param {E | SinglyLinkedListNode<E>} existingValueOrNode - The existing value or node that you want to insert the\n     * new value before. It can be either the value itself or a node containing the value in the linked list.\n     * @param {E} newValue - The `newValue` parameter represents the value that you want to insert into the linked list.\n     * @returns The method `insertBefore` returns a boolean value. It returns `true` if the new value was successfully\n     * inserted before the existing value, and `false` otherwise.\n     */\n    insertBefore(existingValueOrNode, newValue) {\n        if (!this.head)\n            return false;\n        let existingValue;\n        if (existingValueOrNode instanceof SinglyLinkedListNode) {\n            existingValue = existingValueOrNode.val;\n        }\n        else {\n            existingValue = existingValueOrNode;\n        }\n        if (this.head.val === existingValue) {\n            this.unshift(newValue);\n            return true;\n        }\n        let current = this.head;\n        while (current.next) {\n            if (current.next.val === existingValue) {\n                const newNode = new SinglyLinkedListNode(newValue);\n                newNode.next = current.next;\n                current.next = newNode;\n                this._length++;\n                return true;\n            }\n            current = current.next;\n        }\n        return false;\n    }\n    /**\n     * The `insertAfter` function inserts a new node with a given value after an existing node in a singly linked list.\n     * @param {E | SinglyLinkedListNode<E>} existingValueOrNode - The existing value or node in the linked list after which\n     * the new value will be inserted. It can be either the value of the existing node or the existing node itself.\n     * @param {E} newValue - The value that you want to insert into the linked list after the existing value or node.\n     * @returns The method returns a boolean value. It returns true if the new value was successfully inserted after the\n     * existing value or node, and false if the existing value or node was not found in the linked list.\n     */\n    insertAfter(existingValueOrNode, newValue) {\n        let existingNode;\n        if (existingValueOrNode instanceof SinglyLinkedListNode) {\n            existingNode = existingValueOrNode;\n        }\n        else {\n            existingNode = this.findNode(existingValueOrNode);\n        }\n        if (existingNode) {\n            const newNode = new SinglyLinkedListNode(newValue);\n            newNode.next = existingNode.next;\n            existingNode.next = newNode;\n            if (existingNode === this.tail) {\n                this.tail = newNode;\n            }\n            this._length++;\n            return true;\n        }\n        return false;\n    }\n    /**\n     * The function counts the number of occurrences of a given value in a linked list.\n     * @param {E} value - The value parameter is the value that you want to count the occurrences of in the linked list.\n     * @returns The count of occurrences of the given value in the linked list.\n     */\n    countOccurrences(value) {\n        let count = 0;\n        let current = this.head;\n        while (current) {\n            if (current.val === value) {\n                count++;\n            }\n            current = current.next;\n        }\n        return count;\n    }\n    *[Symbol.iterator]() {\n        let current = this.head;\n        while (current) {\n            yield current.val;\n            current = current.next;\n        }\n    }\n}\n","/**\n * data-structure-typed\n *\n * @author Tyler Zeng\n * @copyright Copyright (c) 2022 Tyler Zeng <zrwusa@gmail.com>\n * @license MIT License\n */\nexport class DoublyLinkedListNode {\n    /**\n     * The constructor function initializes the value, next, and previous properties of an object.\n     * @param {E} val - The \"val\" parameter is the value that will be stored in the node. It can be of any data type, as it\n     * is defined as a generic type \"E\".\n     */\n    constructor(val) {\n        this._val = val;\n        this._next = null;\n        this._prev = null;\n    }\n    get val() {\n        return this._val;\n    }\n    set val(value) {\n        this._val = value;\n    }\n    get next() {\n        return this._next;\n    }\n    set next(value) {\n        this._next = value;\n    }\n    get prev() {\n        return this._prev;\n    }\n    set prev(value) {\n        this._prev = value;\n    }\n}\nexport class DoublyLinkedList {\n    /**\n     * The constructor initializes the linked list with an empty head, tail, and length.\n     */\n    constructor() {\n        this._head = null;\n        this._tail = null;\n        this._length = 0;\n    }\n    get head() {\n        return this._head;\n    }\n    set head(value) {\n        this._head = value;\n    }\n    get tail() {\n        return this._tail;\n    }\n    set tail(value) {\n        this._tail = value;\n    }\n    get length() {\n        return this._length;\n    }\n    /**\n     * The `fromArray` function creates a new instance of a DoublyLinkedList and populates it with the elements from the\n     * given array.\n     * @param {E[]} data - The `data` parameter is an array of elements of type `E`.\n     * @returns The `fromArray` function returns a DoublyLinkedList object.\n     */\n    static fromArray(data) {\n        const doublyLinkedList = new DoublyLinkedList();\n        for (const item of data) {\n            doublyLinkedList.push(item);\n        }\n        return doublyLinkedList;\n    }\n    /**\n     * The push function adds a new node with the given value to the end of the doubly linked list.\n     * @param {E} val - The value to be added to the linked list.\n     */\n    push(val) {\n        const newNode = new DoublyLinkedListNode(val);\n        if (!this.head) {\n            this.head = newNode;\n            this.tail = newNode;\n        }\n        else {\n            newNode.prev = this.tail;\n            this.tail.next = newNode;\n            this.tail = newNode;\n        }\n        this._length++;\n    }\n    /**\n     * The addLast function adds a new node with the given value to the end of the doubly linked list.\n     * @param {E} val - The value to be added to the linked list.\n     */\n    addLast(val) {\n        this.push(val);\n    }\n    /**\n     * The `pop()` function removes and returns the value of the last node in a doubly linked list.\n     * @returns The method is returning the value of the removed node (removedNode.val) if the list is not empty. If the\n     * list is empty, it returns null.\n     */\n    pop() {\n        if (!this.tail)\n            return undefined;\n        const removedNode = this.tail;\n        if (this.head === this.tail) {\n            this.head = null;\n            this.tail = null;\n        }\n        else {\n            this.tail = removedNode.prev;\n            this.tail.next = null;\n        }\n        this._length--;\n        return removedNode.val;\n    }\n    /**\n     * The `pollLast()` function removes and returns the value of the last node in a doubly linked list.\n     * @returns The method is returning the value of the removed node (removedNode.val) if the list is not empty. If the\n     * list is empty, it returns null.\n     */\n    pollLast() {\n        return this.pop();\n    }\n    /**\n     * The `shift()` function removes and returns the value of the first node in a doubly linked list.\n     * @returns The method `shift()` returns the value of the node that is removed from the beginning of the doubly linked\n     * list.\n     */\n    shift() {\n        if (!this.head)\n            return undefined;\n        const removedNode = this.head;\n        if (this.head === this.tail) {\n            this.head = null;\n            this.tail = null;\n        }\n        else {\n            this.head = removedNode.next;\n            this.head.prev = null;\n        }\n        this._length--;\n        return removedNode.val;\n    }\n    /**\n     * The `pollFirst()` function removes and returns the value of the first node in a doubly linked list.\n     * @returns The method `shift()` returns the value of the node that is removed from the beginning of the doubly linked\n     * list.\n     */\n    pollFirst() {\n        return this.shift();\n    }\n    /**\n     * The unshift function adds a new node with the given value to the beginning of a doubly linked list.\n     * @param {E} val - The `val` parameter represents the value of the new node that will be added to the beginning of the\n     * doubly linked list.\n     */\n    unshift(val) {\n        const newNode = new DoublyLinkedListNode(val);\n        if (!this.head) {\n            this.head = newNode;\n            this.tail = newNode;\n        }\n        else {\n            newNode.next = this.head;\n            this.head.prev = newNode;\n            this.head = newNode;\n        }\n        this._length++;\n    }\n    /**\n     * The addFirst function adds a new node with the given value to the beginning of a doubly linked list.\n     * @param {E} val - The `val` parameter represents the value of the new node that will be added to the beginning of the\n     * doubly linked list.\n     */\n    addFirst(val) {\n        this.unshift(val);\n    }\n    /**\n     * The `peekFirst` function returns the first node in a doubly linked list, or null if the list is empty.\n     * @returns The method `peekFirst()` returns the first node of the doubly linked list, or `null` if the list is empty.\n     */\n    peekFirst() {\n        var _a;\n        return (_a = this.head) === null || _a === void 0 ? void 0 : _a.val;\n    }\n    /**\n     * The `peekLast` function returns the last node in a doubly linked list, or null if the list is empty.\n     * @returns The method `peekLast()` returns the last node of the doubly linked list, or `null` if the list is empty.\n     */\n    peekLast() {\n        var _a;\n        return (_a = this.tail) === null || _a === void 0 ? void 0 : _a.val;\n    }\n    get size() {\n        return this.length;\n    }\n    /**\n     * The `getAt` function returns the value at a specified index in a linked list, or null if the index is out of bounds.\n     * @param {number} index - The index parameter is a number that represents the position of the element we want to\n     * retrieve from the list.\n     * @returns The method is returning the value at the specified index in the linked list. If the index is out of bounds\n     * or the linked list is empty, it will return null.\n     */\n    getAt(index) {\n        if (index < 0 || index >= this.length)\n            return undefined;\n        let current = this.head;\n        for (let i = 0; i < index; i++) {\n            current = current.next;\n        }\n        return current.val;\n    }\n    /**\n     * The function `getNodeAt` returns the node at a given index in a doubly linked list, or null if the index is out of\n     * range.\n     * @param {number} index - The `index` parameter is a number that represents the position of the node we want to\n     * retrieve from the doubly linked list. It indicates the zero-based index of the node we want to access.\n     * @returns The method `getNodeAt(index: number)` returns a `DoublyLinkedListNode<E>` object if the index is within the\n     * valid range of the linked list, otherwise it returns `null`.\n     */\n    getNodeAt(index) {\n        if (index < 0 || index >= this.length)\n            return null;\n        let current = this.head;\n        for (let i = 0; i < index; i++) {\n            current = current.next;\n        }\n        return current;\n    }\n    /**\n     * The function `findNodeByValue` searches for a node with a specific value in a doubly linked list and returns the\n     * node if found, otherwise it returns null.\n     * @param {E} val - The `val` parameter is the value that we want to search for in the doubly linked list.\n     * @returns The function `findNodeByValue` returns a `DoublyLinkedListNode<E>` if a node with the specified value `val`\n     * is found in the linked list. If no such node is found, it returns `null`.\n     */\n    findNode(val) {\n        let current = this.head;\n        while (current) {\n            if (current.val === val) {\n                return current;\n            }\n            current = current.next;\n        }\n        return null;\n    }\n    /**\n     * The `insert` function inserts a value at a specified index in a doubly linked list.\n     * @param {number} index - The index parameter represents the position at which the new value should be inserted in the\n     * DoublyLinkedList. It is of type number.\n     * @param {E} val - The `val` parameter represents the value that you want to insert into the Doubly Linked List at the\n     * specified index.\n     * @returns The `insert` method returns a boolean value. It returns `true` if the insertion is successful, and `false`\n     * if the index is out of bounds.\n     */\n    insertAt(index, val) {\n        if (index < 0 || index > this.length)\n            return false;\n        if (index === 0) {\n            this.unshift(val);\n            return true;\n        }\n        if (index === this.length) {\n            this.push(val);\n            return true;\n        }\n        const newNode = new DoublyLinkedListNode(val);\n        const prevNode = this.getNodeAt(index - 1);\n        const nextNode = prevNode.next;\n        newNode.prev = prevNode;\n        newNode.next = nextNode;\n        prevNode.next = newNode;\n        nextNode.prev = newNode;\n        this._length++;\n        return true;\n    }\n    /**\n     * The `deleteAt` function removes an element at a specified index from a linked list and returns the removed element.\n     * @param {number} index - The index parameter represents the position of the element that needs to be deleted in the\n     * data structure. It is of type number.\n     * @returns The method `deleteAt` returns the value of the node that was deleted, or `null` if the index is out of\n     * bounds.\n     */\n    deleteAt(index) {\n        if (index < 0 || index >= this.length)\n            return undefined;\n        if (index === 0)\n            return this.shift();\n        if (index === this.length - 1)\n            return this.pop();\n        const removedNode = this.getNodeAt(index);\n        const prevNode = removedNode.prev;\n        const nextNode = removedNode.next;\n        prevNode.next = nextNode;\n        nextNode.prev = prevNode;\n        this._length--;\n        return removedNode.val;\n    }\n    /**\n     * The `delete` function removes a node from a doubly linked list based on either the node itself or its value.\n     * @param {E | DoublyLinkedListNode<E>} valOrNode - The `valOrNode` parameter can accept either a value of type `E` or\n     * a `DoublyLinkedListNode<E>` object.\n     * @returns The `delete` method returns a boolean value. It returns `true` if the value or node was successfully\n     * deleted from the doubly linked list, and `false` if the value or node was not found in the list.\n     */\n    delete(valOrNode) {\n        let node;\n        if (valOrNode instanceof DoublyLinkedListNode) {\n            node = valOrNode;\n        }\n        else {\n            node = this.findNode(valOrNode);\n        }\n        if (node) {\n            if (node === this.head) {\n                this.shift();\n            }\n            else if (node === this.tail) {\n                this.pop();\n            }\n            else {\n                const prevNode = node.prev;\n                const nextNode = node.next;\n                prevNode.next = nextNode;\n                nextNode.prev = prevNode;\n                this._length--;\n            }\n            return true;\n        }\n        return false;\n    }\n    /**\n     * The `toArray` function converts a linked list into an array.\n     * @returns The `toArray()` method is returning an array of type `E[]`.\n     */\n    toArray() {\n        const array = [];\n        let current = this.head;\n        while (current) {\n            array.push(current.val);\n            current = current.next;\n        }\n        return array;\n    }\n    /**\n     * The function checks if a variable has a length greater than zero and returns a boolean value.\n     * @returns A boolean value is being returned.\n     */\n    isEmpty() {\n        return this.length === 0;\n    }\n    /**\n     * The `clear` function resets the linked list by setting the head, tail, and length to null and 0 respectively.\n     */\n    clear() {\n        this._head = null;\n        this._tail = null;\n        this._length = 0;\n    }\n    /**\n     * The `find` function iterates through a linked list and returns the first element that satisfies a given condition.\n     * @param callback - A function that takes a value of type E as its parameter and returns a boolean value. This\n     * function is used to determine whether a particular value in the linked list satisfies a certain condition.\n     * @returns The method `find` returns the first element in the linked list that satisfies the condition specified by\n     * the callback function. If no element satisfies the condition, it returns `null`.\n     */\n    find(callback) {\n        let current = this.head;\n        while (current) {\n            if (callback(current.val)) {\n                return current.val;\n            }\n            current = current.next;\n        }\n        return null;\n    }\n    /**\n     * The function returns the index of the first occurrence of a given value in a linked list.\n     * @param {E} val - The parameter `val` is of type `E`, which means it can be any data type. It represents the value\n     * that we are searching for in the linked list.\n     * @returns The method `indexOf` returns the index of the first occurrence of the specified value `val` in the linked\n     * list. If the value is not found, it returns -1.\n     */\n    indexOf(val) {\n        let index = 0;\n        let current = this.head;\n        while (current) {\n            if (current.val === val) {\n                return index;\n            }\n            index++;\n            current = current.next;\n        }\n        return -1;\n    }\n    /**\n     * The `findLast` function iterates through a linked list from the last node to the first node and returns the last\n     * value that satisfies the given callback function, or null if no value satisfies the callback.\n     * @param callback - A function that takes a value of type E as its parameter and returns a boolean value. This\n     * function is used to determine whether a given value satisfies a certain condition.\n     * @returns The method `findLast` returns the last value in the linked list that satisfies the condition specified by\n     * the callback function. If no value satisfies the condition, it returns `null`.\n     */\n    findLast(callback) {\n        let current = this.tail;\n        while (current) {\n            if (callback(current.val)) {\n                return current.val;\n            }\n            current = current.prev;\n        }\n        return null;\n    }\n    /**\n     * The `toArrayReverse` function converts a doubly linked list into an array in reverse order.\n     * @returns The `toArrayReverse()` function returns an array of type `E[]`.\n     */\n    toArrayReverse() {\n        const array = [];\n        let current = this.tail;\n        while (current) {\n            array.push(current.val);\n            current = current.prev;\n        }\n        return array;\n    }\n    /**\n     * The `reverse` function reverses the order of the elements in a doubly linked list.\n     */\n    reverse() {\n        let current = this.head;\n        [this.head, this.tail] = [this.tail, this.head];\n        while (current) {\n            const next = current.next;\n            [current.prev, current.next] = [current.next, current.prev];\n            current = next;\n        }\n    }\n    /**\n     * The `forEach` function iterates over each element in a linked list and applies a callback function to each element.\n     * @param callback - The callback parameter is a function that takes two arguments: val and index. The val argument\n     * represents the value of the current node in the linked list, and the index argument represents the index of the\n     * current node in the linked list.\n     */\n    forEach(callback) {\n        let current = this.head;\n        let index = 0;\n        while (current) {\n            callback(current.val, index);\n            current = current.next;\n            index++;\n        }\n    }\n    /**\n     * The `map` function takes a callback function and applies it to each element in the DoublyLinkedList, returning a new\n     * DoublyLinkedList with the transformed values.\n     * @param callback - The callback parameter is a function that takes a value of type E (the type of values stored in\n     * the original DoublyLinkedList) and returns a value of type U (the type of values that will be stored in the mapped\n     * DoublyLinkedList).\n     * @returns The `map` function is returning a new instance of `DoublyLinkedList<U>` that contains the mapped values.\n     */\n    map(callback) {\n        const mappedList = new DoublyLinkedList();\n        let current = this.head;\n        while (current) {\n            mappedList.push(callback(current.val));\n            current = current.next;\n        }\n        return mappedList;\n    }\n    /**\n     * The `filter` function iterates through a DoublyLinkedList and returns a new DoublyLinkedList containing only the\n     * elements that satisfy the given callback function.\n     * @param callback - The `callback` parameter is a function that takes a value of type `E` and returns a boolean value.\n     * It is used to determine whether a value should be included in the filtered list or not.\n     * @returns The filtered list, which is an instance of the DoublyLinkedList class.\n     */\n    filter(callback) {\n        const filteredList = new DoublyLinkedList();\n        let current = this.head;\n        while (current) {\n            if (callback(current.val)) {\n                filteredList.push(current.val);\n            }\n            current = current.next;\n        }\n        return filteredList;\n    }\n    /**\n     * The `reduce` function iterates over a linked list and applies a callback function to each element, accumulating a\n     * single value.\n     * @param callback - The `callback` parameter is a function that takes two arguments: `accumulator` and `val`. It is\n     * used to perform a specific operation on each element of the linked list.\n     * @param {U} initialValue - The `initialValue` parameter is the initial value of the accumulator. It is the starting\n     * point for the reduction operation.\n     * @returns The `reduce` method is returning the final value of the accumulator after iterating through all the\n     * elements in the linked list.\n     */\n    reduce(callback, initialValue) {\n        let accumulator = initialValue;\n        let current = this.head;\n        while (current) {\n            accumulator = callback(accumulator, current.val);\n            current = current.next;\n        }\n        return accumulator;\n    }\n    /**\n     * The `insertAfter` function inserts a new node with a given value after an existing node in a doubly linked list.\n     * @param {E | DoublyLinkedListNode<E>} existingValueOrNode - The existing value or node in the doubly linked list\n     * after which the new value will be inserted. It can be either the value of the existing node or the existing node\n     * itself.\n     * @param {E} newValue - The value that you want to insert into the doubly linked list.\n     * @returns The method returns a boolean value. It returns true if the insertion is successful, and false if the\n     * existing value or node is not found in the doubly linked list.\n     */\n    insertAfter(existingValueOrNode, newValue) {\n        let existingNode;\n        if (existingValueOrNode instanceof DoublyLinkedListNode) {\n            existingNode = existingValueOrNode;\n        }\n        else {\n            existingNode = this.findNode(existingValueOrNode);\n        }\n        if (existingNode) {\n            const newNode = new DoublyLinkedListNode(newValue);\n            newNode.next = existingNode.next;\n            if (existingNode.next) {\n                existingNode.next.prev = newNode;\n            }\n            newNode.prev = existingNode;\n            existingNode.next = newNode;\n            if (existingNode === this.tail) {\n                this.tail = newNode;\n            }\n            this._length++;\n            return true;\n        }\n        return false;\n    }\n    /**\n     * The `insertBefore` function inserts a new value before an existing value or node in a doubly linked list.\n     * @param {E | DoublyLinkedListNode<E>} existingValueOrNode - The existing value or node in the doubly linked list\n     * before which the new value will be inserted. It can be either the value of the existing node or the existing node\n     * itself.\n     * @param {E} newValue - The `newValue` parameter represents the value that you want to insert into the doubly linked\n     * list.\n     * @returns The method returns a boolean value. It returns `true` if the insertion is successful, and `false` if the\n     * insertion fails.\n     */\n    insertBefore(existingValueOrNode, newValue) {\n        let existingNode;\n        if (existingValueOrNode instanceof DoublyLinkedListNode) {\n            existingNode = existingValueOrNode;\n        }\n        else {\n            existingNode = this.findNode(existingValueOrNode);\n        }\n        if (existingNode) {\n            const newNode = new DoublyLinkedListNode(newValue);\n            newNode.prev = existingNode.prev;\n            if (existingNode.prev) {\n                existingNode.prev.next = newNode;\n            }\n            newNode.next = existingNode;\n            existingNode.prev = newNode;\n            if (existingNode === this.head) {\n                this.head = newNode;\n            }\n            this._length++;\n            return true;\n        }\n        return false;\n    }\n}\n","/**\n * data-structure-typed\n *\n * @author Tyler Zeng\n * @copyright Copyright (c) 2022 Tyler Zeng <zrwusa@gmail.com>\n * @license MIT License\n */\nexport class SkipListNode {\n    constructor(key, value, level) {\n        this.key = key;\n        this.value = value;\n        this.forward = new Array(level);\n    }\n}\nexport class SkipList {\n    get probability() {\n        return this._probability;\n    }\n    set probability(value) {\n        this._probability = value;\n    }\n    get maxLevel() {\n        return this._maxLevel;\n    }\n    set maxLevel(value) {\n        this._maxLevel = value;\n    }\n    get level() {\n        return this._level;\n    }\n    set level(value) {\n        this._level = value;\n    }\n    get head() {\n        return this._head;\n    }\n    set head(value) {\n        this._head = value;\n    }\n    /**\n     * The constructor initializes a SkipList with a specified maximum level and probability.\n     * @param [maxLevel=16] - The `maxLevel` parameter represents the maximum level that a skip list can have. It determines\n     * the maximum number of levels that can be created in the skip list.\n     * @param [probability=0.5] - The probability parameter represents the probability of a node being promoted to a higher\n     * level in the skip list. It is used to determine the height of each node in the skip list.\n     */\n    constructor(maxLevel = 16, probability = 0.5) {\n        this._head = new SkipListNode(null, null, maxLevel);\n        this._level = 0;\n        this._maxLevel = maxLevel;\n        this._probability = probability;\n    }\n    /**\n     * The function \"randomLevel\" generates a random level based on a given probability and maximum level.\n     * @returns the level, which is a number.\n     */\n    randomLevel() {\n        let level = 1;\n        while (Math.random() < this.probability && level < this.maxLevel) {\n            level++;\n        }\n        return level;\n    }\n    /**\n     * The add function adds a new node with a given key and value to a Skip List data structure.\n     * @param {K} key - The key parameter represents the key of the node that needs to be added to the skip list.\n     * @param {V} value - The \"value\" parameter represents the value associated with the key that is being added to the Skip\n     * List.\n     */\n    add(key, value) {\n        const newNode = new SkipListNode(key, value, this.randomLevel());\n        const update = new Array(this.maxLevel).fill(this.head);\n        let current = this.head;\n        for (let i = this.level - 1; i >= 0; i--) {\n            while (current.forward[i] && current.forward[i].key < key) {\n                current = current.forward[i];\n            }\n            update[i] = current;\n        }\n        for (let i = 0; i < newNode.forward.length; i++) {\n            newNode.forward[i] = update[i].forward[i];\n            update[i].forward[i] = newNode;\n        }\n        if (newNode.forward[0] !== null) {\n            this.level = Math.max(this.level, newNode.forward.length);\n        }\n    }\n    /**\n     * The function `get` retrieves the value associated with a given key from a skip list data structure.\n     * @param {K} key - The `key` parameter is the key of the element that we want to retrieve from the data structure.\n     * @returns The method `get(key: K)` returns the value associated with the given key if it exists in the data structure,\n     * otherwise it returns `undefined`.\n     */\n    get(key) {\n        let current = this.head;\n        for (let i = this.level - 1; i >= 0; i--) {\n            while (current.forward[i] && current.forward[i].key < key) {\n                current = current.forward[i];\n            }\n        }\n        current = current.forward[0];\n        if (current && current.key === key) {\n            return current.value;\n        }\n        return undefined;\n    }\n    /**\n     * The `remove` function removes a node with a specific key from a Skip List data structure.\n     * @param {K} key - The key parameter represents the key of the node that needs to be removed from the skip list.\n     * @returns The `remove` method returns a boolean value. It returns `true` if the key was successfully removed from the\n     * skip list, and `false` if the key was not found in the skip list.\n     */\n    remove(key) {\n        const update = new Array(this.maxLevel).fill(this.head);\n        let current = this.head;\n        for (let i = this.level - 1; i >= 0; i--) {\n            while (current.forward[i] && current.forward[i].key < key) {\n                current = current.forward[i];\n            }\n            update[i] = current;\n        }\n        current = current.forward[0];\n        if (current && current.key === key) {\n            for (let i = 0; i < this.level; i++) {\n                if (update[i].forward[i] !== current) {\n                    break;\n                }\n                update[i].forward[i] = current.forward[i];\n            }\n            while (this.level > 0 && this.head.forward[this.level - 1] === null) {\n                this.level--;\n            }\n            return true;\n        }\n        return false;\n    }\n}\n","/**\n * @license MIT\n * @copyright Tyler Zeng <zrwusa@gmail.com>\n * @class\n */\nexport class Stack {\n    /**\n     * The constructor initializes an array of elements, which can be provided as an optional parameter.\n     * @param {E[]} [elements] - The `elements` parameter is an optional parameter of type `E[]`, which represents an array\n     * of elements of type `E`. It is used to initialize the `_elements` property of the class. If the `elements` parameter\n     * is provided and is an array, it is assigned to the `_elements\n     */\n    constructor(elements) {\n        this._elements = Array.isArray(elements) ? elements : [];\n    }\n    /**\n     * The function \"fromArray\" creates a new Stack object from an array of elements.\n     * @param {E[]} elements - The `elements` parameter is an array of elements of type `E`.\n     * @returns {Stack} The method is returning a new instance of the Stack class, initialized with the elements from the input\n     * array.\n     */\n    static fromArray(elements) {\n        return new Stack(elements);\n    }\n    /**\n     * The function checks if an array is empty and returns a boolean value.\n     * @returns A boolean value indicating whether the `_elements` array is empty or not.\n     */\n    isEmpty() {\n        return this._elements.length === 0;\n    }\n    /**\n     * The size() function returns the number of elements in an array.\n     * @returns The size of the elements array.\n     */\n    size() {\n        return this._elements.length;\n    }\n    /**\n     * The `peek` function returns the last element of an array, or null if the array is empty.\n     * @returns The `peek()` function returns the last element of the `_elements` array, or `null` if the array is empty.\n     */\n    peek() {\n        if (this.isEmpty())\n            return null;\n        return this._elements[this._elements.length - 1];\n    }\n    /**\n     * The push function adds an element to the stack and returns the updated stack.\n     * @param {E} element - The parameter \"element\" is of type E, which means it can be any data type.\n     * @returns The `push` method is returning the updated `Stack<E>` object.\n     */\n    push(element) {\n        this._elements.push(element);\n        return this;\n    }\n    /**\n     * The `pop` function removes and returns the last element from an array, or returns null if the array is empty.\n     * @returns The `pop()` method is returning the last element of the array `_elements` if the array is not empty. If the\n     * array is empty, it returns `null`.\n     */\n    pop() {\n        if (this.isEmpty())\n            return null;\n        return this._elements.pop() || null;\n    }\n    /**\n     * The toArray function returns a copy of the elements in an array.\n     * @returns An array of type E.\n     */\n    toArray() {\n        return this._elements.slice();\n    }\n    /**\n     * The clear function clears the elements array.\n     */\n    clear() {\n        this._elements = [];\n    }\n    /**\n     * The `clone()` function returns a new `Stack` object with the same elements as the original stack.\n     * @returns The `clone()` method is returning a new `Stack` object with a copy of the `_elements` array.\n     */\n    clone() {\n        return new Stack(this._elements.slice());\n    }\n}\n","/**\n * @license MIT\n * @copyright Tyler Zeng <zrwusa@gmail.com>\n * @class\n */\nimport { SinglyLinkedList } from '../linked-list';\nexport class LinkedListQueue extends SinglyLinkedList {\n    /**\n     * The enqueue function adds a value to the end of an array.\n     * @param {E} value - The value parameter represents the value that you want to add to the queue.\n     */\n    enqueue(value) {\n        this.push(value);\n    }\n    /**\n     * The `dequeue` function removes and returns the first element from a queue, or returns null if the queue is empty.\n     * @returns The method is returning the element at the front of the queue, or null if the queue is empty.\n     */\n    dequeue() {\n        return this.shift();\n    }\n    /**\n     * The `peek` function returns the value of the head node in a linked list, or `undefined` if the list is empty.\n     * @returns The `peek()` method is returning the value of the `head` node if it exists, otherwise it returns `undefined`.\n     */\n    peek() {\n        var _a;\n        return (_a = this.head) === null || _a === void 0 ? void 0 : _a.val;\n    }\n}\nexport class Queue {\n    /**\n     * The constructor initializes an instance of a class with an optional array of elements and sets the offset to 0.\n     * @param {E[]} [elements] - The `elements` parameter is an optional array of elements of type `E`. If provided, it\n     * will be used to initialize the `_nodes` property of the class. If not provided, the `_nodes` property will be\n     * initialized as an empty array.\n     */\n    constructor(elements) {\n        this._nodes = elements || [];\n        this._offset = 0;\n    }\n    get nodes() {\n        return this._nodes;\n    }\n    set nodes(value) {\n        this._nodes = value;\n    }\n    get offset() {\n        return this._offset;\n    }\n    set offset(value) {\n        this._offset = value;\n    }\n    /**\n     * The size function returns the number of elements in an array.\n     * @returns {number} The size of the array, which is the difference between the length of the array and the offset.\n     */\n    get size() {\n        return this.nodes.length - this.offset;\n    }\n    /**\n     * The function \"fromArray\" creates a new Queue object from an array of elements.Creates a queue from an existing array.\n     * @public\n     * @static\n     * @param {E[]} elements - The \"elements\" parameter is an array of elements of type E.\n     * @returns The method is returning a new instance of the Queue class, initialized with the elements from the input\n     * array.\n     */\n    static fromArray(elements) {\n        return new Queue(elements);\n    }\n    /**\n     * The push function adds an element to the end of the queue and returns the updated queue.Adds an element at the back of the queue.\n     * @param {E} element - The `element` parameter represents the element that you want to add to the queue.\n     * @returns The `add` method is returning a `Queue<E>` object.\n     */\n    push(element) {\n        this.nodes.push(element);\n        return this;\n    }\n    /**\n     * The `shift` function removes and returns the first element in the queue, and adjusts the internal data structure if\n     * necessary to optimize performance.\n     * @returns The function `shift()` returns either the first element in the queue or `null` if the queue is empty.\n     */\n    shift() {\n        if (this.size === 0)\n            return undefined;\n        const first = this.peek();\n        this.offset += 1;\n        if (this.offset * 2 < this.nodes.length)\n            return first;\n        // only remove dequeued elements when reaching half size\n        // to decrease latency of shifting elements.\n        this.nodes = this.nodes.slice(this.offset);\n        this.offset = 0;\n        return first;\n    }\n    /**\n     * The `peek` function returns the first element of the array `_nodes` if it exists, otherwise it returns `null`.\n     * @returns The `peek()` method returns the first element of the data structure, represented by the `_nodes` array at\n     * the `_offset` index. If the data structure is empty (size is 0), it returns `null`.\n     */\n    peek() {\n        return this.size > 0 ? this.nodes[this.offset] : undefined;\n    }\n    /**\n     * The `peekLast` function returns the last element in an array-like data structure, or null if the structure is empty.\n     * @returns The method `peekLast()` returns the last element of the `_nodes` array if the array is not empty. If the\n     * array is empty, it returns `null`.\n     */\n    peekLast() {\n        return this.size > 0 ? this.nodes[this.nodes.length - 1] : undefined;\n    }\n    /**\n     * The enqueue function adds a value to the end of a queue.\n     * @param {E} value - The value parameter represents the value that you want to add to the queue.\n     */\n    enqueue(value) {\n        this.push(value);\n    }\n    /**\n     * The `dequeue` function removes and returns the first element from a queue, or returns null if the queue is empty.\n     * @returns The method is returning a value of type E or null.\n     */\n    dequeue() {\n        return this.shift();\n    }\n    getAt(index) {\n        return this.nodes[index];\n    }\n    /**\n     * The function checks if a data structure is empty by comparing its size to zero.\n     * @returns {boolean} A boolean value indicating whether the size of the object is 0 or not.\n     */\n    isEmpty() {\n        return this.size === 0;\n    }\n    /**\n     * The toArray() function returns an array of elements from the current offset to the end of the _nodes array.\n     * @returns An array of type E is being returned.\n     */\n    toArray() {\n        return this.nodes.slice(this.offset);\n    }\n    /**\n     * The clear function resets the nodes array and offset to their initial values.\n     */\n    clear() {\n        this.nodes = [];\n        this.offset = 0;\n    }\n    /**\n     * The `clone()` function returns a new Queue object with the same elements as the original Queue.\n     * @returns The `clone()` method is returning a new instance of the `Queue` class.\n     */\n    clone() {\n        return new Queue(this.nodes.slice(this.offset));\n    }\n    *[Symbol.iterator]() {\n        for (const item of this.nodes) {\n            yield item;\n        }\n    }\n}\n","/**\n * data-structure-typed\n *\n * @author Tyler Zeng\n * @copyright Copyright (c) 2022 Tyler Zeng <zrwusa@gmail.com>\n * @license MIT License\n */\nimport { DoublyLinkedList } from '../linked-list';\n// O(n) time complexity of obtaining the value\n// O(1) time complexity of adding at the beginning and the end\nexport class Deque extends DoublyLinkedList {\n}\n// O(1) time complexity of obtaining the value\n// O(n) time complexity of adding at the beginning and the end\n// todo tested slowest one\nexport class ObjectDeque {\n    constructor(capacity) {\n        this._nodes = {};\n        this._capacity = Number.MAX_SAFE_INTEGER;\n        this._first = -1;\n        this._last = -1;\n        this._size = 0;\n        if (capacity !== undefined)\n            this._capacity = capacity;\n    }\n    get nodes() {\n        return this._nodes;\n    }\n    get capacity() {\n        return this._capacity;\n    }\n    set capacity(value) {\n        this._capacity = value;\n    }\n    get first() {\n        return this._first;\n    }\n    set first(value) {\n        this._first = value;\n    }\n    get last() {\n        return this._last;\n    }\n    set last(value) {\n        this._last = value;\n    }\n    get size() {\n        return this._size;\n    }\n    /**\n     * The \"addFirst\" function adds a value to the beginning of an array-like data structure.\n     * @param {E} value - The `value` parameter represents the value that you want to add to the beginning of the data\n     * structure.\n     */\n    addFirst(value) {\n        if (this._size === 0) {\n            const mid = Math.floor(this._capacity / 2);\n            this._first = mid;\n            this._last = mid;\n        }\n        else {\n            this._first--;\n        }\n        this._nodes[this._first] = value;\n        this._size++;\n    }\n    /**\n     * The addLast function adds a value to the end of an array-like data structure.\n     * @param {E} value - The `value` parameter represents the value that you want to add to the end of the data structure.\n     */\n    addLast(value) {\n        if (this._size === 0) {\n            const mid = Math.floor(this._capacity / 2);\n            this._first = mid;\n            this._last = mid;\n        }\n        else {\n            this._last++;\n        }\n        this._nodes[this._last] = value;\n        this._size++;\n    }\n    /**\n     * The function `pollFirst()` removes and returns the first element in a data structure.\n     * @returns The value of the first element in the data structure.\n     */\n    pollFirst() {\n        if (!this._size)\n            return;\n        const value = this.peekFirst();\n        delete this._nodes[this._first];\n        this._first++;\n        this._size--;\n        return value;\n    }\n    /**\n     * The `peekFirst` function returns the first element in an array-like data structure if it exists.\n     * @returns The element at the first position of the `_nodes` array.\n     */\n    peekFirst() {\n        if (this._size)\n            return this._nodes[this._first];\n    }\n    /**\n     * The `pollLast()` function removes and returns the last element in a data structure.\n     * @returns The value that was removed from the data structure.\n     */\n    pollLast() {\n        if (!this._size)\n            return;\n        const value = this.peekLast();\n        delete this._nodes[this._last];\n        this._last--;\n        this._size--;\n        return value;\n    }\n    /**\n     * The `peekLast()` function returns the last element in an array-like data structure.\n     * @returns The last element in the array \"_nodes\" is being returned.\n     */\n    peekLast() {\n        if (this._size)\n            return this._nodes[this._last];\n    }\n    /**\n     * The get function returns the element at the specified index in an array-like data structure.\n     * @param {number} index - The index parameter is a number that represents the position of the element you want to\n     * retrieve from the array.\n     * @returns The element at the specified index in the `_nodes` array is being returned. If there is no element at that\n     * index, `null` is returned.\n     */\n    get(index) {\n        return this._nodes[this._first + index] || null;\n    }\n    /**\n     * The function checks if the size of a data structure is less than or equal to zero.\n     * @returns The method is returning a boolean value indicating whether the size of the object is less than or equal to 0.\n     */\n    isEmpty() {\n        return this._size <= 0;\n    }\n    _seNodes(value) {\n        this._nodes = value;\n    }\n    _setSize(value) {\n        this._size = value;\n    }\n}\n// O(1) time complexity of obtaining the value\n// O(n) time complexity of adding at the beginning and the end\nexport class ArrayDeque {\n    constructor() {\n        this._nodes = [];\n    }\n    get size() {\n        return this._nodes.length;\n    }\n    /**\n     * O(n) time complexity of adding at the beginning and the end\n     */\n    /**\n     * The function \"addLast\" adds a value to the end of an array.\n     * @param {E} value - The value parameter represents the value that you want to add to the end of the array.\n     * @returns The return value is the new length of the array after the value has been added.\n     */\n    addLast(value) {\n        return this._nodes.push(value);\n    }\n    /**\n     * The function \"pollLast\" returns and removes the last element from an array, or returns null if the array is empty.\n     * @returns The method `pollLast()` returns the last element of the `_nodes` array, or `null` if the array is empty.\n     */\n    pollLast() {\n        var _a;\n        return (_a = this._nodes.pop()) !== null && _a !== void 0 ? _a : null;\n    }\n    /**\n     * The `pollFirst` function removes and returns the first element from an array, or returns null if the array is empty.\n     * @returns The `pollFirst()` function returns the first element of the `_nodes` array, or `null` if the array is\n     * empty.\n     */\n    pollFirst() {\n        var _a;\n        return (_a = this._nodes.shift()) !== null && _a !== void 0 ? _a : null;\n    }\n    /**\n     * O(n) time complexity of adding at the beginning and the end\n     */\n    /**\n     * The function \"addFirst\" adds a value to the beginning of an array.\n     * @param {E} value - The value parameter represents the value that you want to add to the beginning of the array.\n     * @returns The return value of the `addFirst` function is the new length of the array `_nodes` after adding the\n     * `value` at the beginning.\n     */\n    addFirst(value) {\n        return this._nodes.unshift(value);\n    }\n    /**\n     * The `peekFirst` function returns the first element of an array or null if the array is empty.\n     * @returns The function `peekFirst()` is returning the first element (`E`) of the `_nodes` array. If the array is\n     * empty, it will return `null`.\n     */\n    peekFirst() {\n        var _a;\n        return (_a = this._nodes[0]) !== null && _a !== void 0 ? _a : null;\n    }\n    /**\n     * The `peekLast` function returns the last element of an array or null if the array is empty.\n     * @returns The method `peekLast()` returns the last element of the `_nodes` array, or `null` if the array is empty.\n     */\n    peekLast() {\n        var _a;\n        return (_a = this._nodes[this._nodes.length - 1]) !== null && _a !== void 0 ? _a : null;\n    }\n    /**\n     * O(1) time complexity of obtaining the value\n     */\n    /**\n     * The get function returns the element at the specified index in an array, or null if the index is out of bounds.\n     * @param {number} index - The index parameter is a number that represents the position of the element you want to\n     * retrieve from the array.\n     * @returns The method is returning the element at the specified index in the `_nodes` array. If the element exists, it\n     * will be returned. If the element does not exist (i.e., the index is out of bounds), `null` will be returned.\n     */\n    get(index) {\n        var _a;\n        return (_a = this._nodes[index]) !== null && _a !== void 0 ? _a : null;\n    }\n    /**\n     * The set function assigns a value to a specific index in an array.\n     * @param {number} index - The index parameter is a number that represents the position of the element in the array\n     * that you want to set a new value for.\n     * @param {E} value - The value parameter represents the new value that you want to set at the specified index in the\n     * _nodes array.\n     * @returns The value that is being set at the specified index in the `_nodes` array.\n     */\n    set(index, value) {\n        return (this._nodes[index] = value);\n    }\n    /**\n     * The insert function adds a value at a specified index in an array.\n     * @param {number} index - The index parameter specifies the position at which the value should be inserted in the\n     * array. It is a number that represents the index of the array where the value should be inserted. The index starts\n     * from 0, so the first element of the array has an index of 0, the second element has\n     * @param {E} value - The value parameter represents the value that you want to insert into the array at the specified\n     * index.\n     * @returns The splice method returns an array containing the removed elements, if any. In this case, since no elements\n     * are being removed, an empty array will be returned.\n     */\n    insert(index, value) {\n        return this._nodes.splice(index, 0, value);\n    }\n    /**\n     * The remove function removes an element from an array at a specified index.\n     * @param {number} index - The index parameter specifies the position of the element to be removed from the array. It\n     * is a number that represents the index of the element to be removed.\n     * @returns The method is returning an array containing the removed element.\n     */\n    remove(index) {\n        return this._nodes.splice(index, 1);\n    }\n    /**\n     * The function checks if an array called \"_nodes\" is empty.\n     * @returns The method `isEmpty()` is returning a boolean value. It returns `true` if the length of the `_nodes` array\n     * is 0, indicating that the array is empty. Otherwise, it returns `false`.\n     */\n    isEmpty() {\n        return this._nodes.length === 0;\n    }\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nexport const uuidV4 = function () {\n    return 'xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx'.replace(/[x]/g, function (c) {\n        const r = (Math.random() * 16) | 0, v = c == 'x' ? r : (r & 0x3) | 0x8;\n        return v.toString(16);\n    });\n};\nexport const arrayRemove = function (array, predicate) {\n    let i = -1, len = array ? array.length : 0;\n    const result = [];\n    while (++i < len) {\n        const value = array[i];\n        if (predicate(value, i, array)) {\n            result.push(value);\n            Array.prototype.splice.call(array, i--, 1);\n            len--;\n        }\n    }\n    return result;\n};\nexport const THUNK_SYMBOL = Symbol('thunk');\nexport const isThunk = (fnOrValue) => {\n    return typeof fnOrValue === 'function' && fnOrValue.__THUNK__ === THUNK_SYMBOL;\n};\nexport const toThunk = (fn) => {\n    const thunk = () => fn();\n    thunk.__THUNK__ = THUNK_SYMBOL;\n    return thunk;\n};\nexport const trampoline = (fn) => {\n    const cont = (...args) => toThunk(() => fn(...args));\n    return Object.assign((...args) => {\n        let result = fn(...args);\n        while (isThunk(result) && typeof result === 'function') {\n            result = result();\n        }\n        return result;\n    }, { cont });\n};\nexport const trampolineAsync = (fn) => {\n    const cont = (...args) => toThunk(() => fn(...args));\n    return Object.assign((...args) => __awaiter(void 0, void 0, void 0, function* () {\n        let result = yield fn(...args);\n        while (isThunk(result) && typeof result === 'function') {\n            result = yield result();\n        }\n        return result;\n    }), { cont });\n};\n","/**\n * data-structure-typed\n * @author Kirk Qi\n * @copyright Copyright (c) 2022 Kirk Qi <qilinaus@gmail.com>\n * @license MIT License\n */\nexport class Heap {\n    constructor(comparator) {\n        this.nodes = [];\n        this.comparator = comparator;\n    }\n    /**\n     * Insert an element into the heap and maintain the heap properties.\n     * @param value - The element to be inserted.\n     */\n    add(value) {\n        this.nodes.push(value);\n        this.bubbleUp(this.nodes.length - 1);\n        return this;\n    }\n    /**\n     * Remove and return the top element (smallest or largest element) from the heap.\n     * @returns The top element or null if the heap is empty.\n     */\n    poll() {\n        if (this.nodes.length === 0) {\n            return null;\n        }\n        if (this.nodes.length === 1) {\n            return this.nodes.pop();\n        }\n        const topValue = this.nodes[0];\n        this.nodes[0] = this.nodes.pop();\n        this.sinkDown(0);\n        return topValue;\n    }\n    /**\n     * Float operation to maintain heap properties after adding an element.\n     * @param index - The index of the newly added element.\n     */\n    bubbleUp(index) {\n        const element = this.nodes[index];\n        while (index > 0) {\n            const parentIndex = Math.floor((index - 1) / 2);\n            const parent = this.nodes[parentIndex];\n            if (this.comparator(element, parent) < 0) {\n                this.nodes[index] = parent;\n                this.nodes[parentIndex] = element;\n                index = parentIndex;\n            }\n            else {\n                break;\n            }\n        }\n    }\n    /**\n     * Sinking operation to maintain heap properties after removing the top element.\n     * @param index - The index from which to start sinking.\n     */\n    sinkDown(index) {\n        const leftChildIndex = 2 * index + 1;\n        const rightChildIndex = 2 * index + 2;\n        const length = this.nodes.length;\n        let targetIndex = index;\n        if (leftChildIndex < length && this.comparator(this.nodes[leftChildIndex], this.nodes[targetIndex]) < 0) {\n            targetIndex = leftChildIndex;\n        }\n        if (rightChildIndex < length && this.comparator(this.nodes[rightChildIndex], this.nodes[targetIndex]) < 0) {\n            targetIndex = rightChildIndex;\n        }\n        if (targetIndex !== index) {\n            const temp = this.nodes[index];\n            this.nodes[index] = this.nodes[targetIndex];\n            this.nodes[targetIndex] = temp;\n            this.sinkDown(targetIndex);\n        }\n    }\n    /**\n     * Fix the entire heap to maintain heap properties.\n     */\n    fix() {\n        for (let i = Math.floor(this.size / 2); i >= 0; i--)\n            this.sinkDown(i);\n    }\n    /**\n     * Peek at the top element of the heap without removing it.\n     * @returns The top element or null if the heap is empty.\n     */\n    peek() {\n        if (this.nodes.length === 0) {\n            return null;\n        }\n        return this.nodes[0];\n    }\n    /**\n     * Get the size (number of elements) of the heap.\n     */\n    get size() {\n        return this.nodes.length;\n    }\n    /**\n     * Get the last element in the heap, which is not necessarily a leaf node.\n     * @returns The last element or null if the heap is empty.\n     */\n    get leaf() {\n        var _a;\n        return (_a = this.nodes[this.size - 1]) !== null && _a !== void 0 ? _a : null;\n    }\n    /**\n     * Check if the heap is empty.\n     * @returns True if the heap is empty, otherwise false.\n     */\n    isEmpty() {\n        return this.size === 0;\n    }\n    /**\n     * Reset the nodes of the heap. Make the nodes empty.\n     */\n    clear() {\n        this.nodes = [];\n    }\n    /**\n     * Clear and add nodes of the heap\n     * @param nodes\n     */\n    refill(nodes) {\n        this.nodes = nodes;\n        this.fix();\n    }\n    /**\n     * Use a comparison function to check whether a binary heap contains a specific element.\n     * @param value - the element to check.\n     * @returns Returns true if the specified element is contained; otherwise, returns false.\n     */\n    has(value) {\n        return this.nodes.includes(value);\n    }\n    /**\n     * Depth-first search (DFS) method, different traversal orders can be selected\n     * @param order - Traversal order parameter: 'in' (in-order), 'pre' (pre-order) or 'post' (post-order).\n     * @returns An array containing elements traversed in the specified order.\n     */\n    dfs(order) {\n        const result = [];\n        // Auxiliary recursive function, traverses the binary heap according to the traversal order\n        const dfsHelper = (index) => {\n            if (index < this.size) {\n                if (order === 'in') {\n                    dfsHelper(2 * index + 1);\n                    result.push(this.nodes[index]);\n                    dfsHelper(2 * index + 2);\n                }\n                else if (order === 'pre') {\n                    result.push(this.nodes[index]);\n                    dfsHelper(2 * index + 1);\n                    dfsHelper(2 * index + 2);\n                }\n                else if (order === 'post') {\n                    dfsHelper(2 * index + 1);\n                    dfsHelper(2 * index + 2);\n                    result.push(this.nodes[index]);\n                }\n            }\n        };\n        dfsHelper(0); // Traverse starting from the root node\n        return result;\n    }\n    /**\n     * Convert the heap to an array.\n     * @returns An array containing the elements of the heap.\n     */\n    toArray() {\n        return [...this.nodes];\n    }\n    getNodes() {\n        return this.nodes;\n    }\n    /**\n     * Clone the heap, creating a new heap with the same elements.\n     * @returns A new Heap instance containing the same elements.\n     */\n    clone() {\n        const clonedHeap = new Heap(this.comparator);\n        clonedHeap.nodes = [...this.nodes];\n        return clonedHeap;\n    }\n    /**\n     * Sort the elements in the heap and return them as an array.\n     * @returns An array containing the elements sorted in ascending order.\n     */\n    sort() {\n        const visitedNode = [];\n        const cloned = this.clone();\n        while (cloned.size !== 0) {\n            const top = cloned.poll();\n            if (top)\n                visitedNode.push(top);\n        }\n        return visitedNode;\n    }\n    /**\n     * Static method that creates a binary heap from an array of nodes and a comparison function.\n     * @param nodes\n     * @param comparator - Comparison function.\n     * @returns A new Heap instance.\n     */\n    static heapify(nodes, comparator) {\n        const binaryHeap = new Heap(comparator);\n        binaryHeap.nodes = [...nodes];\n        binaryHeap.fix(); // Fix heap properties\n        return binaryHeap;\n    }\n}\n","/**\n * data-structure-typed\n *\n * @author Kirk Qi\n * @copyright Copyright (c) 2022 Kirk Qi <qilinaus@gmail.com>\n * @license MIT License\n */\nimport { Heap } from '../heap';\nexport class PriorityQueue extends Heap {\n    constructor(comparator) {\n        super(comparator);\n    }\n}\n","/**\n * data-structure-typed\n *\n * @author Kirk Qi\n * @copyright Copyright (c) 2022 Kirk Qi <qilinaus@gmail.com>\n * @license MIT License\n */\nimport { arrayRemove, uuidV4 } from '../../utils';\nimport { PriorityQueue } from '../priority-queue';\nexport class AbstractVertex {\n    /**\n     * The function is a protected constructor that takes an key and an optional value as parameters.\n     * @param {VertexKey} key - The `key` parameter is of type `VertexKey` and represents the identifier of the vertex. It is\n     * used to uniquely identify the vertex object.\n     * @param {V} [val] - The parameter \"val\" is an optional parameter of type V. It is used to assign a value to the\n     * vertex. If no value is provided, it will be set to undefined.\n     */\n    constructor(key, val) {\n        this._key = key;\n        this._val = val;\n    }\n    get key() {\n        return this._key;\n    }\n    set key(v) {\n        this._key = v;\n    }\n    get val() {\n        return this._val;\n    }\n    set val(value) {\n        this._val = value;\n    }\n}\nexport class AbstractEdge {\n    /**\n     * The above function is a protected constructor that initializes the weight, value, and hash code properties of an\n     * object.\n     * @param {number} [weight] - The `weight` parameter is an optional number that represents the weight of the object. If\n     * a value is provided, it will be assigned to the `_weight` property. If no value is provided, the default value of 1\n     * will be assigned.\n     * @param {V} [val] - The `val` parameter is of type `V`, which means it can be any type. It is an optional parameter,\n     * meaning it can be omitted when creating an instance of the class.\n     */\n    constructor(weight, val) {\n        this._weight = weight !== undefined ? weight : 1;\n        this._val = val;\n        this._hashCode = uuidV4();\n    }\n    get val() {\n        return this._val;\n    }\n    set val(value) {\n        this._val = value;\n    }\n    get weight() {\n        return this._weight;\n    }\n    set weight(v) {\n        this._weight = v;\n    }\n    get hashCode() {\n        return this._hashCode;\n    }\n    /**\n     * In TypeScript, a subclass inherits the interface implementation of its parent class, without needing to implement the same interface again in the subclass. This behavior differs from Java's approach. In Java, if a parent class implements an interface, the subclass needs to explicitly implement the same interface, even if the parent class has already implemented it.\n     * This means that using abstract methods in the parent class cannot constrain the grandchild classes. Defining methods within an interface also cannot constrain the descendant classes. When inheriting from this class, developers need to be aware that this method needs to be overridden.\n     */\n    /**\n     * The function sets the value of the _hashCode property to the provided string.\n     * @param {string} v - The parameter \"v\" is of type string and represents the value that will be assigned to the\n     * \"_hashCode\" property.\n     */\n    _setHashCode(v) {\n        this._hashCode = v;\n    }\n}\nexport class AbstractGraph {\n    constructor() {\n        this._vertices = new Map();\n    }\n    get vertices() {\n        return this._vertices;\n    }\n    /**\n     * The function \"getVertex\" returns the vertex with the specified ID or null if it doesn't exist.\n     * @param {VertexKey} vertexKey - The `vertexKey` parameter is the identifier of the vertex that you want to retrieve from\n     * the `_vertices` map.\n     * @returns The method `getVertex` returns the vertex with the specified `vertexKey` if it exists in the `_vertices`\n     * map. If the vertex does not exist, it returns `null`.\n     */\n    getVertex(vertexKey) {\n        return this._vertices.get(vertexKey) || null;\n    }\n    /**\n     * The function checks if a vertex exists in a graph.\n     * @param {V | VertexKey} vertexOrKey - The parameter `vertexOrKey` can be either a vertex object (`V`) or a vertex ID\n     * (`VertexKey`).\n     * @returns a boolean value.\n     */\n    hasVertex(vertexOrKey) {\n        return this._vertices.has(this._getVertexKey(vertexOrKey));\n    }\n    addVertex(keyOrVertex, val) {\n        if (keyOrVertex instanceof AbstractVertex) {\n            return this._addVertexOnly(keyOrVertex);\n        }\n        else {\n            const newVertex = this.createVertex(keyOrVertex, val);\n            return this._addVertexOnly(newVertex);\n        }\n    }\n    /**\n     * The `removeVertex` function removes a vertex from a graph by its ID or by the vertex object itself.\n     * @param {V | VertexKey} vertexOrKey - The parameter `vertexOrKey` can be either a vertex object (`V`) or a vertex ID\n     * (`VertexKey`).\n     * @returns The method is returning a boolean value.\n     */\n    removeVertex(vertexOrKey) {\n        const vertexKey = this._getVertexKey(vertexOrKey);\n        return this._vertices.delete(vertexKey);\n    }\n    /**\n     * The function removes all vertices from a graph and returns a boolean indicating if any vertices were removed.\n     * @param {V[] | VertexKey[]} vertices - The `vertices` parameter can be either an array of vertices (`V[]`) or an array\n     * of vertex IDs (`VertexKey[]`).\n     * @returns a boolean value. It returns true if at least one vertex was successfully removed, and false if no vertices\n     * were removed.\n     */\n    removeAllVertices(vertices) {\n        const removed = [];\n        for (const v of vertices) {\n            removed.push(this.removeVertex(v));\n        }\n        return removed.length > 0;\n    }\n    /**\n     * The function checks if there is an edge between two vertices and returns a boolean value indicating the result.\n     * @param {VertexKey | V} v1 - The parameter v1 can be either a VertexKey or a V. A VertexKey represents the unique\n     * identifier of a vertex in a graph, while V represents the type of the vertex object itself.\n     * @param {VertexKey | V} v2 - The parameter `v2` represents the second vertex in the edge. It can be either a\n     * `VertexKey` or a `V` type, which represents the type of the vertex.\n     * @returns A boolean value is being returned.\n     */\n    hasEdge(v1, v2) {\n        const edge = this.getEdge(v1, v2);\n        return !!edge;\n    }\n    addEdge(srcOrEdge, dest, weight, val) {\n        if (srcOrEdge instanceof AbstractEdge) {\n            return this._addEdgeOnly(srcOrEdge);\n        }\n        else {\n            if (dest instanceof AbstractVertex || typeof dest === 'string' || typeof dest === 'number') {\n                if (!(this.hasVertex(srcOrEdge) && this.hasVertex(dest)))\n                    return false;\n                if (srcOrEdge instanceof AbstractVertex)\n                    srcOrEdge = srcOrEdge.key;\n                if (dest instanceof AbstractVertex)\n                    dest = dest.key;\n                const newEdge = this.createEdge(srcOrEdge, dest, weight, val);\n                return this._addEdgeOnly(newEdge);\n            }\n            else {\n                throw new Error('dest must be a Vertex or vertex key while srcOrEdge is an Edge');\n            }\n        }\n    }\n    /**\n     * The function sets the weight of an edge between two vertices in a graph.\n     * @param {VertexKey | V} srcOrKey - The `srcOrKey` parameter can be either a `VertexKey` or a `V` object. It represents\n     * the source vertex of the edge.\n     * @param {VertexKey | V} destOrKey - The `destOrKey` parameter represents the destination vertex of the edge. It can be\n     * either a `VertexKey` or a vertex object `V`.\n     * @param {number} weight - The weight parameter represents the weight of the edge between the source vertex (srcOrKey)\n     * and the destination vertex (destOrKey).\n     * @returns a boolean value. If the edge exists between the source and destination vertices, the function will update\n     * the weight of the edge and return true. If the edge does not exist, the function will return false.\n     */\n    setEdgeWeight(srcOrKey, destOrKey, weight) {\n        const edge = this.getEdge(srcOrKey, destOrKey);\n        if (edge) {\n            edge.weight = weight;\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    /**\n     * The function `getAllPathsBetween` finds all paths between two vertices in a graph using depth-first search.\n     * @param {V | VertexKey} v1 - The parameter `v1` represents either a vertex object (`V`) or a vertex ID (`VertexKey`).\n     * It is the starting vertex for finding paths.\n     * @param {V | VertexKey} v2 - The parameter `v2` represents either a vertex object (`V`) or a vertex ID (`VertexKey`).\n     * @returns The function `getAllPathsBetween` returns an array of arrays of vertices (`V[][]`).\n     */\n    getAllPathsBetween(v1, v2) {\n        const paths = [];\n        const vertex1 = this._getVertex(v1);\n        const vertex2 = this._getVertex(v2);\n        if (!(vertex1 && vertex2)) {\n            return [];\n        }\n        const dfs = (cur, dest, visiting, path) => {\n            visiting.set(cur, true);\n            if (cur === dest) {\n                paths.push([vertex1, ...path]);\n            }\n            const neighbors = this.getNeighbors(cur);\n            for (const neighbor of neighbors) {\n                if (!visiting.get(neighbor)) {\n                    path.push(neighbor);\n                    dfs(neighbor, dest, visiting, path);\n                    arrayRemove(path, (vertex) => vertex === neighbor);\n                }\n            }\n            visiting.set(cur, false);\n        };\n        dfs(vertex1, vertex2, new Map(), []);\n        return paths;\n    }\n    /**\n     * The function calculates the sum of weights along a given path.\n     * @param {V[]} path - An array of vertices (V) representing a path in a graph.\n     * @returns The function `getPathSumWeight` returns the sum of the weights of the edges in the given path.\n     */\n    getPathSumWeight(path) {\n        var _a;\n        let sum = 0;\n        for (let i = 0; i < path.length; i++) {\n            sum += ((_a = this.getEdge(path[i], path[i + 1])) === null || _a === void 0 ? void 0 : _a.weight) || 0;\n        }\n        return sum;\n    }\n    /**\n     * The function `getMinCostBetween` calculates the minimum cost between two vertices in a graph, either based on edge\n     * weights or using a breadth-first search algorithm.\n     * @param {V | VertexKey} v1 - The parameter `v1` represents the starting vertex or its ID.\n     * @param {V | VertexKey} v2 - The parameter `v2` represents the destination vertex or its ID. It is the vertex to which\n     * you want to find the minimum cost or weight from the source vertex `v1`.\n     * @param {boolean} [isWeight] - isWeight is an optional parameter that indicates whether the graph edges have weights.\n     * If isWeight is set to true, the function will calculate the minimum cost between v1 and v2 based on the weights of\n     * the edges. If isWeight is set to false or not provided, the function will calculate the\n     * @returns The function `getMinCostBetween` returns a number representing the minimum cost between two vertices (`v1`\n     * and `v2`). If the `isWeight` parameter is `true`, it calculates the minimum weight among all paths between the\n     * vertices. If `isWeight` is `false` or not provided, it uses a breadth-first search (BFS) algorithm to calculate the\n     * minimum number of\n     */\n    getMinCostBetween(v1, v2, isWeight) {\n        if (isWeight === undefined)\n            isWeight = false;\n        if (isWeight) {\n            const allPaths = this.getAllPathsBetween(v1, v2);\n            let min = Infinity;\n            for (const path of allPaths) {\n                min = Math.min(this.getPathSumWeight(path), min);\n            }\n            return min;\n        }\n        else {\n            // BFS\n            const vertex2 = this._getVertex(v2);\n            const vertex1 = this._getVertex(v1);\n            if (!(vertex1 && vertex2)) {\n                return null;\n            }\n            const visited = new Map();\n            const queue = [vertex1];\n            visited.set(vertex1, true);\n            let cost = 0;\n            while (queue.length > 0) {\n                for (let i = 0; i < queue.length; i++) {\n                    const cur = queue.shift();\n                    if (cur === vertex2) {\n                        return cost;\n                    }\n                    // TODO consider optimizing to AbstractGraph\n                    if (cur !== undefined) {\n                        const neighbors = this.getNeighbors(cur);\n                        for (const neighbor of neighbors) {\n                            if (!visited.has(neighbor)) {\n                                visited.set(neighbor, true);\n                                queue.push(neighbor);\n                            }\n                        }\n                    }\n                }\n                cost++;\n            }\n            return null;\n        }\n    }\n    /**\n     * The function `getMinPathBetween` returns the minimum path between two vertices in a graph, either based on weight or\n     * using a breadth-first search algorithm.\n     * @param {V | VertexKey} v1 - The parameter `v1` represents the starting vertex of the path. It can be either a vertex\n     * object (`V`) or a vertex ID (`VertexKey`).\n     * @param {V | VertexKey} v2 - V | VertexKey - The second vertex or vertex ID between which we want to find the minimum\n     * path.\n     * @param {boolean} [isWeight] - A boolean flag indicating whether to consider the weight of edges in finding the\n     * minimum path. If set to true, the function will use Dijkstra's algorithm to find the minimum weighted path. If set\n     * to false, the function will use breadth-first search (BFS) to find the minimum path.\n     * @returns The function `getMinPathBetween` returns an array of vertices (`V[]`) representing the minimum path between\n     * two vertices (`v1` and `v2`). If there is no path between the vertices, it returns `null`.\n     */\n    getMinPathBetween(v1, v2, isWeight) {\n        if (isWeight === undefined)\n            isWeight = false;\n        if (isWeight) {\n            const allPaths = this.getAllPathsBetween(v1, v2);\n            let min = Infinity;\n            let minIndex = -1;\n            let index = 0;\n            for (const path of allPaths) {\n                const pathSumWeight = this.getPathSumWeight(path);\n                if (pathSumWeight < min) {\n                    min = pathSumWeight;\n                    minIndex = index;\n                }\n                index++;\n            }\n            return allPaths[minIndex] || null;\n        }\n        else {\n            // BFS\n            let minPath = [];\n            const vertex1 = this._getVertex(v1);\n            const vertex2 = this._getVertex(v2);\n            if (!(vertex1 && vertex2)) {\n                return [];\n            }\n            const dfs = (cur, dest, visiting, path) => {\n                visiting.set(cur, true);\n                if (cur === dest) {\n                    minPath = [vertex1, ...path];\n                    return;\n                }\n                const neighbors = this.getNeighbors(cur);\n                for (const neighbor of neighbors) {\n                    if (!visiting.get(neighbor)) {\n                        path.push(neighbor);\n                        dfs(neighbor, dest, visiting, path);\n                        arrayRemove(path, (vertex) => vertex === neighbor);\n                    }\n                }\n                visiting.set(cur, false);\n            };\n            dfs(vertex1, vertex2, new Map(), []);\n            return minPath;\n        }\n    }\n    /**\n     * Dijkstra algorithm time: O(VE) space: O(V + E)\n     * /\n  \n     /**\n     * Dijkstra algorithm time: O(VE) space: O(V + E)\n     * The function `dijkstraWithoutHeap` implements Dijkstra's algorithm to find the shortest path between two vertices in\n     * a graph without using a heap data structure.\n     * @param {V | VertexKey} src - The source vertex from which to start the Dijkstra's algorithm. It can be either a\n     * vertex object or a vertex ID.\n     * @param {V | VertexKey | null} [dest] - The `dest` parameter in the `dijkstraWithoutHeap` function is an optional\n     * parameter that specifies the destination vertex for the Dijkstra algorithm. It can be either a vertex object or its\n     * identifier. If no destination is provided, the value is set to `null`.\n     * @param {boolean} [getMinDist] - The `getMinDist` parameter is a boolean flag that determines whether the minimum\n     * distance from the source vertex to the destination vertex should be calculated and returned in the result. If\n     * `getMinDist` is set to `true`, the `minDist` property in the result will contain the minimum distance\n     * @param {boolean} [genPaths] - The `genPaths` parameter is a boolean flag that determines whether or not to generate\n     * paths in the Dijkstra algorithm. If `genPaths` is set to `true`, the algorithm will calculate and return the\n     * shortest paths from the source vertex to all other vertices in the graph. If `genPaths\n     * @returns The function `dijkstraWithoutHeap` returns an object of type `DijkstraResult<V>`.\n     */\n    dijkstraWithoutHeap(src, dest, getMinDist, genPaths) {\n        if (getMinDist === undefined)\n            getMinDist = false;\n        if (genPaths === undefined)\n            genPaths = false;\n        if (dest === undefined)\n            dest = null;\n        let minDist = Infinity;\n        let minDest = null;\n        let minPath = [];\n        const paths = [];\n        const vertices = this._vertices;\n        const distMap = new Map();\n        const seen = new Set();\n        const preMap = new Map(); // predecessor\n        const srcVertex = this._getVertex(src);\n        const destVertex = dest ? this._getVertex(dest) : null;\n        if (!srcVertex) {\n            return null;\n        }\n        for (const vertex of vertices) {\n            const vertexOrKey = vertex[1];\n            if (vertexOrKey instanceof AbstractVertex)\n                distMap.set(vertexOrKey, Infinity);\n        }\n        distMap.set(srcVertex, 0);\n        preMap.set(srcVertex, null);\n        const getMinOfNoSeen = () => {\n            let min = Infinity;\n            let minV = null;\n            for (const [key, val] of distMap) {\n                if (!seen.has(key)) {\n                    if (val < min) {\n                        min = val;\n                        minV = key;\n                    }\n                }\n            }\n            return minV;\n        };\n        const getPaths = (minV) => {\n            for (const vertex of vertices) {\n                const vertexOrKey = vertex[1];\n                if (vertexOrKey instanceof AbstractVertex) {\n                    const path = [vertexOrKey];\n                    let parent = preMap.get(vertexOrKey);\n                    while (parent) {\n                        path.push(parent);\n                        parent = preMap.get(parent);\n                    }\n                    const reversed = path.reverse();\n                    if (vertex[1] === minV)\n                        minPath = reversed;\n                    paths.push(reversed);\n                }\n            }\n        };\n        for (let i = 1; i < vertices.size; i++) {\n            const cur = getMinOfNoSeen();\n            if (cur) {\n                seen.add(cur);\n                if (destVertex && destVertex === cur) {\n                    if (getMinDist) {\n                        minDist = distMap.get(destVertex) || Infinity;\n                    }\n                    if (genPaths) {\n                        getPaths(destVertex);\n                    }\n                    return { distMap, preMap, seen, paths, minDist, minPath };\n                }\n                const neighbors = this.getNeighbors(cur);\n                for (const neighbor of neighbors) {\n                    if (!seen.has(neighbor)) {\n                        const edge = this.getEdge(cur, neighbor);\n                        if (edge) {\n                            const curFromMap = distMap.get(cur);\n                            const neighborFromMap = distMap.get(neighbor);\n                            // TODO after no-non-null-assertion not ensure the logic\n                            if (curFromMap !== undefined && neighborFromMap !== undefined) {\n                                if (edge.weight + curFromMap < neighborFromMap) {\n                                    distMap.set(neighbor, edge.weight + curFromMap);\n                                    preMap.set(neighbor, cur);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        getMinDist &&\n            distMap.forEach((d, v) => {\n                if (v !== srcVertex) {\n                    if (d < minDist) {\n                        minDist = d;\n                        if (genPaths)\n                            minDest = v;\n                    }\n                }\n            });\n        genPaths && getPaths(minDest);\n        return { distMap, preMap, seen, paths, minDist, minPath };\n    }\n    /**\n     * Dijkstra algorithm time: O(logVE) space: O(V + E)\n     *\n     * Dijkstra's algorithm only solves the single-source shortest path problem, while the Bellman-Ford algorithm and Floyd-Warshall algorithm can address shortest paths between all pairs of nodes.\n     * Dijkstra's algorithm is suitable for graphs with non-negative edge weights, whereas the Bellman-Ford algorithm and Floyd-Warshall algorithm can handle negative-weight edges.\n     * The time complexity of Dijkstra's algorithm and the Bellman-Ford algorithm depends on the size of the graph, while the time complexity of the Floyd-Warshall algorithm is O(V^3), where V is the number of nodes. For dense graphs, Floyd-Warshall might become slower.\n     *\n     * /\n  \n     /**\n     * Dijkstra's algorithm is used to find the shortest paths from a source node to all other nodes in a graph. Its basic idea is to repeatedly choose the node closest to the source node and update the distances of other nodes using this node as an intermediary. Dijkstra's algorithm requires that the edge weights in the graph are non-negative.\n     * The `dijkstra` function implements Dijkstra's algorithm to find the shortest path between a source vertex and an\n     * optional destination vertex, and optionally returns the minimum distance, the paths, and other information.\n     * @param {V | VertexKey} src - The `src` parameter represents the source vertex from which the Dijkstra algorithm will\n     * start. It can be either a vertex object or a vertex ID.\n     * @param {V | VertexKey | null} [dest] - The `dest` parameter is the destination vertex or vertex ID. It specifies the\n     * vertex to which the shortest path is calculated from the source vertex. If no destination is provided, the algorithm\n     * will calculate the shortest paths to all other vertices from the source vertex.\n     * @param {boolean} [getMinDist] - The `getMinDist` parameter is a boolean flag that determines whether the minimum\n     * distance from the source vertex to the destination vertex should be calculated and returned in the result. If\n     * `getMinDist` is set to `true`, the `minDist` property in the result will contain the minimum distance\n     * @param {boolean} [genPaths] - The `genPaths` parameter is a boolean flag that determines whether or not to generate\n     * paths in the Dijkstra algorithm. If `genPaths` is set to `true`, the algorithm will calculate and return the\n     * shortest paths from the source vertex to all other vertices in the graph. If `genPaths\n     * @returns The function `dijkstra` returns an object of type `DijkstraResult<V>`.\n     */\n    dijkstra(src, dest, getMinDist, genPaths) {\n        var _a;\n        if (getMinDist === undefined)\n            getMinDist = false;\n        if (genPaths === undefined)\n            genPaths = false;\n        if (dest === undefined)\n            dest = null;\n        let minDist = Infinity;\n        let minDest = null;\n        let minPath = [];\n        const paths = [];\n        const vertices = this._vertices;\n        const distMap = new Map();\n        const seen = new Set();\n        const preMap = new Map(); // predecessor\n        const srcVertex = this._getVertex(src);\n        const destVertex = dest ? this._getVertex(dest) : null;\n        if (!srcVertex)\n            return null;\n        for (const vertex of vertices) {\n            const vertexOrKey = vertex[1];\n            if (vertexOrKey instanceof AbstractVertex)\n                distMap.set(vertexOrKey, Infinity);\n        }\n        const heap = new PriorityQueue((a, b) => a.key - b.key);\n        heap.add({ key: 0, val: srcVertex });\n        distMap.set(srcVertex, 0);\n        preMap.set(srcVertex, null);\n        /**\n         * The function `getPaths` retrieves all paths from vertices to a specified minimum vertex.\n         * @param {V | null} minV - The parameter `minV` is of type `V | null`. It represents the minimum vertex value or\n         * null.\n         */\n        const getPaths = (minV) => {\n            for (const vertex of vertices) {\n                const vertexOrKey = vertex[1];\n                if (vertexOrKey instanceof AbstractVertex) {\n                    const path = [vertexOrKey];\n                    let parent = preMap.get(vertexOrKey);\n                    while (parent) {\n                        path.push(parent);\n                        parent = preMap.get(parent);\n                    }\n                    const reversed = path.reverse();\n                    if (vertex[1] === minV)\n                        minPath = reversed;\n                    paths.push(reversed);\n                }\n            }\n        };\n        while (heap.size > 0) {\n            const curHeapNode = heap.poll();\n            const dist = curHeapNode === null || curHeapNode === void 0 ? void 0 : curHeapNode.key;\n            const cur = curHeapNode === null || curHeapNode === void 0 ? void 0 : curHeapNode.val;\n            if (dist !== undefined) {\n                if (cur) {\n                    seen.add(cur);\n                    if (destVertex && destVertex === cur) {\n                        if (getMinDist) {\n                            minDist = distMap.get(destVertex) || Infinity;\n                        }\n                        if (genPaths) {\n                            getPaths(destVertex);\n                        }\n                        return { distMap, preMap, seen, paths, minDist, minPath };\n                    }\n                    const neighbors = this.getNeighbors(cur);\n                    for (const neighbor of neighbors) {\n                        if (!seen.has(neighbor)) {\n                            const weight = (_a = this.getEdge(cur, neighbor)) === null || _a === void 0 ? void 0 : _a.weight;\n                            if (typeof weight === 'number') {\n                                const distSrcToNeighbor = distMap.get(neighbor);\n                                if (distSrcToNeighbor) {\n                                    if (dist + weight < distSrcToNeighbor) {\n                                        heap.add({ key: dist + weight, val: neighbor });\n                                        preMap.set(neighbor, cur);\n                                        distMap.set(neighbor, dist + weight);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (getMinDist) {\n            distMap.forEach((d, v) => {\n                if (v !== srcVertex) {\n                    if (d < minDist) {\n                        minDist = d;\n                        if (genPaths)\n                            minDest = v;\n                    }\n                }\n            });\n        }\n        if (genPaths) {\n            getPaths(minDest);\n        }\n        return { distMap, preMap, seen, paths, minDist, minPath };\n    }\n    /**\n     * BellmanFord time:O(VE) space:O(V)\n     * one to rest pairs\n     * /\n  \n     /**\n     * BellmanFord time:O(VE) space:O(V)\n     * one to rest pairs\n     * The Bellman-Ford algorithm is also used to find the shortest paths from a source node to all other nodes in a graph. Unlike Dijkstra's algorithm, it can handle edge weights that are negative. Its basic idea involves iterative relaxation of all edges for several rounds to gradually approximate the shortest paths. Due to its ability to handle negative-weight edges, the Bellman-Ford algorithm is more flexible in some scenarios.\n     * The `bellmanFord` function implements the Bellman-Ford algorithm to find the shortest path from a source vertex to\n     * all other vertices in a graph, and optionally detects negative cycles and generates the minimum path.\n     * @param {V | VertexKey} src - The `src` parameter is the source vertex from which the Bellman-Ford algorithm will\n     * start calculating the shortest paths. It can be either a vertex object or a vertex ID.\n     * @param {boolean} [scanNegativeCycle] - A boolean flag indicating whether to scan for negative cycles in the graph.\n     * @param {boolean} [getMin] - The `getMin` parameter is a boolean flag that determines whether the algorithm should\n     * calculate the minimum distance from the source vertex to all other vertices in the graph. If `getMin` is set to\n     * `true`, the algorithm will find the minimum distance and update the `min` variable with the minimum\n     * @param {boolean} [genPath] - A boolean flag indicating whether to generate paths for all vertices from the source\n     * vertex.\n     * @returns The function `bellmanFord` returns an object with the following properties:\n     */\n    bellmanFord(src, scanNegativeCycle, getMin, genPath) {\n        if (getMin === undefined)\n            getMin = false;\n        if (genPath === undefined)\n            genPath = false;\n        const srcVertex = this._getVertex(src);\n        const paths = [];\n        const distMap = new Map();\n        const preMap = new Map(); // predecessor\n        let min = Infinity;\n        let minPath = [];\n        // TODO\n        let hasNegativeCycle;\n        if (scanNegativeCycle)\n            hasNegativeCycle = false;\n        if (!srcVertex)\n            return { hasNegativeCycle, distMap, preMap, paths, min, minPath };\n        const vertices = this._vertices;\n        const numOfVertices = vertices.size;\n        const edges = this.edgeSet();\n        const numOfEdges = edges.length;\n        this._vertices.forEach(vertex => {\n            distMap.set(vertex, Infinity);\n        });\n        distMap.set(srcVertex, 0);\n        for (let i = 1; i < numOfVertices; ++i) {\n            for (let j = 0; j < numOfEdges; ++j) {\n                const ends = this.getEndsOfEdge(edges[j]);\n                if (ends) {\n                    const [s, d] = ends;\n                    const weight = edges[j].weight;\n                    const sWeight = distMap.get(s);\n                    const dWeight = distMap.get(d);\n                    if (sWeight !== undefined && dWeight !== undefined) {\n                        if (distMap.get(s) !== Infinity && sWeight + weight < dWeight) {\n                            distMap.set(d, sWeight + weight);\n                            genPath && preMap.set(d, s);\n                        }\n                    }\n                }\n            }\n        }\n        let minDest = null;\n        if (getMin) {\n            distMap.forEach((d, v) => {\n                if (v !== srcVertex) {\n                    if (d < min) {\n                        min = d;\n                        if (genPath)\n                            minDest = v;\n                    }\n                }\n            });\n        }\n        if (genPath) {\n            for (const vertex of vertices) {\n                const vertexOrKey = vertex[1];\n                if (vertexOrKey instanceof AbstractVertex) {\n                    const path = [vertexOrKey];\n                    let parent = preMap.get(vertexOrKey);\n                    while (parent !== undefined) {\n                        path.push(parent);\n                        parent = preMap.get(parent);\n                    }\n                    const reversed = path.reverse();\n                    if (vertex[1] === minDest)\n                        minPath = reversed;\n                    paths.push(reversed);\n                }\n            }\n        }\n        for (let j = 0; j < numOfEdges; ++j) {\n            const ends = this.getEndsOfEdge(edges[j]);\n            if (ends) {\n                const [s] = ends;\n                const weight = edges[j].weight;\n                const sWeight = distMap.get(s);\n                if (sWeight) {\n                    if (sWeight !== Infinity && sWeight + weight < sWeight)\n                        hasNegativeCycle = true;\n                }\n            }\n        }\n        return { hasNegativeCycle, distMap, preMap, paths, min, minPath };\n    }\n    /**\n     * Dijkstra algorithm time: O(logVE) space: O(V + E)\n     * /\n  \n     /**\n     * Dijkstra algorithm time: O(logVE) space: O(V + E)\n     * Dijkstra's algorithm is used to find the shortest paths from a source node to all other nodes in a graph. Its basic idea is to repeatedly choose the node closest to the source node and update the distances of other nodes using this node as an intermediary. Dijkstra's algorithm requires that the edge weights in the graph are non-negative.\n     */\n    /**\n     * BellmanFord time:O(VE) space:O(V)\n     * one to rest pairs\n     * The Bellman-Ford algorithm is also used to find the shortest paths from a source node to all other nodes in a graph. Unlike Dijkstra's algorithm, it can handle edge weights that are negative. Its basic idea involves iterative relaxation of all edges for several rounds to gradually approximate the shortest paths. Due to its ability to handle negative-weight edges, the Bellman-Ford algorithm is more flexible in some scenarios.\n     * The `bellmanFord` function implements the Bellman-Ford algorithm to find the shortest path from a source vertex to\n     */\n    /**\n     * Floyd algorithm time: O(V^3) space: O(V^2), not support graph with negative weight cycle\n     * all pairs\n     * The Floyd-Warshall algorithm is used to find the shortest paths between all pairs of nodes in a graph. It employs dynamic programming to compute the shortest paths from any node to any other node. The Floyd-Warshall algorithm's advantage lies in its ability to handle graphs with negative-weight edges, and it can simultaneously compute shortest paths between any two nodes.\n     */\n    /**\n     * Floyd algorithm time: O(V^3) space: O(V^2), not support graph with negative weight cycle\n     * all pairs\n     * /\n  \n     /**\n     * Floyd algorithm time: O(V^3) space: O(V^2), not support graph with negative weight cycle\n     * all pairs\n     * The Floyd-Warshall algorithm is used to find the shortest paths between all pairs of nodes in a graph. It employs dynamic programming to compute the shortest paths from any node to any other node. The Floyd-Warshall algorithm's advantage lies in its ability to handle graphs with negative-weight edges, and it can simultaneously compute shortest paths between any two nodes.\n     * The function implements the Floyd-Warshall algorithm to find the shortest path between all pairs of vertices in a\n     * graph.\n     * @returns The function `floyd()` returns an object with two properties: `costs` and `predecessor`. The `costs`\n     * property is a 2D array of numbers representing the shortest path costs between vertices in a graph. The\n     * `predecessor` property is a 2D array of vertices (or `null`) representing the predecessor vertices in the shortest\n     * path between vertices in the\n     */\n    floyd() {\n        var _a;\n        const idAndVertices = [...this._vertices];\n        const n = idAndVertices.length;\n        const costs = [];\n        const predecessor = [];\n        // successors\n        for (let i = 0; i < n; i++) {\n            costs[i] = [];\n            predecessor[i] = [];\n            for (let j = 0; j < n; j++) {\n                predecessor[i][j] = null;\n            }\n        }\n        for (let i = 0; i < n; i++) {\n            for (let j = 0; j < n; j++) {\n                costs[i][j] = ((_a = this.getEdge(idAndVertices[i][1], idAndVertices[j][1])) === null || _a === void 0 ? void 0 : _a.weight) || Infinity;\n            }\n        }\n        for (let k = 0; k < n; k++) {\n            for (let i = 0; i < n; i++) {\n                for (let j = 0; j < n; j++) {\n                    if (costs[i][j] > costs[i][k] + costs[k][j]) {\n                        costs[i][j] = costs[i][k] + costs[k][j];\n                        predecessor[i][j] = idAndVertices[k][1];\n                    }\n                }\n            }\n        }\n        return { costs, predecessor };\n    }\n    /**\n     * Tarjan is an algorithm based on dfs,which is used to solve the connectivity problem of graphs.\n     * Tarjan can find cycles in directed or undirected graph\n     * Tarjan can find the articulation points and bridges(critical edges) of undirected graphs in linear time,\n     * Tarjan solve the bi-connected components of undirected graphs;\n     * Tarjan can find the SSC(strongly connected components), articulation points, and bridges of directed graphs.\n     * /\n  \n     /**\n     * Tarjan is an algorithm based on dfs,which is used to solve the connectivity problem of graphs.\n     * Tarjan can find cycles in directed or undirected graph\n     * Tarjan can find the articulation points and bridges(critical edges) of undirected graphs in linear time,\n     * Tarjan solve the bi-connected components of undirected graphs;\n     * Tarjan can find the SSC(strongly connected components), articulation points, and bridges of directed graphs.\n     * The `tarjan` function is used to perform various graph analysis tasks such as finding articulation points, bridges,\n     * strongly connected components (SCCs), and cycles in a graph.\n     * @param {boolean} [needArticulationPoints] - A boolean value indicating whether or not to calculate and return the\n     * articulation points in the graph. Articulation points are the vertices in a graph whose removal would increase the\n     * number of connected components in the graph.\n     * @param {boolean} [needBridges] - A boolean flag indicating whether the algorithm should find and return the bridges\n     * (edges whose removal would increase the number of connected components in the graph).\n     * @param {boolean} [needSCCs] - A boolean value indicating whether the Strongly Connected Components (SCCs) of the\n     * graph are needed. If set to true, the function will calculate and return the SCCs of the graph. If set to false, the\n     * SCCs will not be calculated or returned.\n     * @param {boolean} [needCycles] - A boolean flag indicating whether the algorithm should find cycles in the graph. If\n     * set to true, the algorithm will return a map of cycles, where the keys are the low values of the SCCs and the values\n     * are arrays of vertices that form cycles within the SCCs.\n     * @returns The function `tarjan` returns an object with the following properties:\n     */\n    tarjan(needArticulationPoints, needBridges, needSCCs, needCycles) {\n        // !! in undirected graph we will not let child visit parent when dfs\n        // !! articulation point(in dfs search tree not in graph): (cur !== root && cur.has(child)) && (low(child) >= dfn(cur)) || (cur === root && cur.children() >= 2)\n        // !! bridge: low(child) > dfn(cur)\n        const defaultConfig = false;\n        if (needArticulationPoints === undefined)\n            needArticulationPoints = defaultConfig;\n        if (needBridges === undefined)\n            needBridges = defaultConfig;\n        if (needSCCs === undefined)\n            needSCCs = defaultConfig;\n        if (needCycles === undefined)\n            needCycles = defaultConfig;\n        const dfnMap = new Map();\n        const lowMap = new Map();\n        const vertices = this._vertices;\n        vertices.forEach(v => {\n            dfnMap.set(v, -1);\n            lowMap.set(v, Infinity);\n        });\n        const [root] = vertices.values();\n        const articulationPoints = [];\n        const bridges = [];\n        let dfn = 0;\n        const dfs = (cur, parent) => {\n            dfn++;\n            dfnMap.set(cur, dfn);\n            lowMap.set(cur, dfn);\n            const neighbors = this.getNeighbors(cur);\n            let childCount = 0; // child in dfs tree not child in graph\n            for (const neighbor of neighbors) {\n                if (neighbor !== parent) {\n                    if (dfnMap.get(neighbor) === -1) {\n                        childCount++;\n                        dfs(neighbor, cur);\n                    }\n                    const childLow = lowMap.get(neighbor);\n                    const curLow = lowMap.get(cur);\n                    // TODO after no-non-null-assertion not ensure the logic\n                    if (curLow !== undefined && childLow !== undefined) {\n                        lowMap.set(cur, Math.min(curLow, childLow));\n                    }\n                    const curFromMap = dfnMap.get(cur);\n                    if (childLow !== undefined && curFromMap !== undefined) {\n                        if (needArticulationPoints) {\n                            if ((cur === root && childCount >= 2) || (cur !== root && childLow >= curFromMap)) {\n                                // todo not ensure the logic if (cur === root && childCount >= 2 || ((cur !== root) && (childLow >= curFromMap))) {\n                                articulationPoints.push(cur);\n                            }\n                        }\n                        if (needBridges) {\n                            if (childLow > curFromMap) {\n                                const edgeCurToNeighbor = this.getEdge(cur, neighbor);\n                                if (edgeCurToNeighbor) {\n                                    bridges.push(edgeCurToNeighbor);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        };\n        dfs(root, null);\n        let SCCs = new Map();\n        const getSCCs = () => {\n            const SCCs = new Map();\n            lowMap.forEach((low, vertex) => {\n                var _a;\n                if (!SCCs.has(low)) {\n                    SCCs.set(low, [vertex]);\n                }\n                else {\n                    (_a = SCCs.get(low)) === null || _a === void 0 ? void 0 : _a.push(vertex);\n                }\n            });\n            return SCCs;\n        };\n        if (needSCCs) {\n            SCCs = getSCCs();\n        }\n        const cycles = new Map();\n        if (needCycles) {\n            let SCCs = new Map();\n            if (SCCs.size < 1) {\n                SCCs = getSCCs();\n            }\n            SCCs.forEach((SCC, low) => {\n                if (SCC.length > 1) {\n                    cycles.set(low, SCC);\n                }\n            });\n        }\n        return { dfnMap, lowMap, bridges, articulationPoints, SCCs, cycles };\n    }\n    _addVertexOnly(newVertex) {\n        if (this.hasVertex(newVertex)) {\n            return false;\n            // throw (new Error('Duplicated vertex key is not allowed'));\n        }\n        this._vertices.set(newVertex.key, newVertex);\n        return true;\n    }\n    _getVertex(vertexOrKey) {\n        const vertexKey = this._getVertexKey(vertexOrKey);\n        return this._vertices.get(vertexKey) || null;\n    }\n    _getVertexKey(vertexOrKey) {\n        return vertexOrKey instanceof AbstractVertex ? vertexOrKey.key : vertexOrKey;\n    }\n    _setVertices(value) {\n        this._vertices = value;\n    }\n}\n","/**\n * data-structure-typed\n *\n * @author Tyler Zeng\n * @copyright Copyright (c) 2022 Tyler Zeng <zrwusa@gmail.com>\n * @license MIT License\n */\nimport { arrayRemove } from '../../utils';\nimport { AbstractEdge, AbstractGraph, AbstractVertex } from './abstract-graph';\nexport class DirectedVertex extends AbstractVertex {\n    /**\n     * The constructor function initializes a vertex with an optional value.\n     * @param {VertexKey} key - The `key` parameter is of type `VertexKey` and represents the identifier of the vertex. It is\n     * used to uniquely identify the vertex within a graph or data structure.\n     * @param {V} [val] - The \"val\" parameter is an optional parameter of type V. It is used to initialize the value of the\n     * vertex. If no value is provided, the vertex will be initialized with a default value.\n     */\n    constructor(key, val) {\n        super(key, val);\n    }\n}\nexport class DirectedEdge extends AbstractEdge {\n    /**\n     * The constructor function initializes the source and destination vertices of an edge, along with an optional weight\n     * and value.\n     * @param {VertexKey} src - The `src` parameter is the source vertex ID. It represents the starting point of an edge in\n     * a graph.\n     * @param {VertexKey} dest - The `dest` parameter represents the destination vertex of an edge. It is of type\n     * `VertexKey`, which is likely a unique identifier for a vertex in a graph.\n     * @param {number} [weight] - The weight parameter is an optional number that represents the weight of the edge.\n     * @param {V} [val] - The `val` parameter is an optional parameter of type `V`. It represents the value associated with\n     * the edge.\n     */\n    constructor(src, dest, weight, val) {\n        super(weight, val);\n        this._src = src;\n        this._dest = dest;\n    }\n    get src() {\n        return this._src;\n    }\n    set src(v) {\n        this._src = v;\n    }\n    get dest() {\n        return this._dest;\n    }\n    set dest(v) {\n        this._dest = v;\n    }\n}\nexport class DirectedGraph extends AbstractGraph {\n    /**\n     * The constructor function initializes an instance of a class.\n     */\n    constructor() {\n        super();\n        this._outEdgeMap = new Map();\n        this._inEdgeMap = new Map();\n    }\n    get outEdgeMap() {\n        return this._outEdgeMap;\n    }\n    get inEdgeMap() {\n        return this._inEdgeMap;\n    }\n    /**\n     * In TypeScript, a subclass inherits the interface implementation of its parent class, without needing to implement the same interface again in the subclass. This behavior differs from Java's approach. In Java, if a parent class implements an interface, the subclass needs to explicitly implement the same interface, even if the parent class has already implemented it.\n     * This means that using abstract methods in the parent class cannot constrain the grandchild classes. Defining methods within an interface also cannot constrain the descendant classes. When inheriting from this class, developers need to be aware that this method needs to be overridden.\n     */\n    /**\n     * The function creates a new vertex with an optional value and returns it.\n     * @param {VertexKey} key - The `key` parameter is the unique identifier for the vertex. It is of type `VertexKey`, which\n     * could be a number or a string depending on how you want to identify your vertices.\n     * @param [val] - The 'val' parameter is an optional value that can be assigned to the vertex. If a value is provided,\n     * it will be assigned to the 'val' property of the vertex. If no value is provided, the 'val' property will be\n     * assigned the same value as the 'key' parameter\n     * @returns a new instance of a DirectedVertex object, casted as type V.\n     */\n    createVertex(key, val) {\n        return new DirectedVertex(key, val !== null && val !== void 0 ? val : key);\n    }\n    /**\n     * In TypeScript, a subclass inherits the interface implementation of its parent class, without needing to implement the same interface again in the subclass. This behavior differs from Java's approach. In Java, if a parent class implements an interface, the subclass needs to explicitly implement the same interface, even if the parent class has already implemented it.\n     * This means that using abstract methods in the parent class cannot constrain the grandchild classes. Defining methods within an interface also cannot constrain the descendant classes. When inheriting from this class, developers need to be aware that this method needs to be overridden.\n     */\n    /**\n     * The function creates a directed edge between two vertices with an optional weight and value.\n     * @param {VertexKey} src - The source vertex ID of the edge. It represents the starting point of the edge.\n     * @param {VertexKey} dest - The `dest` parameter is the identifier of the destination vertex for the edge.\n     * @param {number} [weight] - The weight parameter is an optional number that represents the weight of the edge. If no\n     * weight is provided, it defaults to 1.\n     * @param [val] - The 'val' parameter is an optional value that can be assigned to the edge. It can be of any type and\n     * is used to store additional information or data associated with the edge.\n     * @returns a new instance of a DirectedEdge object, casted as type E.\n     */\n    createEdge(src, dest, weight, val) {\n        return new DirectedEdge(src, dest, weight !== null && weight !== void 0 ? weight : 1, val);\n    }\n    /**\n     * The `getEdge` function retrieves an edge between two vertices based on their source and destination IDs.\n     * @param {V | null | VertexKey} srcOrKey - The source vertex or its ID. It can be either a vertex object or a vertex ID.\n     * @param {V | null | VertexKey} destOrKey - The `destOrKey` parameter in the `getEdge` function represents the\n     * destination vertex of the edge. It can be either a vertex object (`V`), a vertex ID (`VertexKey`), or `null` if the\n     * destination is not specified.\n     * @returns the first edge found between the source and destination vertices, or null if no such edge is found.\n     */\n    getEdge(srcOrKey, destOrKey) {\n        let edges = [];\n        if (srcOrKey !== null && destOrKey !== null) {\n            const src = this._getVertex(srcOrKey);\n            const dest = this._getVertex(destOrKey);\n            if (src && dest) {\n                const srcOutEdges = this._outEdgeMap.get(src);\n                if (srcOutEdges) {\n                    edges = srcOutEdges.filter(edge => edge.dest === dest.key);\n                }\n            }\n        }\n        return edges[0] || null;\n    }\n    /**\n     * The function removes an edge between two vertices in a graph and returns the removed edge.\n     * @param {V | VertexKey} srcOrKey - The source vertex or its ID.\n     * @param {V | VertexKey} destOrKey - The `destOrKey` parameter represents the destination vertex or its ID.\n     * @returns the removed edge (E) if it exists, or null if either the source or destination vertex does not exist.\n     */\n    removeEdgeSrcToDest(srcOrKey, destOrKey) {\n        const src = this._getVertex(srcOrKey);\n        const dest = this._getVertex(destOrKey);\n        let removed = null;\n        if (!src || !dest) {\n            return null;\n        }\n        const srcOutEdges = this._outEdgeMap.get(src);\n        if (srcOutEdges) {\n            arrayRemove(srcOutEdges, (edge) => edge.dest === dest.key);\n        }\n        const destInEdges = this._inEdgeMap.get(dest);\n        if (destInEdges) {\n            removed = arrayRemove(destInEdges, (edge) => edge.src === src.key)[0] || null;\n        }\n        return removed;\n    }\n    /**\n     * The function removes an edge from a graph and returns the removed edge, or null if the edge was not found.\n     * @param {E} edge - The `edge` parameter is an object that represents an edge in a graph. It has two properties: `src`\n     * and `dest`, which represent the source and destination vertices of the edge, respectively.\n     * @returns The method `removeEdge` returns the removed edge (`E`) if it exists, or `null` if the edge does not exist.\n     */\n    removeEdge(edge) {\n        let removed = null;\n        const src = this._getVertex(edge.src);\n        const dest = this._getVertex(edge.dest);\n        if (src && dest) {\n            const srcOutEdges = this._outEdgeMap.get(src);\n            if (srcOutEdges && srcOutEdges.length > 0) {\n                arrayRemove(srcOutEdges, (edge) => edge.src === src.key);\n            }\n            const destInEdges = this._inEdgeMap.get(dest);\n            if (destInEdges && destInEdges.length > 0) {\n                removed = arrayRemove(destInEdges, (edge) => edge.dest === dest.key)[0];\n            }\n        }\n        return removed;\n    }\n    /**\n     * The function removes edges between two vertices and returns the removed edges.\n     * @param {VertexKey | V} v1 - The parameter `v1` can be either a `VertexKey` or a `V`. A `VertexKey` represents the\n     * unique identifier of a vertex in a graph, while `V` represents the actual vertex object.\n     * @param {VertexKey | V} v2 - The parameter `v2` represents either a `VertexKey` or a `V` object. It is used to specify\n     * the second vertex in the edge that needs to be removed.\n     * @returns an array of removed edges (E[]).\n     */\n    removeEdgesBetween(v1, v2) {\n        const removed = [];\n        if (v1 && v2) {\n            const v1ToV2 = this.removeEdgeSrcToDest(v1, v2);\n            const v2ToV1 = this.removeEdgeSrcToDest(v2, v1);\n            v1ToV2 && removed.push(v1ToV2);\n            v2ToV1 && removed.push(v2ToV1);\n        }\n        return removed;\n    }\n    /**\n     * The function `incomingEdgesOf` returns an array of incoming edges for a given vertex or vertex ID.\n     * @param {V | VertexKey} vertexOrKey - The parameter `vertexOrKey` can be either a vertex object (`V`) or a vertex ID\n     * (`VertexKey`).\n     * @returns The method `incomingEdgesOf` returns an array of edges (`E[]`).\n     */\n    incomingEdgesOf(vertexOrKey) {\n        const target = this._getVertex(vertexOrKey);\n        if (target) {\n            return this.inEdgeMap.get(target) || [];\n        }\n        return [];\n    }\n    /**\n     * The function `outgoingEdgesOf` returns an array of outgoing edges from a given vertex or vertex ID.\n     * @param {V | VertexKey} vertexOrKey - The parameter `vertexOrKey` can accept either a vertex object (`V`) or a vertex ID\n     * (`VertexKey`).\n     * @returns The method `outgoingEdgesOf` returns an array of edges (`E[]`).\n     */\n    outgoingEdgesOf(vertexOrKey) {\n        const target = this._getVertex(vertexOrKey);\n        if (target) {\n            return this._outEdgeMap.get(target) || [];\n        }\n        return [];\n    }\n    /**\n     * The function \"degreeOf\" returns the total degree of a vertex, which is the sum of its out-degree and in-degree.\n     * @param {VertexKey | V} vertexOrKey - The parameter `vertexOrKey` can be either a `VertexKey` or a `V`.\n     * @returns The sum of the out-degree and in-degree of the specified vertex or vertex ID.\n     */\n    degreeOf(vertexOrKey) {\n        return this.outDegreeOf(vertexOrKey) + this.inDegreeOf(vertexOrKey);\n    }\n    /**\n     * The function \"inDegreeOf\" returns the number of incoming edges for a given vertex.\n     * @param {VertexKey | V} vertexOrKey - The parameter `vertexOrKey` can be either a `VertexKey` or a `V`.\n     * @returns The number of incoming edges of the specified vertex or vertex ID.\n     */\n    inDegreeOf(vertexOrKey) {\n        return this.incomingEdgesOf(vertexOrKey).length;\n    }\n    /**\n     * The function `outDegreeOf` returns the number of outgoing edges from a given vertex.\n     * @param {VertexKey | V} vertexOrKey - The parameter `vertexOrKey` can be either a `VertexKey` or a `V`.\n     * @returns The number of outgoing edges from the specified vertex or vertex ID.\n     */\n    outDegreeOf(vertexOrKey) {\n        return this.outgoingEdgesOf(vertexOrKey).length;\n    }\n    /**\n     * The function \"edgesOf\" returns an array of both outgoing and incoming edges of a given vertex or vertex ID.\n     * @param {VertexKey | V} vertexOrKey - The parameter `vertexOrKey` can be either a `VertexKey` or a `V`.\n     * @returns The function `edgesOf` returns an array of edges.\n     */\n    edgesOf(vertexOrKey) {\n        return [...this.outgoingEdgesOf(vertexOrKey), ...this.incomingEdgesOf(vertexOrKey)];\n    }\n    /**\n     * The function \"getEdgeSrc\" returns the source vertex of an edge, or null if the edge does not exist.\n     * @param {E} e - The parameter \"e\" is of type E, which represents an edge in a graph.\n     * @returns either a vertex object (V) or null.\n     */\n    getEdgeSrc(e) {\n        return this._getVertex(e.src);\n    }\n    /**\n     * The function \"getEdgeDest\" returns the destination vertex of an edge.\n     * @param {E} e - The parameter \"e\" is of type \"E\", which represents an edge in a graph.\n     * @returns either a vertex object of type V or null.\n     */\n    getEdgeDest(e) {\n        return this._getVertex(e.dest);\n    }\n    /**\n     * The function `getDestinations` returns an array of destination vertices connected to a given vertex.\n     * @param {V | VertexKey | null} vertex - The `vertex` parameter represents the starting vertex from which we want to\n     * find the destinations. It can be either a `V` object, a `VertexKey` value, or `null`.\n     * @returns an array of vertices (V[]).\n     */\n    getDestinations(vertex) {\n        if (vertex === null) {\n            return [];\n        }\n        const destinations = [];\n        const outgoingEdges = this.outgoingEdgesOf(vertex);\n        for (const outEdge of outgoingEdges) {\n            const child = this.getEdgeDest(outEdge);\n            if (child) {\n                destinations.push(child);\n            }\n        }\n        return destinations;\n    }\n    /**\n     * The `topologicalSort` function performs a topological sort on a graph and returns an array of vertices or vertex IDs\n     * in the sorted order, or null if the graph contains a cycle.\n     * @param {'vertex' | 'key'} [propertyName] - The `propertyName` parameter is an optional parameter that specifies the\n     * property to use for sorting the vertices. It can have two possible values: 'vertex' or 'key'. If 'vertex' is\n     * specified, the vertices themselves will be used for sorting. If 'key' is specified, the ids of\n     * @returns an array of vertices or vertex IDs in topological order. If there is a cycle in the graph, it returns null.\n     */\n    topologicalSort(propertyName) {\n        propertyName = propertyName !== null && propertyName !== void 0 ? propertyName : 'key';\n        // When judging whether there is a cycle in the undirected graph, all nodes with degree of **<= 1** are enqueued\n        // When judging whether there is a cycle in the directed graph, all nodes with **in degree = 0** are enqueued\n        const statusMap = new Map();\n        for (const entry of this.vertices) {\n            statusMap.set(entry[1], 0);\n        }\n        let sorted = [];\n        let hasCycle = false;\n        const dfs = (cur) => {\n            statusMap.set(cur, 1);\n            const children = this.getDestinations(cur);\n            for (const child of children) {\n                const childStatus = statusMap.get(child);\n                if (childStatus === 0) {\n                    dfs(child);\n                }\n                else if (childStatus === 1) {\n                    hasCycle = true;\n                }\n            }\n            statusMap.set(cur, 2);\n            sorted.push(cur);\n        };\n        for (const entry of this.vertices) {\n            if (statusMap.get(entry[1]) === 0) {\n                dfs(entry[1]);\n            }\n        }\n        if (hasCycle)\n            return null;\n        if (propertyName === 'key')\n            sorted = sorted.map(vertex => (vertex instanceof DirectedVertex ? vertex.key : vertex));\n        return sorted.reverse();\n    }\n    /**\n     * The `edgeSet` function returns an array of all the edges in the graph.\n     * @returns The `edgeSet()` method returns an array of edges (`E[]`).\n     */\n    edgeSet() {\n        let edges = [];\n        this._outEdgeMap.forEach(outEdges => {\n            edges = [...edges, ...outEdges];\n        });\n        return edges;\n    }\n    /**\n     * The function `getNeighbors` returns an array of neighboring vertices of a given vertex or vertex ID in a graph.\n     * @param {V | VertexKey} vertexOrKey - The parameter `vertexOrKey` can be either a vertex object (`V`) or a vertex ID\n     * (`VertexKey`).\n     * @returns an array of vertices (V[]).\n     */\n    getNeighbors(vertexOrKey) {\n        const neighbors = [];\n        const vertex = this._getVertex(vertexOrKey);\n        if (vertex) {\n            const outEdges = this.outgoingEdgesOf(vertex);\n            for (const outEdge of outEdges) {\n                const neighbor = this._getVertex(outEdge.dest);\n                // TODO after no-non-null-assertion not ensure the logic\n                if (neighbor) {\n                    neighbors.push(neighbor);\n                }\n            }\n        }\n        return neighbors;\n    }\n    /**\n     * The function \"getEndsOfEdge\" returns the source and destination vertices of an edge if it exists in the graph,\n     * otherwise it returns null.\n     * @param {E} edge - The parameter `edge` is of type `E`, which represents an edge in a graph.\n     * @returns The function `getEndsOfEdge` returns an array containing two vertices `[V, V]` if the edge exists in the\n     * graph. If the edge does not exist, it returns `null`.\n     */\n    getEndsOfEdge(edge) {\n        if (!this.hasEdge(edge.src, edge.dest)) {\n            return null;\n        }\n        const v1 = this._getVertex(edge.src);\n        const v2 = this._getVertex(edge.dest);\n        if (v1 && v2) {\n            return [v1, v2];\n        }\n        else {\n            return null;\n        }\n    }\n    /**\n     * The function `_addEdgeOnly` adds an edge to a graph if the source and destination vertices exist.\n     * @param {E} edge - The parameter `edge` is of type `E`, which represents an edge in a graph. It is the edge that\n     * needs to be added to the graph.\n     * @returns a boolean value. It returns true if the edge was successfully added to the graph, and false if either the\n     * source or destination vertex does not exist in the graph.\n     */\n    _addEdgeOnly(edge) {\n        if (!(this.hasVertex(edge.src) && this.hasVertex(edge.dest))) {\n            return false;\n        }\n        const srcVertex = this._getVertex(edge.src);\n        const destVertex = this._getVertex(edge.dest);\n        // TODO after no-non-null-assertion not ensure the logic\n        if (srcVertex && destVertex) {\n            const srcOutEdges = this._outEdgeMap.get(srcVertex);\n            if (srcOutEdges) {\n                srcOutEdges.push(edge);\n            }\n            else {\n                this._outEdgeMap.set(srcVertex, [edge]);\n            }\n            const destInEdges = this._inEdgeMap.get(destVertex);\n            if (destInEdges) {\n                destInEdges.push(edge);\n            }\n            else {\n                this._inEdgeMap.set(destVertex, [edge]);\n            }\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    _setOutEdgeMap(value) {\n        this._outEdgeMap = value;\n    }\n    _setInEdgeMap(value) {\n        this._inEdgeMap = value;\n    }\n}\n","/**\n * data-structure-typed\n *\n * @author Tyler Zeng\n * @copyright Copyright (c) 2022 Tyler Zeng <zrwusa@gmail.com>\n * @license MIT License\n */\nimport { arrayRemove } from '../../utils';\nimport { AbstractEdge, AbstractGraph, AbstractVertex } from './abstract-graph';\nexport class UndirectedVertex extends AbstractVertex {\n    /**\n     * The constructor function initializes a vertex with an optional value.\n     * @param {VertexKey} key - The `key` parameter is of type `VertexKey` and represents the identifier of the vertex. It is\n     * used to uniquely identify the vertex within a graph or network.\n     * @param {V} [val] - The \"val\" parameter is an optional parameter of type V. It is used to initialize the value of the\n     * vertex. If no value is provided, the vertex will be initialized with a default value.\n     */\n    constructor(key, val) {\n        super(key, val);\n    }\n}\nexport class UndirectedEdge extends AbstractEdge {\n    /**\n     * The constructor function creates an instance of a class with two vertex IDs, an optional weight, and an optional\n     * value.\n     * @param {VertexKey} v1 - The first vertex ID of the edge.\n     * @param {VertexKey} v2 - The parameter `v2` is a `VertexKey`, which represents the identifier of the second vertex in a\n     * graph edge.\n     * @param {number} [weight] - The weight parameter is an optional number that represents the weight of the edge.\n     * @param {V} [val] - The \"val\" parameter is an optional parameter of type V. It is used to store a value associated\n     * with the edge.\n     */\n    constructor(v1, v2, weight, val) {\n        super(weight, val);\n        this._vertices = [v1, v2];\n    }\n    get vertices() {\n        return this._vertices;\n    }\n    set vertices(v) {\n        this._vertices = v;\n    }\n}\nexport class UndirectedGraph extends AbstractGraph {\n    /**\n     * The constructor initializes a new Map object to store edges.\n     */\n    constructor() {\n        super();\n        this._edges = new Map();\n    }\n    get edges() {\n        return this._edges;\n    }\n    /**\n     * The function creates a new vertex with an optional value and returns it.\n     * @param {VertexKey} key - The `key` parameter is the unique identifier for the vertex. It is used to distinguish one\n     * vertex from another in the graph.\n     * @param [val] - The `val` parameter is an optional value that can be assigned to the vertex. If a value is provided,\n     * it will be used as the value of the vertex. If no value is provided, the `key` parameter will be used as the value of\n     * the vertex.\n     * @returns The method is returning a new instance of the `UndirectedVertex` class, casted as type `V`.\n     */\n    createVertex(key, val) {\n        return new UndirectedVertex(key, val !== null && val !== void 0 ? val : key);\n    }\n    /**\n     * The function creates an undirected edge between two vertices with an optional weight and value.\n     * @param {VertexKey} v1 - The parameter `v1` represents the first vertex of the edge.\n     * @param {VertexKey} v2 - The parameter `v2` represents the second vertex of the edge.\n     * @param {number} [weight] - The `weight` parameter is an optional number that represents the weight of the edge. If\n     * no weight is provided, it defaults to 1.\n     * @param [val] - The `val` parameter is an optional value that can be assigned to the edge. It can be of any type and\n     * is used to store additional information or data associated with the edge.\n     * @returns a new instance of the `UndirectedEdge` class, which is casted as type `E`.\n     */\n    createEdge(v1, v2, weight, val) {\n        return new UndirectedEdge(v1, v2, weight !== null && weight !== void 0 ? weight : 1, val);\n    }\n    /**\n     * The function `getEdge` returns the first edge that connects two vertices, or null if no such edge exists.\n     * @param {V | null | VertexKey} v1 - The parameter `v1` represents a vertex or vertex ID. It can be of type `V` (vertex\n     * object), `null`, or `VertexKey` (a string or number representing the ID of a vertex).\n     * @param {V | null | VertexKey} v2 - The parameter `v2` represents a vertex or vertex ID. It can be of type `V` (vertex\n     * object), `null`, or `VertexKey` (vertex ID).\n     * @returns an edge (E) or null.\n     */\n    getEdge(v1, v2) {\n        var _a;\n        let edges = [];\n        if (v1 !== null && v2 !== null) {\n            const vertex1 = this._getVertex(v1);\n            const vertex2 = this._getVertex(v2);\n            if (vertex1 && vertex2) {\n                edges = (_a = this._edges.get(vertex1)) === null || _a === void 0 ? void 0 : _a.filter(e => e.vertices.includes(vertex2.key));\n            }\n        }\n        return edges ? edges[0] || null : null;\n    }\n    /**\n     * The function removes an edge between two vertices in a graph and returns the removed edge.\n     * @param {V | VertexKey} v1 - The parameter `v1` represents either a vertex object (`V`) or a vertex ID (`VertexKey`).\n     * @param {V | VertexKey} v2 - V | VertexKey - This parameter can be either a vertex object (V) or a vertex ID\n     * (VertexKey). It represents the second vertex of the edge that needs to be removed.\n     * @returns the removed edge (E) if it exists, or null if either of the vertices (V) does not exist.\n     */\n    removeEdgeBetween(v1, v2) {\n        const vertex1 = this._getVertex(v1);\n        const vertex2 = this._getVertex(v2);\n        if (!vertex1 || !vertex2) {\n            return null;\n        }\n        const v1Edges = this._edges.get(vertex1);\n        let removed = null;\n        if (v1Edges) {\n            removed = arrayRemove(v1Edges, (e) => e.vertices.includes(vertex2.key))[0] || null;\n        }\n        const v2Edges = this._edges.get(vertex2);\n        if (v2Edges) {\n            arrayRemove(v2Edges, (e) => e.vertices.includes(vertex1.key));\n        }\n        return removed;\n    }\n    /**\n     * The removeEdge function removes an edge between two vertices in a graph.\n     * @param {E} edge - The parameter \"edge\" is of type E, which represents an edge in a graph.\n     * @returns The method is returning either the removed edge (of type E) or null if the edge was not found.\n     */\n    removeEdge(edge) {\n        return this.removeEdgeBetween(edge.vertices[0], edge.vertices[1]);\n    }\n    /**\n     * The function `degreeOf` returns the degree of a vertex in a graph, which is the number of edges connected to that\n     * vertex.\n     * @param {VertexKey | V} vertexOrKey - The parameter `vertexOrKey` can be either a `VertexKey` or a `V`.\n     * @returns The function `degreeOf` returns the degree of a vertex in a graph. The degree of a vertex is the number of\n     * edges connected to that vertex.\n     */\n    degreeOf(vertexOrKey) {\n        var _a;\n        const vertex = this._getVertex(vertexOrKey);\n        if (vertex) {\n            return ((_a = this._edges.get(vertex)) === null || _a === void 0 ? void 0 : _a.length) || 0;\n        }\n        else {\n            return 0;\n        }\n    }\n    /**\n     * The function returns the edges of a given vertex or vertex ID.\n     * @param {VertexKey | V} vertexOrKey - The parameter `vertexOrKey` can be either a `VertexKey` or a `V`. A `VertexKey` is a\n     * unique identifier for a vertex in a graph, while `V` represents the type of the vertex.\n     * @returns an array of edges.\n     */\n    edgesOf(vertexOrKey) {\n        const vertex = this._getVertex(vertexOrKey);\n        if (vertex) {\n            return this._edges.get(vertex) || [];\n        }\n        else {\n            return [];\n        }\n    }\n    /**\n     * The function \"edgeSet\" returns an array of unique edges from a set of edges.\n     * @returns The method `edgeSet()` returns an array of type `E[]`.\n     */\n    edgeSet() {\n        const edgeSet = new Set();\n        this._edges.forEach(edges => {\n            edges.forEach(edge => {\n                edgeSet.add(edge);\n            });\n        });\n        return [...edgeSet];\n    }\n    /**\n     * The function \"getNeighbors\" returns an array of neighboring vertices for a given vertex or vertex ID.\n     * @param {V | VertexKey} vertexOrKey - The parameter `vertexOrKey` can be either a vertex object (`V`) or a vertex ID\n     * (`VertexKey`).\n     * @returns an array of vertices (V[]).\n     */\n    getNeighbors(vertexOrKey) {\n        const neighbors = [];\n        const vertex = this._getVertex(vertexOrKey);\n        if (vertex) {\n            const neighborEdges = this.edgesOf(vertex);\n            for (const edge of neighborEdges) {\n                const neighbor = this._getVertex(edge.vertices.filter(e => e !== vertex.key)[0]);\n                if (neighbor) {\n                    neighbors.push(neighbor);\n                }\n            }\n        }\n        return neighbors;\n    }\n    /**\n     * The function \"getEndsOfEdge\" returns the vertices at the ends of an edge if the edge exists in the graph, otherwise\n     * it returns null.\n     * @param {E} edge - The parameter \"edge\" is of type E, which represents an edge in a graph.\n     * @returns The function `getEndsOfEdge` returns an array containing two vertices `[V, V]` if the edge exists in the\n     * graph. If the edge does not exist, it returns `null`.\n     */\n    getEndsOfEdge(edge) {\n        if (!this.hasEdge(edge.vertices[0], edge.vertices[1])) {\n            return null;\n        }\n        const v1 = this._getVertex(edge.vertices[0]);\n        const v2 = this._getVertex(edge.vertices[1]);\n        if (v1 && v2) {\n            return [v1, v2];\n        }\n        else {\n            return null;\n        }\n    }\n    /**\n     * The function adds an edge to the graph by updating the adjacency list with the vertices of the edge.\n     * @param {E} edge - The parameter \"edge\" is of type E, which represents an edge in a graph.\n     * @returns a boolean value.\n     */\n    _addEdgeOnly(edge) {\n        for (const end of edge.vertices) {\n            const endVertex = this._getVertex(end);\n            if (endVertex === null)\n                return false;\n            if (endVertex) {\n                const edges = this._edges.get(endVertex);\n                if (edges) {\n                    edges.push(edge);\n                }\n                else {\n                    this._edges.set(endVertex, [edge]);\n                }\n            }\n        }\n        return true;\n    }\n    /**\n     * The function sets the edges of a graph.\n     * @param v - A map where the keys are of type V and the values are arrays of type E.\n     */\n    _setEdges(v) {\n        this._edges = v;\n    }\n}\n","import { DirectedEdge, DirectedGraph, DirectedVertex } from './directed-graph';\nexport class MapVertex extends DirectedVertex {\n    /**\n     * The constructor function initializes an object with an key, latitude, longitude, and an optional value.\n     * @param {VertexKey} key - The `key` parameter is of type `VertexKey` and represents the identifier of the vertex.\n     * @param {number} lat - The \"lat\" parameter represents the latitude of a vertex. Latitude is a geographic coordinate\n     * that specifies the north-south position of a point on the Earth's surface. It is measured in degrees, with positive\n     * values representing points north of the equator and negative values representing points south of the equator.\n     * @param {number} long - The \"long\" parameter represents the longitude of a location. Longitude is a geographic\n     * coordinate that specifies the east-west position of a point on the Earth's surface. It is measured in degrees, with\n     * values ranging from -180 to 180.\n     * @param {V} [val] - The \"val\" parameter is an optional value of type V. It is not required to be provided when\n     * creating an instance of the class.\n     */\n    constructor(key, lat, long, val) {\n        super(key, val);\n        this._lat = lat;\n        this._long = long;\n    }\n    get lat() {\n        return this._lat;\n    }\n    set lat(value) {\n        this._lat = value;\n    }\n    get long() {\n        return this._long;\n    }\n    set long(value) {\n        this._long = value;\n    }\n}\nexport class MapEdge extends DirectedEdge {\n    /**\n     * The constructor function initializes a new instance of a class with the given source, destination, weight, and\n     * value.\n     * @param {VertexKey} src - The `src` parameter is the source vertex ID. It represents the starting point of an edge in\n     * a graph.\n     * @param {VertexKey} dest - The `dest` parameter is the identifier of the destination vertex for an edge.\n     * @param {number} [weight] - The weight parameter is an optional number that represents the weight of the edge.\n     * @param {V} [val] - The \"val\" parameter is an optional parameter of type V. It is used to store additional\n     * information or data associated with the edge.\n     */\n    constructor(src, dest, weight, val) {\n        super(src, dest, weight, val);\n    }\n}\nexport class MapGraph extends DirectedGraph {\n    /**\n     * The constructor function initializes the origin and bottomRight properties of a MapGraphCoordinate object.\n     * @param {MapGraphCoordinate} origin - The `origin` parameter is a `MapGraphCoordinate` object that represents the\n     * starting point or reference point of the map graph. It defines the coordinates of the top-left corner of the map\n     * graph.\n     * @param {MapGraphCoordinate} [bottomRight] - The `bottomRight` parameter is an optional parameter of type\n     * `MapGraphCoordinate`. It represents the bottom right coordinate of a map graph. If this parameter is not provided,\n     * it will default to `undefined`.\n     */\n    constructor(origin, bottomRight) {\n        super();\n        this._origin = [0, 0];\n        this._origin = origin;\n        this._bottomRight = bottomRight;\n    }\n    get origin() {\n        return this._origin;\n    }\n    set origin(value) {\n        this._origin = value;\n    }\n    get bottomRight() {\n        return this._bottomRight;\n    }\n    set bottomRight(value) {\n        this._bottomRight = value;\n    }\n    /**\n     * The function creates a new vertex with the given key, value, latitude, and longitude.\n     * @param {VertexKey} key - The key parameter is the unique identifier for the vertex. It is of type VertexKey, which could\n     * be a string or a number depending on how you define it in your code.\n     * @param [val] - The `val` parameter is an optional value that can be assigned to the `val` property of the vertex. It\n     * is of type `V['val']`, which means it should be of the same type as the `val` property of the vertex class `V`.\n     * @param {number} lat - The `lat` parameter represents the latitude of the vertex. It is a number that specifies the\n     * position of the vertex on the Earth's surface in the north-south direction.\n     * @param {number} long - The `long` parameter represents the longitude coordinate of the vertex.\n     * @returns The method is returning a new instance of the `MapVertex` class, casted as type `V`.\n     */\n    createVertex(key, val, lat = this.origin[0], long = this.origin[1]) {\n        return new MapVertex(key, lat, long, val);\n    }\n    /**\n     * The function creates a new instance of a MapEdge with the given source, destination, weight, and value.\n     * @param {VertexKey} src - The source vertex ID of the edge. It represents the starting point of the edge.\n     * @param {VertexKey} dest - The `dest` parameter is the identifier of the destination vertex for the edge being\n     * created.\n     * @param {number} [weight] - The `weight` parameter is an optional number that represents the weight of the edge. It\n     * is used to assign a numerical value to the edge, which can be used in algorithms such as shortest path algorithms.\n     * If the weight is not provided, it can be set to a default value or left undefined.\n     * @param [val] - The `val` parameter is an optional value that can be assigned to the edge. It can be of any type,\n     * depending on the specific implementation of the `MapEdge` class.\n     * @returns a new instance of the `MapEdge` class, cast as type `E`.\n     */\n    createEdge(src, dest, weight, val) {\n        return new MapEdge(src, dest, weight, val);\n    }\n}\n","/**\n * Enum representing different loop types.\n *\n * - `iterative`: Indicates the iterative loop type (with loops that use iterations).\n * - `recursive`: Indicates the recursive loop type (with loops that call themselves).\n */\nexport var LoopType;\n(function (LoopType) {\n    LoopType[\"ITERATIVE\"] = \"ITERATIVE\";\n    LoopType[\"RECURSIVE\"] = \"RECURSIVE\";\n})(LoopType || (LoopType = {}));\nexport var FamilyPosition;\n(function (FamilyPosition) {\n    FamilyPosition[\"ROOT\"] = \"ROOT\";\n    FamilyPosition[\"LEFT\"] = \"LEFT\";\n    FamilyPosition[\"RIGHT\"] = \"RIGHT\";\n    FamilyPosition[\"ROOT_LEFT\"] = \"ROOT_LEFT\";\n    FamilyPosition[\"ROOT_RIGHT\"] = \"ROOT_RIGHT\";\n    FamilyPosition[\"ISOLATED\"] = \"ISOLATED\";\n    FamilyPosition[\"MAL_NODE\"] = \"MAL_NODE\";\n})(FamilyPosition || (FamilyPosition = {}));\n","export var CP;\n(function (CP) {\n    CP[\"lt\"] = \"lt\";\n    CP[\"eq\"] = \"eq\";\n    CP[\"gt\"] = \"gt\";\n})(CP || (CP = {}));\n","export var RBColor;\n(function (RBColor) {\n    RBColor[\"RED\"] = \"RED\";\n    RBColor[\"BLACK\"] = \"BLACK\";\n})(RBColor || (RBColor = {}));\n","export var TopologicalProperty;\n(function (TopologicalProperty) {\n    TopologicalProperty[\"VAL\"] = \"VAL\";\n    TopologicalProperty[\"NODE\"] = \"NODE\";\n    TopologicalProperty[\"ID\"] = \"ID\";\n})(TopologicalProperty || (TopologicalProperty = {}));\n","/**\n * data-structure-typed\n *\n * @author Tyler Zeng\n * @copyright Copyright (c) 2022 Tyler Zeng <zrwusa@gmail.com>\n * @license MIT License\n */\nimport { FamilyPosition, LoopType } from '../../types';\nimport { trampoline } from '../../utils';\nexport class BinaryTreeNode {\n    /**\n     * The constructor function initializes a BinaryTreeNode object with a key and an optional value.\n     * @param {BinaryTreeNodeKey} key - The `key` parameter is of type `BinaryTreeNodeKey` and represents the unique identifier\n     * of the binary tree node. It is used to distinguish one node from another in the binary tree.\n     * @param {V} [val] - The \"val\" parameter is an optional parameter of type V. It represents the value that will be\n     * stored in the binary tree node. If no value is provided, it will be set to undefined.\n     */\n    constructor(key, val) {\n        this.key = key;\n        this.val = val;\n    }\n    get left() {\n        return this._left;\n    }\n    set left(v) {\n        if (v) {\n            v.parent = this;\n        }\n        this._left = v;\n    }\n    get right() {\n        return this._right;\n    }\n    set right(v) {\n        if (v) {\n            v.parent = this;\n        }\n        this._right = v;\n    }\n    /**\n     * The function determines the position of a node in a family tree structure.\n     * @returns a value of type `FamilyPosition`.\n     */\n    get familyPosition() {\n        const that = this;\n        if (that.parent) {\n            if (that.parent.left === that) {\n                if (that.left || that.right) {\n                    return FamilyPosition.ROOT_LEFT;\n                }\n                else {\n                    return FamilyPosition.LEFT;\n                }\n            }\n            else if (that.parent.right === that) {\n                if (that.left || that.right) {\n                    return FamilyPosition.ROOT_RIGHT;\n                }\n                else {\n                    return FamilyPosition.RIGHT;\n                }\n            }\n            else {\n                return FamilyPosition.MAL_NODE;\n            }\n        }\n        else {\n            if (that.left || that.right) {\n                return FamilyPosition.ROOT;\n            }\n            else {\n                return FamilyPosition.ISOLATED;\n            }\n        }\n    }\n}\nexport class BinaryTree {\n    /**\n     * This is a constructor function for a binary tree class that takes an optional options parameter.\n     * @param {BinaryTreeOptions} [options] - The `options` parameter is an optional object that can be passed to the\n     * constructor of the `BinaryTree` class. It allows you to customize the behavior of the binary tree by providing\n     * different configuration options.\n     */\n    constructor(options) {\n        // TODO placeholder node may need redesigned\n        this._root = null;\n        this._size = 0;\n        this._loopType = LoopType.ITERATIVE;\n        this.visitedKey = [];\n        this.visitedVal = [];\n        this.visitedNode = [];\n        if (options !== undefined) {\n            const { loopType = LoopType.ITERATIVE } = options;\n            this._loopType = loopType;\n        }\n    }\n    /**\n     * The function creates a new binary tree node with an optional value.\n     * @param {BinaryTreeNodeKey} key - The `key` parameter is the identifier for the binary tree node. It is of type\n     * `BinaryTreeNodeKey`, which represents the unique identifier for each node in the binary tree.\n     * @param [val] - The `val` parameter is an optional value that can be assigned to the node. It represents the value\n     * stored in the node.\n     * @returns a new instance of a BinaryTreeNode with the specified key and value.\n     */\n    createNode(key, val) {\n        return new BinaryTreeNode(key, val);\n    }\n    get root() {\n        return this._root;\n    }\n    get size() {\n        return this._size;\n    }\n    get loopType() {\n        return this._loopType;\n    }\n    /**\n     * The `swapLocation` function swaps the location of two nodes in a binary tree.\n     * @param {N} srcNode - The source node that you want to swap with the destination node.\n     * @param {N} destNode - The `destNode` parameter represents the destination node where the values from `srcNode` will\n     * be swapped to.\n     * @returns The `destNode` is being returned.\n     */\n    swapLocation(srcNode, destNode) {\n        const { key, val } = destNode;\n        const tempNode = this.createNode(key, val);\n        if (tempNode) {\n            destNode.key = srcNode.key;\n            destNode.val = srcNode.val;\n            srcNode.key = tempNode.key;\n            srcNode.val = tempNode.val;\n        }\n        return destNode;\n    }\n    /**\n     * The clear() function resets the root, size, and maxKey properties to their initial values.\n     */\n    clear() {\n        this._root = null;\n        this._size = 0;\n        this._clearResults();\n    }\n    /**\n     * The function checks if the size of an object is equal to zero and returns a boolean value.\n     * @returns A boolean value indicating whether the size of the object is 0 or not.\n     */\n    isEmpty() {\n        return this.size === 0;\n    }\n    /**\n     * When all leaf nodes are null, it will no longer be possible to add new entity nodes to this binary tree.\n     * In this scenario, null nodes serve as \"sentinel nodes,\" \"virtual nodes,\" or \"placeholder nodes.\"\n     */\n    /**\n     * The `add` function adds a new node to a binary tree, either by ID or by creating a new node with a given value.\n     * @param {BinaryTreeNodeKey | N | null} keyOrNode - The `keyOrNode` parameter can be either a `BinaryTreeNodeKey`, which\n     * is a number representing the ID of a binary tree node, or it can be a `N` object, which represents a binary tree\n     * node itself. It can also be `null` if no node is specified.\n     * @param [val] - The `val` parameter is an optional value that can be assigned to the `val` property of the new node\n     * being added to the binary tree.\n     * @returns The function `add` returns either the inserted node (`N`), `null`, or `undefined`.\n     */\n    add(keyOrNode, val) {\n        const _bfs = (root, newNode) => {\n            const queue = [root];\n            while (queue.length > 0) {\n                const cur = queue.shift();\n                if (cur) {\n                    if (newNode && cur.key === newNode.key)\n                        return;\n                    const inserted = this._addTo(newNode, cur);\n                    if (inserted !== undefined)\n                        return inserted;\n                    if (cur.left)\n                        queue.push(cur.left);\n                    if (cur.right)\n                        queue.push(cur.right);\n                }\n                else\n                    return;\n            }\n            return;\n        };\n        let inserted, needInsert;\n        if (keyOrNode === null) {\n            needInsert = null;\n        }\n        else if (typeof keyOrNode === 'number') {\n            needInsert = this.createNode(keyOrNode, val);\n        }\n        else if (keyOrNode instanceof BinaryTreeNode) {\n            needInsert = keyOrNode;\n        }\n        else {\n            return;\n        }\n        const existNode = keyOrNode ? this.get(keyOrNode, 'key') : undefined;\n        if (this.root) {\n            if (existNode) {\n                existNode.val = val;\n                inserted = existNode;\n            }\n            else {\n                inserted = _bfs(this.root, needInsert);\n            }\n        }\n        else {\n            this._setRoot(needInsert);\n            if (needInsert !== null) {\n                this._setSize(1);\n            }\n            else {\n                this._setSize(0);\n            }\n            inserted = this.root;\n        }\n        return inserted;\n    }\n    /**\n     * The `addMany` function takes an array of binary tree node IDs or nodes, and optionally an array of corresponding data\n     * values, and adds them to the binary tree.\n     * @param {(BinaryTreeNodeKey | null)[] | (N | null)[]} keysOrNodes - An array of BinaryTreeNodeKey or BinaryTreeNode\n     * objects, or null values.\n     * @param {N['val'][]} [data] - The `data` parameter is an optional array of values (`N['val'][]`) that corresponds to\n     * the nodes or node IDs being added. It is used to set the value of each node being added. If `data` is not provided,\n     * the value of the nodes will be `undefined`.\n     * @returns The function `addMany` returns an array of `N`, `null`, or `undefined` values.\n     */\n    addMany(keysOrNodes, data) {\n        // TODO not sure addMany not be run multi times\n        const inserted = [];\n        for (let i = 0; i < keysOrNodes.length; i++) {\n            const keyOrNode = keysOrNodes[i];\n            if (keyOrNode instanceof BinaryTreeNode) {\n                inserted.push(this.add(keyOrNode.key, keyOrNode.val));\n                continue;\n            }\n            if (keyOrNode === null) {\n                inserted.push(this.add(null));\n                continue;\n            }\n            const val = data === null || data === void 0 ? void 0 : data[i];\n            inserted.push(this.add(keyOrNode, val));\n        }\n        return inserted;\n    }\n    /**\n     * The `refill` function clears the binary tree and adds multiple nodes with the given IDs or nodes and optional data.\n     * @param {(BinaryTreeNodeKey | N)[]} keysOrNodes - The `keysOrNodes` parameter is an array that can contain either\n     * `BinaryTreeNodeKey` or `N` values.\n     * @param {N[] | Array<N['val']>} [data] - The `data` parameter is an optional array of values that will be assigned to\n     * the nodes being added. If provided, the length of the `data` array should be equal to the length of the `keysOrNodes`\n     * array. Each value in the `data` array will be assigned to the\n     * @returns The method is returning a boolean value.\n     */\n    refill(keysOrNodes, data) {\n        this.clear();\n        return keysOrNodes.length === this.addMany(keysOrNodes, data).length;\n    }\n    /**\n     * The `remove` function in TypeScript is used to delete a node from a binary search tree and returns an array of objects\n     * containing the deleted node and the node that needs to be balanced.\n     * @param {N | BinaryTreeNodeKey} nodeOrKey - The `nodeOrKey` parameter can be either a node object (`N`) or a binary tree\n     * node ID (`BinaryTreeNodeKey`).\n     * @returns The function `remove` returns an array of `BinaryTreeDeletedResult<N>` objects.\n     */\n    remove(nodeOrKey) {\n        const bstDeletedResult = [];\n        if (!this.root)\n            return bstDeletedResult;\n        const curr = typeof nodeOrKey === 'number' ? this.get(nodeOrKey) : nodeOrKey;\n        if (!curr)\n            return bstDeletedResult;\n        const parent = (curr === null || curr === void 0 ? void 0 : curr.parent) ? curr.parent : null;\n        let needBalanced = null, orgCurrent = curr;\n        if (!curr.left) {\n            if (!parent) {\n                if (curr.right !== undefined)\n                    this._setRoot(curr.right);\n            }\n            else {\n                const { familyPosition: fp } = curr;\n                if (fp === FamilyPosition.LEFT || fp === FamilyPosition.ROOT_LEFT) {\n                    parent.left = curr.right;\n                }\n                else if (fp === FamilyPosition.RIGHT || fp === FamilyPosition.ROOT_RIGHT) {\n                    parent.right = curr.right;\n                }\n                needBalanced = parent;\n            }\n        }\n        else {\n            const leftSubTreeRightMost = curr.left ? this.getRightMost(curr.left) : null;\n            if (leftSubTreeRightMost) {\n                const parentOfLeftSubTreeMax = leftSubTreeRightMost.parent;\n                orgCurrent = this.swapLocation(curr, leftSubTreeRightMost);\n                if (parentOfLeftSubTreeMax) {\n                    if (parentOfLeftSubTreeMax.right === leftSubTreeRightMost)\n                        parentOfLeftSubTreeMax.right = leftSubTreeRightMost.left;\n                    else\n                        parentOfLeftSubTreeMax.left = leftSubTreeRightMost.left;\n                    needBalanced = parentOfLeftSubTreeMax;\n                }\n            }\n        }\n        this._setSize(this.size - 1);\n        bstDeletedResult.push({ deleted: orgCurrent, needBalanced });\n        return bstDeletedResult;\n    }\n    /**\n     * The function calculates the depth of a node in a binary tree.\n     * @param {N | BinaryTreeNodeKey | null} distNode - The `distNode` parameter can be any node of the tree\n     * @param {N | BinaryTreeNodeKey | null} beginRoot - The `beginRoot` parameter can be the predecessor node of distNode\n     * @returns the depth of the given node or binary tree.\n     */\n    getDepth(distNode, beginRoot = this.root) {\n        if (typeof distNode === 'number')\n            distNode = this.get(distNode, 'key');\n        if (typeof beginRoot === 'number')\n            beginRoot = this.get(beginRoot, 'key');\n        let depth = 0;\n        while (distNode === null || distNode === void 0 ? void 0 : distNode.parent) {\n            if (distNode === beginRoot) {\n                return depth;\n            }\n            depth++;\n            distNode = distNode.parent;\n        }\n        return depth;\n    }\n    /**\n     * The `getHeight` function calculates the maximum height of a binary tree, either recursively or iteratively.\n     * @param {N | BinaryTreeNodeKey | null} [beginRoot] - The `beginRoot` parameter is optional and can be of type `N` (a\n     * generic type representing a node in a binary tree), `BinaryTreeNodeKey` (a type representing the ID of a binary tree\n     * node), or `null`.\n     * @returns the height of the binary tree.\n     */\n    getHeight(beginRoot = this.root) {\n        if (typeof beginRoot === 'number')\n            beginRoot = this.get(beginRoot, 'key');\n        if (!beginRoot)\n            return -1;\n        if (this._loopType === LoopType.RECURSIVE) {\n            const _getMaxHeight = (cur) => {\n                if (!cur)\n                    return -1;\n                const leftHeight = _getMaxHeight(cur.left);\n                const rightHeight = _getMaxHeight(cur.right);\n                return Math.max(leftHeight, rightHeight) + 1;\n            };\n            return _getMaxHeight(beginRoot);\n        }\n        else {\n            if (!beginRoot) {\n                return -1;\n            }\n            const stack = [{ node: beginRoot, depth: 0 }];\n            let maxHeight = 0;\n            while (stack.length > 0) {\n                const { node, depth } = stack.pop();\n                if (node.left) {\n                    stack.push({ node: node.left, depth: depth + 1 });\n                }\n                if (node.right) {\n                    stack.push({ node: node.right, depth: depth + 1 });\n                }\n                maxHeight = Math.max(maxHeight, depth);\n            }\n            return maxHeight;\n        }\n    }\n    /**\n     * The `getMinHeight` function calculates the minimum height of a binary tree using either a recursive or iterative\n     * approach.\n     * @param {N | null} [beginRoot] - The `beginRoot` parameter is an optional parameter of type `N` or `null`. It\n     * represents the starting node from which to calculate the minimum height of a binary tree. If no value is provided\n     * for `beginRoot`, the `this.root` property is used as the default value.\n     * @returns The function `getMinHeight` returns the minimum height of the binary tree.\n     */\n    getMinHeight(beginRoot = this.root) {\n        var _a, _b, _c;\n        if (!beginRoot)\n            return -1;\n        if (this._loopType === LoopType.RECURSIVE) {\n            const _getMinHeight = (cur) => {\n                if (!cur)\n                    return 0;\n                if (!cur.left && !cur.right)\n                    return 0;\n                const leftMinHeight = _getMinHeight(cur.left);\n                const rightMinHeight = _getMinHeight(cur.right);\n                return Math.min(leftMinHeight, rightMinHeight) + 1;\n            };\n            return _getMinHeight(beginRoot);\n        }\n        else {\n            const stack = [];\n            let node = beginRoot, last = null;\n            const depths = new Map();\n            while (stack.length > 0 || node) {\n                if (node) {\n                    stack.push(node);\n                    node = node.left;\n                }\n                else {\n                    node = stack[stack.length - 1];\n                    if (!node.right || last === node.right) {\n                        node = stack.pop();\n                        if (node) {\n                            const leftMinHeight = node.left ? (_a = depths.get(node.left)) !== null && _a !== void 0 ? _a : -1 : -1;\n                            const rightMinHeight = node.right ? (_b = depths.get(node.right)) !== null && _b !== void 0 ? _b : -1 : -1;\n                            depths.set(node, 1 + Math.min(leftMinHeight, rightMinHeight));\n                            last = node;\n                            node = null;\n                        }\n                    }\n                    else\n                        node = node.right;\n                }\n            }\n            return (_c = depths.get(beginRoot)) !== null && _c !== void 0 ? _c : -1;\n        }\n    }\n    /**\n     * The function checks if a binary tree is perfectly balanced by comparing the minimum height and the height of the\n     * tree.\n     * @param {N | null} [beginRoot] - The parameter `beginRoot` is of type `N` or `null`. It represents the root node of a\n     * tree or null if the tree is empty.\n     * @returns The method is returning a boolean value.\n     */\n    isPerfectlyBalanced(beginRoot = this.root) {\n        return this.getMinHeight(beginRoot) + 1 >= this.getHeight(beginRoot);\n    }\n    /**\n     * The function `getNodes` returns an array of nodes that match a given property name and value in a binary tree.\n     * @param {BinaryTreeNodeKey | N} nodeProperty - The `nodeProperty` parameter can be either a `BinaryTreeNodeKey` or a\n     * generic type `N`. It represents the property of the binary tree node that you want to search for.\n     * @param {BinaryTreeNodePropertyName} [propertyName] - The `propertyName` parameter is an optional parameter that\n     * specifies the property name to use when searching for nodes. If not provided, it defaults to 'key'.\n     * @param {boolean} [onlyOne] - The `onlyOne` parameter is an optional boolean parameter that determines whether to\n     * return only one node that matches the given `nodeProperty` or `propertyName`. If `onlyOne` is set to `true`, the\n     * function will stop traversing the tree and return the first matching node. If `only\n     * @returns an array of nodes (type N).\n     */\n    getNodes(nodeProperty, propertyName = 'key', onlyOne = false) {\n        if (!this.root)\n            return [];\n        const result = [];\n        if (this.loopType === LoopType.RECURSIVE) {\n            const _traverse = (cur) => {\n                if (this._pushByPropertyNameStopOrNot(cur, result, nodeProperty, propertyName, onlyOne))\n                    return;\n                if (!cur.left && !cur.right)\n                    return;\n                cur.left && _traverse(cur.left);\n                cur.right && _traverse(cur.right);\n            };\n            _traverse(this.root);\n        }\n        else {\n            const queue = [this.root];\n            while (queue.length > 0) {\n                const cur = queue.shift();\n                if (cur) {\n                    if (this._pushByPropertyNameStopOrNot(cur, result, nodeProperty, propertyName, onlyOne))\n                        return result;\n                    cur.left && queue.push(cur.left);\n                    cur.right && queue.push(cur.right);\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * The function checks if a binary tree node has a specific property.\n     * @param {BinaryTreeNodeKey | N} nodeProperty - The `nodeProperty` parameter can be either a `BinaryTreeNodeKey` or `N`.\n     * It represents the property of the binary tree node that you want to check.\n     * @param {BinaryTreeNodePropertyName} [propertyName] - The `propertyName` parameter is an optional parameter that\n     * specifies the name of the property to be checked in the nodes. If not provided, it defaults to 'key'.\n     * @returns a boolean value.\n     */\n    has(nodeProperty, propertyName = 'key') {\n        // TODO may support finding node by value equal\n        return this.getNodes(nodeProperty, propertyName).length > 0;\n    }\n    /**\n     * The function returns the first node that matches the given property name and value, or null if no matching node is\n     * found.\n     * @param {BinaryTreeNodeKey | N} nodeProperty - The `nodeProperty` parameter can be either a `BinaryTreeNodeKey` or `N`.\n     * It represents the property of the binary tree node that you want to search for.\n     * @param {BinaryTreeNodePropertyName} [propertyName] - The `propertyName` parameter is an optional parameter that\n     * specifies the property name to be used for searching the binary tree nodes. If this parameter is not provided, the\n     * default value is set to `'key'`.\n     * @returns either the value of the specified property of the node, or the node itself if no property name is provided.\n     * If no matching node is found, it returns null.\n     */\n    get(nodeProperty, propertyName = 'key') {\n        var _a;\n        // TODO may support finding node by value equal\n        return (_a = this.getNodes(nodeProperty, propertyName, true)[0]) !== null && _a !== void 0 ? _a : null;\n    }\n    /**\n     * The function `getPathToRoot` returns an array of nodes representing the path from a given node to the root node, with\n     * an option to reverse the order of the nodes.\n     * @param {N} node - The `node` parameter represents a node in a tree structure. It is of type `N`, which could be any\n     * type that represents a node in your specific implementation.\n     * @param {boolean} [isReverse=true] - The `isReverse` parameter is a boolean flag that determines whether the resulting\n     * path should be reversed or not. If `isReverse` is set to `true`, the path will be reversed before returning it. If\n     * `isReverse` is set to `false` or not provided, the path will\n     * @returns The function `getPathToRoot` returns an array of nodes (`N[]`).\n     */\n    getPathToRoot(node, isReverse = true) {\n        // TODO to support get path through passing key\n        const result = [];\n        while (node.parent) {\n            // Array.push + Array.reverse is more efficient than Array.unshift\n            // TODO may consider using Deque, so far this is not the performance bottleneck\n            result.push(node);\n            node = node.parent;\n        }\n        result.push(node);\n        return isReverse ? result.reverse() : result;\n    }\n    /**\n     * The function `getLeftMost` returns the leftmost node in a binary tree, starting from a specified node or the root if\n     * no node is specified.\n     * @param {N | BinaryTreeNodeKey | null} [beginRoot] - The `beginRoot` parameter is optional and can be of type `N` (a\n     * generic type representing a node in a binary tree), `BinaryTreeNodeKey` (a type representing the ID of a binary tree\n     * node), or `null`.\n     * @returns The function `getLeftMost` returns the leftmost node in a binary tree. If the `beginRoot` parameter is\n     * provided, it starts the traversal from that node. If `beginRoot` is not provided or is `null`, it starts the traversal\n     * from the root of the binary tree. The function returns the leftmost node found during the traversal. If no leftmost\n     * node is found (\n     */\n    getLeftMost(beginRoot = this.root) {\n        if (typeof beginRoot === 'number')\n            beginRoot = this.get(beginRoot, 'key');\n        if (!beginRoot)\n            return beginRoot;\n        if (this._loopType === LoopType.RECURSIVE) {\n            const _traverse = (cur) => {\n                if (!cur.left)\n                    return cur;\n                return _traverse(cur.left);\n            };\n            return _traverse(beginRoot);\n        }\n        else {\n            // Indirect implementation of iteration using tail recursion optimization\n            const _traverse = trampoline((cur) => {\n                if (!cur.left)\n                    return cur;\n                return _traverse.cont(cur.left);\n            });\n            return _traverse(beginRoot);\n        }\n    }\n    /**\n     * The `getRightMost` function returns the rightmost node in a binary tree, either recursively or iteratively using tail\n     * recursion optimization.\n     * @param {N | null} [beginRoot] - The `node` parameter is an optional parameter of type `N` or `null`. It represents the\n     * starting node from which we want to find the rightmost node. If no node is provided, the function will default to\n     * using the root node of the data structure.\n     * @returns The `getRightMost` function returns the rightmost node in a binary tree. If the `node` parameter is provided,\n     * it returns the rightmost node starting from that node. If the `node` parameter is not provided, it returns the\n     * rightmost node starting from the root of the binary tree.\n     */\n    getRightMost(beginRoot = this.root) {\n        // TODO support get right most by passing key in\n        if (!beginRoot)\n            return beginRoot;\n        if (this._loopType === LoopType.RECURSIVE) {\n            const _traverse = (cur) => {\n                if (!cur.right)\n                    return cur;\n                return _traverse(cur.right);\n            };\n            return _traverse(beginRoot);\n        }\n        else {\n            // Indirect implementation of iteration using tail recursion optimization\n            const _traverse = trampoline((cur) => {\n                if (!cur.right)\n                    return cur;\n                return _traverse.cont(cur.right);\n            });\n            return _traverse(beginRoot);\n        }\n    }\n    /**\n     * The function checks if a binary search tree is valid by traversing it either recursively or iteratively.\n     * @param {N | null} node - The `node` parameter represents the root node of a binary search tree (BST).\n     * @returns a boolean value.\n     */\n    isSubtreeBST(node) {\n        // TODO there is a bug\n        if (!node)\n            return true;\n        if (this._loopType === LoopType.RECURSIVE) {\n            const dfs = (cur, min, max) => {\n                if (!cur)\n                    return true;\n                if (cur.key <= min || cur.key >= max)\n                    return false;\n                return dfs(cur.left, min, cur.key) && dfs(cur.right, cur.key, max);\n            };\n            return dfs(node, Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);\n        }\n        else {\n            const stack = [];\n            let prev = Number.MIN_SAFE_INTEGER, curr = node;\n            while (curr || stack.length > 0) {\n                while (curr) {\n                    stack.push(curr);\n                    curr = curr.left;\n                }\n                curr = stack.pop();\n                if (!curr || prev >= curr.key)\n                    return false;\n                prev = curr.key;\n                curr = curr.right;\n            }\n            return true;\n        }\n    }\n    /**\n     * The function isBST checks if the binary tree is valid binary search tree.\n     * @returns The `isBST()` function is returning a boolean value.\n     */\n    isBST() {\n        return this.isSubtreeBST(this.root);\n    }\n    /**\n     * The function calculates the size of a subtree by traversing it either recursively or iteratively.\n     * @param {N | null | undefined} subTreeRoot - The `subTreeRoot` parameter represents the root node of a subtree in a\n     * binary tree.\n     * @returns the size of the subtree rooted at `subTreeRoot`.\n     */\n    getSubTreeSize(subTreeRoot) {\n        // TODO support key passed in\n        let size = 0;\n        if (!subTreeRoot)\n            return size;\n        if (this._loopType === LoopType.RECURSIVE) {\n            const _traverse = (cur) => {\n                size++;\n                cur.left && _traverse(cur.left);\n                cur.right && _traverse(cur.right);\n            };\n            _traverse(subTreeRoot);\n            return size;\n        }\n        else {\n            const stack = [subTreeRoot];\n            while (stack.length > 0) {\n                const cur = stack.pop();\n                size++;\n                cur.right && stack.push(cur.right);\n                cur.left && stack.push(cur.left);\n            }\n            return size;\n        }\n    }\n    /**\n     * The function `subTreeSum` calculates the sum of a specified property in a binary tree or subtree.\n     * @param {N | BinaryTreeNodeKey | null} subTreeRoot - The `subTreeRoot` parameter represents the root node of a binary\n     * tree or the ID of a binary tree node. It can also be `null` if there is no subtree.\n     * @param {BinaryTreeNodePropertyName} [propertyName] - propertyName is an optional parameter that specifies the\n     * property of the binary tree node to use for calculating the sum. It can be either 'key' or 'val'. If propertyName is\n     * not provided, it defaults to 'key'.\n     * @returns a number, which is the sum of the values of the specified property in the subtree rooted at `subTreeRoot`.\n     */\n    subTreeSum(subTreeRoot, propertyName = 'key') {\n        if (typeof subTreeRoot === 'number')\n            subTreeRoot = this.get(subTreeRoot, 'key');\n        if (!subTreeRoot)\n            return 0;\n        let sum = 0;\n        const _sumByProperty = (cur) => {\n            let needSum;\n            switch (propertyName) {\n                case 'key':\n                    needSum = cur.key;\n                    break;\n                case 'val':\n                    needSum = typeof cur.val === 'number' ? cur.val : 0;\n                    break;\n                default:\n                    needSum = cur.key;\n                    break;\n            }\n            return needSum;\n        };\n        if (this._loopType === LoopType.RECURSIVE) {\n            const _traverse = (cur) => {\n                sum += _sumByProperty(cur);\n                cur.left && _traverse(cur.left);\n                cur.right && _traverse(cur.right);\n            };\n            _traverse(subTreeRoot);\n        }\n        else {\n            const stack = [subTreeRoot];\n            while (stack.length > 0) {\n                const cur = stack.pop();\n                sum += _sumByProperty(cur);\n                cur.right && stack.push(cur.right);\n                cur.left && stack.push(cur.left);\n            }\n        }\n        return sum;\n    }\n    /**\n     * The function `subTreeAdd` adds a delta value to a specified property of each node in a subtree.\n     * @param {N | BinaryTreeNodeKey | null} subTreeRoot - The `subTreeRoot` parameter represents the root node of a binary\n     * tree or the ID of a node in the binary tree. It can also be `null` if there is no subtree to add to.\n     * @param {number} delta - The `delta` parameter is a number that represents the amount by which the property value of\n     * each node in the subtree should be incremented.\n     * @param {BinaryTreeNodePropertyName} [propertyName] - The `propertyName` parameter is an optional parameter that\n     * specifies the property of the binary tree node that should be modified. If not provided, it defaults to 'key'.\n     * @returns a boolean value.\n     */\n    subTreeAdd(subTreeRoot, delta, propertyName = 'key') {\n        if (typeof subTreeRoot === 'number')\n            subTreeRoot = this.get(subTreeRoot, 'key');\n        if (!subTreeRoot)\n            return false;\n        const _addByProperty = (cur) => {\n            switch (propertyName) {\n                case 'key':\n                    cur.key += delta;\n                    break;\n                default:\n                    cur.key += delta;\n                    break;\n            }\n        };\n        if (this._loopType === LoopType.RECURSIVE) {\n            const _traverse = (cur) => {\n                _addByProperty(cur);\n                cur.left && _traverse(cur.left);\n                cur.right && _traverse(cur.right);\n            };\n            _traverse(subTreeRoot);\n        }\n        else {\n            const stack = [subTreeRoot];\n            while (stack.length > 0) {\n                const cur = stack.pop();\n                _addByProperty(cur);\n                cur.right && stack.push(cur.right);\n                cur.left && stack.push(cur.left);\n            }\n        }\n        return true;\n    }\n    /**\n     * The bfs function performs a breadth-first search on a binary tree, accumulating properties of each node based on a specified property name.\n     * @param {NodeOrPropertyName} [nodeOrPropertyName] - An optional parameter that represents either a node or a property name.\n     * If a node is provided, the bfs algorithm will be performed starting from that node.\n     * If a property name is provided, the bfs algorithm will be performed starting from the root node, accumulating the specified property.\n     * @returns An instance of the `BinaryTreeNodeProperties` class with generic type `N`.\n     */\n    bfs(nodeOrPropertyName = 'key') {\n        this._clearResults();\n        const queue = [this.root];\n        while (queue.length !== 0) {\n            const cur = queue.shift();\n            if (cur) {\n                this._accumulatedByPropertyName(cur, nodeOrPropertyName);\n                if ((cur === null || cur === void 0 ? void 0 : cur.left) !== null)\n                    queue.push(cur.left);\n                if ((cur === null || cur === void 0 ? void 0 : cur.right) !== null)\n                    queue.push(cur.right);\n            }\n        }\n        return this._getResultByPropertyName(nodeOrPropertyName);\n    }\n    /**\n     * The dfs function performs a depth-first search traversal on a binary tree and returns the accumulated properties of\n     * each node based on the specified pattern and property name.\n     * @param {'in' | 'pre' | 'post'} [pattern] - The traversal pattern: 'in' (in-order), 'pre' (pre-order), or 'post' (post-order).\n     * @param {NodeOrPropertyName} [nodeOrPropertyName] - The name of a property of the nodes in the binary tree. This property will be used to accumulate values during the depth-first search traversal. If no `nodeOrPropertyName` is provided, the default value is `'key'`.\n     * @returns an instance of the BinaryTreeNodeProperties class, which contains the accumulated properties of the binary tree nodes based on the specified pattern and node or property name.\n     */\n    dfs(pattern = 'in', nodeOrPropertyName = 'key') {\n        this._clearResults();\n        const _traverse = (node) => {\n            switch (pattern) {\n                case 'in':\n                    if (node.left)\n                        _traverse(node.left);\n                    this._accumulatedByPropertyName(node, nodeOrPropertyName);\n                    if (node.right)\n                        _traverse(node.right);\n                    break;\n                case 'pre':\n                    this._accumulatedByPropertyName(node, nodeOrPropertyName);\n                    if (node.left)\n                        _traverse(node.left);\n                    if (node.right)\n                        _traverse(node.right);\n                    break;\n                case 'post':\n                    if (node.left)\n                        _traverse(node.left);\n                    if (node.right)\n                        _traverse(node.right);\n                    this._accumulatedByPropertyName(node, nodeOrPropertyName);\n                    break;\n            }\n        };\n        this.root && _traverse(this.root);\n        return this._getResultByPropertyName(nodeOrPropertyName);\n    }\n    /**\n     * The dfsIterative function performs an iterative depth-first search traversal on a binary tree, with the option to\n     * specify the traversal pattern and the property name to accumulate results by.\n     * @param {'in' | 'pre' | 'post'} [pattern] - The traversal pattern: 'in' (in-order), 'pre' (pre-order), or 'post' (post-order).\n     * @param {NodeOrPropertyName} [nodeOrPropertyName] - The name of a property of the nodes in the binary tree. This property will be used to accumulate values during the depth-first search traversal. By default, it is set to `'key'`.\n     * @returns An object of type BinaryTreeNodeProperties<N>.\n     */\n    dfsIterative(pattern = 'in', nodeOrPropertyName = 'key') {\n        this._clearResults();\n        if (!this.root)\n            return this._getResultByPropertyName(nodeOrPropertyName);\n        // 0: visit, 1: print\n        const stack = [{ opt: 0, node: this.root }];\n        while (stack.length > 0) {\n            const cur = stack.pop();\n            if (!cur || !cur.node)\n                continue;\n            if (cur.opt === 1) {\n                this._accumulatedByPropertyName(cur.node, nodeOrPropertyName);\n            }\n            else {\n                switch (pattern) {\n                    case 'in':\n                        stack.push({ opt: 0, node: cur.node.right });\n                        stack.push({ opt: 1, node: cur.node });\n                        stack.push({ opt: 0, node: cur.node.left });\n                        break;\n                    case 'pre':\n                        stack.push({ opt: 0, node: cur.node.right });\n                        stack.push({ opt: 0, node: cur.node.left });\n                        stack.push({ opt: 1, node: cur.node });\n                        break;\n                    case 'post':\n                        stack.push({ opt: 1, node: cur.node });\n                        stack.push({ opt: 0, node: cur.node.right });\n                        stack.push({ opt: 0, node: cur.node.left });\n                        break;\n                    default:\n                        stack.push({ opt: 0, node: cur.node.right });\n                        stack.push({ opt: 1, node: cur.node });\n                        stack.push({ opt: 0, node: cur.node.left });\n                        break;\n                }\n            }\n        }\n        return this._getResultByPropertyName(nodeOrPropertyName);\n    }\n    /**\n     * The `levelIterative` function performs a level-order traversal on a binary tree and returns the values of the nodes\n     * in an array, based on a specified property name.\n     * @param {N | null} node - The `node` parameter is a BinaryTreeNode object representing the starting\n     * node for the level order traversal. It can be null if no specific node is provided, in which case the root node of\n     * the tree is used as the starting node.\n     * @param {NodeOrPropertyName} [nodeOrPropertyName] - The `nodeOrPropertyName` parameter is an optional parameter that\n     * can be either a `BinaryTreeNode` property name or the string `'key'`. If a property name is provided, the function\n     * will accumulate results based on that property. If no property name is provided, the function will default to\n     * accumulating results based on the 'key' property.\n     * @returns An object of type `BinaryTreeNodeProperties<N>`.\n     */\n    levelIterative(node = this.root, nodeOrPropertyName = 'key') {\n        if (!node)\n            return [];\n        this._clearResults();\n        const queue = [node];\n        while (queue.length > 0) {\n            const cur = queue.shift();\n            if (cur) {\n                this._accumulatedByPropertyName(cur, nodeOrPropertyName);\n                if (cur.left) {\n                    queue.push(cur.left);\n                }\n                if (cur.right) {\n                    queue.push(cur.right);\n                }\n            }\n        }\n        return this._getResultByPropertyName(nodeOrPropertyName);\n    }\n    /**\n     * The `listLevels` function collects nodes from a binary tree by a specified property and organizes them into levels.\n     * @param {N | null} node - The `node` parameter is a BinaryTreeNode object or null. It represents the root node of a binary tree. If it is null, the function will use the root node of the current binary tree instance.\n     * @param {NodeOrPropertyName} [nodeOrPropertyName] - The `nodeOrPropertyName` parameter is an optional parameter that specifies the property of the `BinaryTreeNode` object to collect at each level. It can be one of the following values: 'key', 'val', or 'node'. If not provided, it defaults to 'key'.\n     * @returns A 2D array of `AbstractBinaryTreeNodeProperty<N>` objects.\n     */\n    listLevels(node = this.root, nodeOrPropertyName = 'key') {\n        if (!node)\n            return [];\n        const levelsNodes = [];\n        const collectByProperty = (node, level) => {\n            switch (nodeOrPropertyName) {\n                case 'key':\n                    levelsNodes[level].push(node.key);\n                    break;\n                case 'val':\n                    levelsNodes[level].push(node.val);\n                    break;\n                case 'node':\n                    levelsNodes[level].push(node);\n                    break;\n                default:\n                    levelsNodes[level].push(node.key);\n                    break;\n            }\n        };\n        if (this.loopType === LoopType.RECURSIVE) {\n            const _recursive = (node, level) => {\n                if (!levelsNodes[level])\n                    levelsNodes[level] = [];\n                collectByProperty(node, level);\n                if (node.left)\n                    _recursive(node.left, level + 1);\n                if (node.right)\n                    _recursive(node.right, level + 1);\n            };\n            _recursive(node, 0);\n        }\n        else {\n            const stack = [[node, 0]];\n            while (stack.length > 0) {\n                const head = stack.pop();\n                const [node, level] = head;\n                if (!levelsNodes[level])\n                    levelsNodes[level] = [];\n                collectByProperty(node, level);\n                if (node.right)\n                    stack.push([node.right, level + 1]);\n                if (node.left)\n                    stack.push([node.left, level + 1]);\n            }\n        }\n        return levelsNodes;\n    }\n    /**\n     * The function returns the predecessor of a given node in a binary tree.\n     * @param node - The parameter `node` is a BinaryTreeNode object, representing a node in a binary tree.\n     * @returns the predecessor of the given node in a binary tree.\n     */\n    getPredecessor(node) {\n        if (node.left) {\n            let predecessor = node.left;\n            while (!predecessor || (predecessor.right && predecessor.right !== node)) {\n                if (predecessor) {\n                    predecessor = predecessor.right;\n                }\n            }\n            return predecessor;\n        }\n        else {\n            return node;\n        }\n    }\n    /**\n     * The `morris` function performs an in-order, pre-order, or post-order traversal on a binary tree using the Morris traversal algorithm.\n     * @param {'in' | 'pre' | 'post'} [pattern] - The traversal pattern: 'in' (in-order), 'pre' (pre-order), or 'post' (post-order).\n     * @param {NodeOrPropertyName} [nodeOrPropertyName] - The property name of the nodes to retrieve or perform operations on during the traversal. It can be any valid property name of the nodes in the binary tree. If not provided, it defaults to 'key'.\n     * @returns An array of BinaryTreeNodeProperties<N> objects.\n     */\n    morris(pattern = 'in', nodeOrPropertyName = 'key') {\n        if (this.root === null)\n            return [];\n        this._clearResults();\n        let cur = this.root;\n        const _reverseEdge = (node) => {\n            let pre = null;\n            let next = null;\n            while (node) {\n                next = node.right;\n                node.right = pre;\n                pre = node;\n                node = next;\n            }\n            return pre;\n        };\n        const _printEdge = (node) => {\n            const tail = _reverseEdge(node);\n            let cur = tail;\n            while (cur) {\n                this._accumulatedByPropertyName(cur, nodeOrPropertyName);\n                cur = cur.right;\n            }\n            _reverseEdge(tail);\n        };\n        switch (pattern) {\n            case 'in':\n                while (cur) {\n                    if (cur.left) {\n                        const predecessor = this.getPredecessor(cur);\n                        if (!predecessor.right) {\n                            predecessor.right = cur;\n                            cur = cur.left;\n                            continue;\n                        }\n                        else {\n                            predecessor.right = null;\n                        }\n                    }\n                    this._accumulatedByPropertyName(cur, nodeOrPropertyName);\n                    cur = cur.right;\n                }\n                break;\n            case 'pre':\n                while (cur) {\n                    if (cur.left) {\n                        const predecessor = this.getPredecessor(cur);\n                        if (!predecessor.right) {\n                            predecessor.right = cur;\n                            this._accumulatedByPropertyName(cur, nodeOrPropertyName);\n                            cur = cur.left;\n                            continue;\n                        }\n                        else {\n                            predecessor.right = null;\n                        }\n                    }\n                    else {\n                        this._accumulatedByPropertyName(cur, nodeOrPropertyName);\n                    }\n                    cur = cur.right;\n                }\n                break;\n            case 'post':\n                while (cur) {\n                    if (cur.left) {\n                        const predecessor = this.getPredecessor(cur);\n                        if (predecessor.right === null) {\n                            predecessor.right = cur;\n                            cur = cur.left;\n                            continue;\n                        }\n                        else {\n                            predecessor.right = null;\n                            _printEdge(cur.left);\n                        }\n                    }\n                    cur = cur.right;\n                }\n                _printEdge(this.root);\n                break;\n        }\n        return this._getResultByPropertyName(nodeOrPropertyName);\n    }\n    /**\n     * The function adds a new node to a binary tree if there is an available position.\n     * @param {N | null} newNode - The `newNode` parameter is of type `N | null`, which means it can either be a node of\n     * type `N` or `null`. It represents the node that you want to add to the binary tree.\n     * @param {N} parent - The parent parameter is of type N, which represents a node in a binary tree.\n     * @returns either the left or right child node of the parent node, depending on which child is available for adding\n     * the new node. If a new node is added, the function also updates the size of the binary tree. If neither the left nor\n     * right child is available, the function returns undefined. If the parent node is null, the function also returns\n     * undefined.\n     */\n    _addTo(newNode, parent) {\n        if (parent) {\n            // When all leaf nodes are null, it will no longer be possible to add new entity nodes to this binary tree.\n            // In this scenario, null nodes serve as \"sentinel nodes,\" \"virtual nodes,\" or \"placeholder nodes.\"\n            if (parent.left === undefined) {\n                parent.left = newNode;\n                if (newNode) {\n                    this._setSize(this.size + 1);\n                }\n                return parent.left;\n            }\n            else if (parent.right === undefined) {\n                parent.right = newNode;\n                if (newNode) {\n                    this._setSize(this.size + 1);\n                }\n                return parent.right;\n            }\n            else {\n                return;\n            }\n        }\n        else {\n            return;\n        }\n    }\n    /**\n     * The function sets the loop type for a protected variable.\n     * @param {LoopType} value - The value parameter is of type LoopType.\n     */\n    _setLoopType(value) {\n        this._loopType = value;\n    }\n    /**\n     * The function sets the root property of an object to a given value, and if the value is not null, it also sets the\n     * parent property of the value to undefined.\n     * @param {N | null} v - The parameter `v` is of type `N | null`, which means it can either be of type `N` or `null`.\n     */\n    _setRoot(v) {\n        if (v) {\n            v.parent = undefined;\n        }\n        this._root = v;\n    }\n    /**\n     * The function sets the size of a protected variable.\n     * @param {number} v - number\n     */\n    _setSize(v) {\n        this._size = v;\n    }\n    /**\n     * The function `_clearResults` resets the values of several arrays used for tracking visited nodes and their\n     * properties.\n     */\n    _clearResults() {\n        this.visitedKey = [];\n        this.visitedVal = [];\n        this.visitedNode = [];\n    }\n    /**\n     * The function checks if a given property of a binary tree node matches a specified value, and if so, adds the node to\n     * a result array.\n     * @param {N} cur - The current node being processed.\n     * @param {(N | null | undefined)[]} result - An array that stores the matching nodes.\n     * @param {BinaryTreeNodeKey | N} nodeProperty - The `nodeProperty` parameter is either a `BinaryTreeNodeKey` or a `N`\n     * type. It represents the property value that we are comparing against in the switch statement.\n     * @param {BinaryTreeNodePropertyName} [propertyName] - The `propertyName` parameter is an optional parameter that\n     * specifies the property name to compare against when pushing nodes into the `result` array. It can be either `'key'`\n     * or `'val'`. If it is not provided or is not equal to `'key'` or `'val'`, the\n     * @param {boolean} [onlyOne] - The `onlyOne` parameter is an optional boolean parameter that determines whether to\n     * stop after finding the first matching node or continue searching for all matching nodes. If `onlyOne` is set to\n     * `true`, the function will stop after finding the first matching node and return `true`. If `onlyOne\n     * @returns a boolean value indicating whether only one matching node should be pushed into the result array.\n     */\n    _pushByPropertyNameStopOrNot(cur, result, nodeProperty, propertyName = 'key', onlyOne = false) {\n        switch (propertyName) {\n            case 'key':\n                if (cur.key === nodeProperty) {\n                    result.push(cur);\n                    return onlyOne;\n                }\n                break;\n            case 'val':\n                if (cur.val === nodeProperty) {\n                    result.push(cur);\n                    return onlyOne;\n                }\n                break;\n            default:\n                if (cur.key === nodeProperty) {\n                    result.push(cur);\n                    return onlyOne;\n                }\n                break;\n        }\n    }\n    /**\n     * The function `_accumulatedByPropertyName` accumulates values from a given node based on the specified property name.\n     * @param {N} node - The `node` parameter is of type `N`, which represents a node in a data structure.\n     * @param {NodeOrPropertyName} [nodeOrPropertyName] - The `nodeOrPropertyName` parameter is an optional parameter that\n     * can be either a string representing a property name or a reference to a `Node` object. If it is a string, it\n     * specifies the property name to be used for accumulating values. If it is a `Node` object, it specifies\n     */\n    _accumulatedByPropertyName(node, nodeOrPropertyName = 'key') {\n        switch (nodeOrPropertyName) {\n            case 'key':\n                this.visitedKey.push(node.key);\n                break;\n            case 'val':\n                this.visitedVal.push(node.val);\n                break;\n            case 'node':\n                this.visitedNode.push(node);\n                break;\n            default:\n                this.visitedKey.push(node.key);\n                break;\n        }\n    }\n    /**\n     * The time complexity of Morris traversal is O(n), it may slower than others\n     * The space complexity  Morris traversal is O(1) because no using stack\n     */\n    /**\n     * The function `_getResultByPropertyName` returns the corresponding property value based on the given node or property\n     * name.\n     * @param {NodeOrPropertyName} [nodeOrPropertyName] - The parameter `nodeOrPropertyName` is an optional parameter that\n     * can accept either a `NodeOrPropertyName` type or be undefined.\n     * @returns The method `_getResultByPropertyName` returns an instance of `BinaryTreeNodeProperties<N>`.\n     */\n    _getResultByPropertyName(nodeOrPropertyName = 'key') {\n        switch (nodeOrPropertyName) {\n            case 'key':\n                return this.visitedKey;\n            case 'val':\n                return this.visitedVal;\n            case 'node':\n                return this.visitedNode;\n            default:\n                return this.visitedKey;\n        }\n    }\n}\n","import { CP, LoopType } from '../../types';\nimport { BinaryTree, BinaryTreeNode } from './binary-tree';\nexport class BSTNode extends BinaryTreeNode {\n    constructor(key, val) {\n        super(key, val);\n    }\n}\nexport class BST extends BinaryTree {\n    /**\n     * The constructor function initializes a binary search tree object with an optional comparator function.\n     * @param {BSTOptions} [options] - An optional object that contains configuration options for the binary search tree.\n     */\n    constructor(options) {\n        super(options);\n        this._comparator = (a, b) => a - b;\n        if (options !== undefined) {\n            const { comparator } = options;\n            if (comparator !== undefined) {\n                this._comparator = comparator;\n            }\n        }\n    }\n    /**\n     * The function creates a new binary search tree node with the given key and value.\n     * @param {BinaryTreeNodeKey} key - The `key` parameter is the identifier for the binary tree node. It is used to uniquely\n     * identify each node in the binary tree.\n     * @param [val] - The `val` parameter is an optional value that can be assigned to the node. It represents the value\n     * that will be stored in the node.\n     * @returns a new instance of the BSTNode class with the specified key and value.\n     */\n    createNode(key, val) {\n        return new BSTNode(key, val);\n    }\n    /**\n     * The `add` function adds a new node to a binary search tree, either by creating a new node or by updating an existing\n     * node with the same ID.\n     * @param {BinaryTreeNodeKey | N | null} keyOrNode - The `keyOrNode` parameter can be either a `BinaryTreeNodeKey` or a `N`\n     * (which represents a binary tree node) or `null`.\n     * @param [val] - The `val` parameter is an optional value that can be assigned to the `val` property of the new node\n     * being added to the binary search tree.\n     * @returns The function `add` returns the inserted node (`inserted`) which can be of type `N`, `null`, or `undefined`.\n     */\n    add(keyOrNode, val) {\n        // TODO support node as a param\n        let inserted = null;\n        let newNode = null;\n        if (keyOrNode instanceof BSTNode) {\n            newNode = keyOrNode;\n        }\n        else if (typeof keyOrNode === 'number') {\n            newNode = this.createNode(keyOrNode, val);\n        }\n        else if (keyOrNode === null) {\n            newNode = null;\n        }\n        if (this.root === null) {\n            this._setRoot(newNode);\n            this._setSize(this.size + 1);\n            inserted = this.root;\n        }\n        else {\n            let cur = this.root;\n            let traversing = true;\n            while (traversing) {\n                if (cur !== null && newNode !== null) {\n                    if (this._compare(cur.key, newNode.key) === CP.eq) {\n                        if (newNode) {\n                            cur.val = newNode.val;\n                        }\n                        //Duplicates are not accepted.\n                        traversing = false;\n                        inserted = cur;\n                    }\n                    else if (this._compare(cur.key, newNode.key) === CP.gt) {\n                        // Traverse left of the node\n                        if (cur.left === undefined) {\n                            if (newNode) {\n                                newNode.parent = cur;\n                            }\n                            //Add to the left of the current node\n                            cur.left = newNode;\n                            this._setSize(this.size + 1);\n                            traversing = false;\n                            inserted = cur.left;\n                        }\n                        else {\n                            //Traverse the left of the current node\n                            if (cur.left)\n                                cur = cur.left;\n                        }\n                    }\n                    else if (this._compare(cur.key, newNode.key) === CP.lt) {\n                        // Traverse right of the node\n                        if (cur.right === undefined) {\n                            if (newNode) {\n                                newNode.parent = cur;\n                            }\n                            //Add to the right of the current node\n                            cur.right = newNode;\n                            this._setSize(this.size + 1);\n                            traversing = false;\n                            inserted = cur.right;\n                        }\n                        else {\n                            //Traverse the left of the current node\n                            if (cur.right)\n                                cur = cur.right;\n                        }\n                    }\n                }\n                else {\n                    traversing = false;\n                }\n            }\n        }\n        return inserted;\n    }\n    /**\n     * The `addMany` function overrides the base class method to add multiple nodes to a binary search tree in a balanced\n     * manner.\n     * @param {[BinaryTreeNodeKey | N , N['val']][]} keysOrNodes - The `keysOrNodes` parameter in the `addMany` function is an array of\n     * `BinaryTreeNodeKey` or `N` (node) objects, or `null` values. It represents the nodes or node IDs that need to be added\n     * to the binary search tree.\n     * @param {N['val'][]} data - The values of tree nodes\n     * @param {boolean} isBalanceAdd - If true the nodes will be balance inserted in binary search method.\n     * @returns The function `addMany` returns an array of `N`, `null`, or `undefined` values.\n     */\n    addMany(keysOrNodes, data, isBalanceAdd = false) {\n        function hasNoNull(arr) {\n            return arr.indexOf(null) === -1;\n        }\n        if (!isBalanceAdd || !hasNoNull(keysOrNodes)) {\n            return super.addMany(keysOrNodes, data);\n        }\n        const inserted = [];\n        const combinedArr = keysOrNodes.map((value, index) => [value, data === null || data === void 0 ? void 0 : data[index]]);\n        let sorted = [];\n        function isNodeOrNullTuple(arr) {\n            for (const [keyOrNode] of arr)\n                if (keyOrNode instanceof BSTNode)\n                    return true;\n            return false;\n        }\n        function isBinaryTreeKeyOrNullTuple(arr) {\n            for (const [keyOrNode] of arr)\n                if (typeof keyOrNode === 'number')\n                    return true;\n            return false;\n        }\n        let sortedKeysOrNodes = [], sortedData = [];\n        if (isNodeOrNullTuple(combinedArr)) {\n            sorted = combinedArr.sort((a, b) => a[0].key - b[0].key);\n        }\n        else if (isBinaryTreeKeyOrNullTuple(combinedArr)) {\n            sorted = combinedArr.sort((a, b) => a[0] - b[0]);\n        }\n        else {\n            throw new Error('Invalid input keysOrNodes');\n        }\n        sortedKeysOrNodes = sorted.map(([keyOrNode]) => keyOrNode);\n        sortedData = sorted.map(([, val]) => val);\n        const recursive = (arr, data) => {\n            if (arr.length === 0)\n                return;\n            const mid = Math.floor((arr.length - 1) / 2);\n            const newNode = this.add(arr[mid], data === null || data === void 0 ? void 0 : data[mid]);\n            inserted.push(newNode);\n            recursive(arr.slice(0, mid), data === null || data === void 0 ? void 0 : data.slice(0, mid));\n            recursive(arr.slice(mid + 1), data === null || data === void 0 ? void 0 : data.slice(mid + 1));\n        };\n        const iterative = () => {\n            const n = sorted.length;\n            const stack = [[0, n - 1]];\n            while (stack.length > 0) {\n                const popped = stack.pop();\n                if (popped) {\n                    const [l, r] = popped;\n                    if (l <= r) {\n                        const m = l + Math.floor((r - l) / 2);\n                        const newNode = this.add(sortedKeysOrNodes[m], sortedData === null || sortedData === void 0 ? void 0 : sortedData[m]);\n                        inserted.push(newNode);\n                        stack.push([m + 1, r]);\n                        stack.push([l, m - 1]);\n                    }\n                }\n            }\n        };\n        if (this.loopType === LoopType.RECURSIVE) {\n            recursive(sortedKeysOrNodes, sortedData);\n        }\n        else {\n            iterative();\n        }\n        return inserted;\n    }\n    /**\n     * The function returns the first node in a binary tree that matches the given property name and value.\n     * @param {BinaryTreeNodeKey | N} nodeProperty - The `nodeProperty` parameter can be either a `BinaryTreeNodeKey` or a\n     * generic type `N`. It represents the property of the binary tree node that you want to search for.\n     * @param {BinaryTreeNodePropertyName} [propertyName] - The `propertyName` parameter is an optional parameter that\n     * specifies the property name to use for searching the binary tree nodes. If not provided, it defaults to `'key'`.\n     * @returns The method is returning either a BinaryTreeNodeKey or N (generic type) or null.\n     */\n    get(nodeProperty, propertyName = 'key') {\n        var _a;\n        return (_a = this.getNodes(nodeProperty, propertyName, true)[0]) !== null && _a !== void 0 ? _a : null;\n    }\n    /**\n     * The function returns the key of the rightmost node if the comparison between two values is less than, the key of the\n     * leftmost node if the comparison is greater than, and the key of the rightmost node otherwise.\n     * @returns The method `lastKey()` returns the key of the rightmost node in the binary tree if the comparison between\n     * the values at index 0 and 1 is less than, otherwise it returns the key of the leftmost node. If the comparison is\n     * equal, it returns the key of the rightmost node. If there are no nodes in the tree, it returns 0.\n     */\n    lastKey() {\n        var _a, _b, _c, _d, _e, _f;\n        if (this._compare(0, 1) === CP.lt)\n            return (_b = (_a = this.getRightMost()) === null || _a === void 0 ? void 0 : _a.key) !== null && _b !== void 0 ? _b : 0;\n        else if (this._compare(0, 1) === CP.gt)\n            return (_d = (_c = this.getLeftMost()) === null || _c === void 0 ? void 0 : _c.key) !== null && _d !== void 0 ? _d : 0;\n        else\n            return (_f = (_e = this.getRightMost()) === null || _e === void 0 ? void 0 : _e.key) !== null && _f !== void 0 ? _f : 0;\n    }\n    /**\n     * The function `getNodes` returns an array of nodes in a binary tree that match a given property value.\n     * @param {BinaryTreeNodeKey | N} nodeProperty - The `nodeProperty` parameter can be either a `BinaryTreeNodeKey` or an\n     * `N` type. It represents the property of the binary tree node that you want to compare with.\n     * @param {BinaryTreeNodePropertyName} [propertyName] - The `propertyName` parameter is an optional parameter that\n     * specifies the property name to use for comparison. If not provided, it defaults to `'key'`.\n     * @param {boolean} [onlyOne] - The `onlyOne` parameter is an optional boolean parameter that determines whether to\n     * return only one node that matches the given `nodeProperty` or all nodes that match the `nodeProperty`. If `onlyOne`\n     * is set to `true`, the function will return an array with only one node (if\n     * @returns an array of nodes (type N).\n     */\n    getNodes(nodeProperty, propertyName = 'key', onlyOne = false) {\n        if (!this.root)\n            return [];\n        const result = [];\n        if (this.loopType === LoopType.RECURSIVE) {\n            const _traverse = (cur) => {\n                if (this._pushByPropertyNameStopOrNot(cur, result, nodeProperty, propertyName, onlyOne))\n                    return;\n                if (!cur.left && !cur.right)\n                    return;\n                if (propertyName === 'key') {\n                    if (this._compare(cur.key, nodeProperty) === CP.gt)\n                        cur.left && _traverse(cur.left);\n                    if (this._compare(cur.key, nodeProperty) === CP.lt)\n                        cur.right && _traverse(cur.right);\n                }\n                else {\n                    cur.left && _traverse(cur.left);\n                    cur.right && _traverse(cur.right);\n                }\n            };\n            _traverse(this.root);\n        }\n        else {\n            const queue = [this.root];\n            while (queue.length > 0) {\n                const cur = queue.shift();\n                if (cur) {\n                    if (this._pushByPropertyNameStopOrNot(cur, result, nodeProperty, propertyName, onlyOne))\n                        return result;\n                    if (propertyName === 'key') {\n                        if (this._compare(cur.key, nodeProperty) === CP.gt)\n                            cur.left && queue.push(cur.left);\n                        if (this._compare(cur.key, nodeProperty) === CP.lt)\n                            cur.right && queue.push(cur.right);\n                    }\n                    else {\n                        cur.left && queue.push(cur.left);\n                        cur.right && queue.push(cur.right);\n                    }\n                }\n            }\n        }\n        return result;\n    }\n    // --- start additional functions\n    /**\n     * The `lesserSum` function calculates the sum of property values in a binary tree for nodes that have a property value\n     * less than a given node.\n     * @param {N | BinaryTreeNodeKey | null} beginNode - The `beginNode` parameter can be one of the following:\n     * @param {BinaryTreeNodePropertyName} [propertyName] - The `propertyName` parameter is an optional parameter that\n     * specifies the property name to use for calculating the sum. If not provided, it defaults to `'key'`.\n     * @returns The function `lesserSum` returns a number, which represents the sum of the values of the nodes in the\n     * binary tree that have a lesser value than the specified `beginNode` based on the `propertyName`.\n     */\n    lesserSum(beginNode, propertyName = 'key') {\n        if (typeof beginNode === 'number')\n            beginNode = this.get(beginNode, 'key');\n        if (!beginNode)\n            return 0;\n        if (!this.root)\n            return 0;\n        const key = beginNode.key;\n        const getSumByPropertyName = (cur) => {\n            let needSum;\n            switch (propertyName) {\n                case 'key':\n                    needSum = cur.key;\n                    break;\n                default:\n                    needSum = cur.key;\n                    break;\n            }\n            return needSum;\n        };\n        let sum = 0;\n        if (this.loopType === LoopType.RECURSIVE) {\n            const _traverse = (cur) => {\n                const compared = this._compare(cur.key, key);\n                if (compared === CP.eq) {\n                    if (cur.right)\n                        sum += this.subTreeSum(cur.right, propertyName);\n                    return;\n                }\n                else if (compared === CP.lt) {\n                    if (cur.left)\n                        sum += this.subTreeSum(cur.left, propertyName);\n                    sum += getSumByPropertyName(cur);\n                    if (cur.right)\n                        _traverse(cur.right);\n                    else\n                        return;\n                }\n                else {\n                    if (cur.left)\n                        _traverse(cur.left);\n                    else\n                        return;\n                }\n            };\n            _traverse(this.root);\n        }\n        else {\n            const queue = [this.root];\n            while (queue.length > 0) {\n                const cur = queue.shift();\n                if (cur) {\n                    const compared = this._compare(cur.key, key);\n                    if (compared === CP.eq) {\n                        if (cur.right)\n                            sum += this.subTreeSum(cur.right, propertyName);\n                        return sum;\n                    }\n                    else if (compared === CP.lt) {\n                        // todo maybe a bug\n                        if (cur.left)\n                            sum += this.subTreeSum(cur.left, propertyName);\n                        sum += getSumByPropertyName(cur);\n                        if (cur.right)\n                            queue.push(cur.right);\n                        else\n                            return sum;\n                    }\n                    else {\n                        if (cur.left)\n                            queue.push(cur.left);\n                        else\n                            return sum;\n                    }\n                }\n            }\n        }\n        return sum;\n    }\n    /**\n     * The `allGreaterNodesAdd` function adds a delta value to the specified property of all nodes in a binary tree that\n     * have a greater value than a given node.\n     * @param {N | BinaryTreeNodeKey | null} node - The `node` parameter can be either of type `N` (a generic type),\n     * `BinaryTreeNodeKey`, or `null`. It represents the node in the binary tree to which the delta value will be added.\n     * @param {number} delta - The `delta` parameter is a number that represents the amount by which the property value of\n     * each greater node should be increased.\n     * @param {BinaryTreeNodePropertyName} [propertyName] - The `propertyName` parameter is an optional parameter that\n     * specifies the property name of the nodes in the binary tree that you want to update. If not provided, it defaults to\n     * 'key'.\n     * @returns a boolean value.\n     */\n    allGreaterNodesAdd(node, delta, propertyName = 'key') {\n        if (typeof node === 'number')\n            node = this.get(node, 'key');\n        if (!node)\n            return false;\n        const key = node.key;\n        if (!this.root)\n            return false;\n        const _sumByPropertyName = (cur) => {\n            switch (propertyName) {\n                case 'key':\n                    cur.key += delta;\n                    break;\n                default:\n                    cur.key += delta;\n                    break;\n            }\n        };\n        if (this.loopType === LoopType.RECURSIVE) {\n            const _traverse = (cur) => {\n                const compared = this._compare(cur.key, key);\n                if (compared === CP.gt)\n                    _sumByPropertyName(cur);\n                if (!cur.left && !cur.right)\n                    return;\n                if (cur.left && this._compare(cur.left.key, key) === CP.gt)\n                    _traverse(cur.left);\n                if (cur.right && this._compare(cur.right.key, key) === CP.gt)\n                    _traverse(cur.right);\n            };\n            _traverse(this.root);\n            return true;\n        }\n        else {\n            const queue = [this.root];\n            while (queue.length > 0) {\n                const cur = queue.shift();\n                if (cur) {\n                    const compared = this._compare(cur.key, key);\n                    if (compared === CP.gt)\n                        _sumByPropertyName(cur);\n                    if (cur.left && this._compare(cur.left.key, key) === CP.gt)\n                        queue.push(cur.left);\n                    if (cur.right && this._compare(cur.right.key, key) === CP.gt)\n                        queue.push(cur.right);\n                }\n            }\n            return true;\n        }\n    }\n    /**\n     * Balancing Adjustment:\n     * Perfectly Balanced Binary Tree: Since the balance of a perfectly balanced binary tree is already fixed, no additional balancing adjustment is needed. Any insertion or deletion operation will disrupt the perfect balance, often requiring a complete reconstruction of the tree.\n     * AVL Tree: After insertion or deletion operations, an AVL tree performs rotation adjustments based on the balance factor of nodes to restore the tree's balance. These rotations can be left rotations, right rotations, left-right rotations, or right-left rotations, performed as needed.\n     *\n     * Use Cases and Efficiency:\n     * Perfectly Balanced Binary Tree: Perfectly balanced binary trees are typically used in specific scenarios such as complete binary heaps in heap sort or certain types of Huffman trees. However, they are not suitable for dynamic operations requiring frequent insertions and deletions, as these operations often necessitate full tree reconstruction.\n     * AVL Tree: AVL trees are well-suited for scenarios involving frequent searching, insertion, and deletion operations. Through rotation adjustments, AVL trees maintain their balance, ensuring average and worst-case time complexity of O(log n).\n     */\n    /**\n     * The `perfectlyBalance` function takes a binary tree, performs a depth-first search to sort the nodes, and then\n     * constructs a balanced binary search tree using either a recursive or iterative approach.\n     * @returns The function `perfectlyBalance()` returns a boolean value.\n     */\n    perfectlyBalance() {\n        const sorted = this.dfs('in', 'node'), n = sorted.length;\n        this.clear();\n        if (sorted.length < 1)\n            return false;\n        if (this.loopType === LoopType.RECURSIVE) {\n            const buildBalanceBST = (l, r) => {\n                if (l > r)\n                    return;\n                const m = l + Math.floor((r - l) / 2);\n                const midNode = sorted[m];\n                this.add(midNode.key, midNode.val);\n                buildBalanceBST(l, m - 1);\n                buildBalanceBST(m + 1, r);\n            };\n            buildBalanceBST(0, n - 1);\n            return true;\n        }\n        else {\n            const stack = [[0, n - 1]];\n            while (stack.length > 0) {\n                const popped = stack.pop();\n                if (popped) {\n                    const [l, r] = popped;\n                    if (l <= r) {\n                        const m = l + Math.floor((r - l) / 2);\n                        const midNode = sorted[m];\n                        this.add(midNode.key, midNode.val);\n                        stack.push([m + 1, r]);\n                        stack.push([l, m - 1]);\n                    }\n                }\n            }\n            return true;\n        }\n    }\n    /**\n     * The function `isAVLBalanced` checks if a binary tree is balanced according to the AVL tree property.\n     * @returns a boolean value.\n     */\n    isAVLBalanced() {\n        var _a, _b;\n        if (!this.root)\n            return true;\n        let balanced = true;\n        if (this.loopType === LoopType.RECURSIVE) {\n            const _height = (cur) => {\n                if (!cur)\n                    return 0;\n                const leftHeight = _height(cur.left), rightHeight = _height(cur.right);\n                if (Math.abs(leftHeight - rightHeight) > 1)\n                    balanced = false;\n                return Math.max(leftHeight, rightHeight) + 1;\n            };\n            _height(this.root);\n        }\n        else {\n            const stack = [];\n            let node = this.root, last = null;\n            const depths = new Map();\n            while (stack.length > 0 || node) {\n                if (node) {\n                    stack.push(node);\n                    node = node.left;\n                }\n                else {\n                    node = stack[stack.length - 1];\n                    if (!node.right || last === node.right) {\n                        node = stack.pop();\n                        if (node) {\n                            const left = node.left ? (_a = depths.get(node.left)) !== null && _a !== void 0 ? _a : -1 : -1;\n                            const right = node.right ? (_b = depths.get(node.right)) !== null && _b !== void 0 ? _b : -1 : -1;\n                            if (Math.abs(left - right) > 1)\n                                return false;\n                            depths.set(node, 1 + Math.max(left, right));\n                            last = node;\n                            node = null;\n                        }\n                    }\n                    else\n                        node = node.right;\n                }\n            }\n        }\n        return balanced;\n    }\n    /**\n     * The function compares two binary tree node IDs using a comparator function and returns whether the first ID is\n     * greater than, less than, or equal to the second ID.\n     * @param {BinaryTreeNodeKey} a - \"a\" is a BinaryTreeNodeKey, which represents the identifier of a binary tree node.\n     * @param {BinaryTreeNodeKey} b - The parameter \"b\" in the above code refers to a BinaryTreeNodeKey.\n     * @returns a value of type CP (ComparisonResult). The possible return values are CP.gt (greater than), CP.lt (less\n     * than), or CP.eq (equal).\n     */\n    _compare(a, b) {\n        const compared = this._comparator(a, b);\n        if (compared > 0)\n            return CP.gt;\n        else if (compared < 0)\n            return CP.lt;\n        else\n            return CP.eq;\n    }\n}\n","/**\n * data-structure-typed\n *\n * @author Tyler Zeng\n * @copyright Copyright (c) 2022 Tyler Zeng <zrwusa@gmail.com>\n * @license MIT License\n */\nexport class BinaryIndexedTree {\n    /**\n     * The constructor initializes an array with a specified length and fills it with zeros.\n     * @param {number} n - The parameter `n` represents the size of the array that will be used to store the sum tree. The\n     * sum tree is a binary tree data structure used to efficiently calculate the sum of a range of elements in an array.\n     * The size of the sum tree array is `n + 1` because\n     */\n    constructor(n) {\n        this._sumTree = new Array(n + 1).fill(0);\n    }\n    get sumTree() {\n        return this._sumTree;\n    }\n    static lowBit(x) {\n        return x & -x;\n    }\n    /**\n     * The update function updates the values in a binary indexed tree by adding a delta value to the specified index and\n     * its ancestors.\n     * @param {number} i - The parameter `i` represents the index of the element in the `_sumTree` array that needs to be\n     * updated.\n     * @param {number} delta - The \"delta\" parameter represents the change in value that needs to be added to the element\n     * at index \"i\" in the \"_sumTree\" array.\n     */\n    update(i, delta) {\n        while (i < this._sumTree.length) {\n            this._sumTree[i] += delta;\n            i += BinaryIndexedTree.lowBit(i);\n        }\n    }\n    /**\n     * The function calculates the prefix sum of an array using a binary indexed tree.\n     * @param {number} i - The parameter \"i\" in the function \"getPrefixSum\" represents the index of the element in the\n     * array for which we want to calculate the prefix sum.\n     * @returns The function `getPrefixSum` returns the prefix sum of the elements in the binary indexed tree up to index\n     * `i`.\n     */\n    getPrefixSum(i) {\n        let sum = 0;\n        while (i > 0) {\n            sum += this._sumTree[i];\n            i -= BinaryIndexedTree.lowBit(i);\n        }\n        return sum;\n    }\n    /**\n     * The function `getRangeSum` calculates the sum of a range of numbers in an array.\n     * @param {number} start - The start parameter is the starting index of the range for which we want to calculate the\n     * sum.\n     * @param {number} end - The \"end\" parameter represents the ending index of the range for which we want to calculate\n     * the sum.\n     * @returns the sum of the elements in the range specified by the start and end indices.\n     */\n    getRangeSum(start, end) {\n        if (!(0 <= start && start <= end && end <= this._sumTree.length))\n            throw 'Index out of bounds';\n        return this.getPrefixSum(end) - this.getPrefixSum(start);\n    }\n    _setSumTree(value) {\n        this._sumTree = value;\n    }\n}\n","/**\n * data-structure-typed\n *\n * @author Tyler Zeng\n * @copyright Copyright (c) 2022 Tyler Zeng <zrwusa@gmail.com>\n * @license MIT License\n */\nexport class SegmentTreeNode {\n    constructor(start, end, sum, val) {\n        this._start = 0;\n        this._end = 0;\n        this._val = null;\n        this._sum = 0;\n        this._left = null;\n        this._right = null;\n        this._start = start;\n        this._end = end;\n        this._sum = sum;\n        this._val = val || null;\n    }\n    get start() {\n        return this._start;\n    }\n    set start(v) {\n        this._start = v;\n    }\n    get end() {\n        return this._end;\n    }\n    set end(v) {\n        this._end = v;\n    }\n    get val() {\n        return this._val;\n    }\n    set val(v) {\n        this._val = v;\n    }\n    get sum() {\n        return this._sum;\n    }\n    set sum(v) {\n        this._sum = v;\n    }\n    get left() {\n        return this._left;\n    }\n    set left(v) {\n        this._left = v;\n    }\n    get right() {\n        return this._right;\n    }\n    set right(v) {\n        this._right = v;\n    }\n}\nexport class SegmentTree {\n    /**\n     * The constructor initializes the values, start, end, and root properties of an object.\n     * @param {number[]} values - An array of numbers that will be used to build a binary search tree.\n     * @param {number} [start] - The `start` parameter is the index of the first element in the `values` array that should\n     * be included in the range. If no value is provided for `start`, it defaults to 0, which means the range starts from\n     * the beginning of the array.\n     * @param {number} [end] - The \"end\" parameter is the index of the last element in the \"values\" array that should be\n     * included in the range. If not provided, it defaults to the index of the last element in the \"values\" array.\n     */\n    constructor(values, start, end) {\n        this._values = [];\n        this._start = 0;\n        start = start || 0;\n        end = end || values.length - 1;\n        this._values = values;\n        this._start = start;\n        this._end = end;\n        if (values.length > 0) {\n            this._root = this.build(start, end);\n        }\n        else {\n            this._root = null;\n            this._values = [];\n        }\n    }\n    get values() {\n        return this._values;\n    }\n    get start() {\n        return this._start;\n    }\n    get end() {\n        return this._end;\n    }\n    get root() {\n        return this._root;\n    }\n    /**\n     * The build function creates a segment tree by recursively dividing the given range into smaller segments and assigning\n     * the sum of values to each segment.\n     * @param {number} start - The `start` parameter represents the starting index of the segment or range for which we are\n     * building the segment tree.\n     * @param {number} end - The \"end\" parameter represents the ending index of the segment or range for which we want to\n     * build a segment tree.\n     * @returns a SegmentTreeNode object.\n     */\n    build(start, end) {\n        if (start > end) {\n            return new SegmentTreeNode(start, end, 0);\n        }\n        if (start === end)\n            return new SegmentTreeNode(start, end, this._values[start]);\n        const mid = start + Math.floor((end - start) / 2);\n        const left = this.build(start, mid);\n        const right = this.build(mid + 1, end);\n        const cur = new SegmentTreeNode(start, end, left.sum + right.sum);\n        cur.left = left;\n        cur.right = right;\n        return cur;\n    }\n    /**\n     * The function updates the value of a node in a segment tree and recalculates the sum of its children if they exist.\n     * @param {number} index - The index parameter represents the index of the node in the segment tree that needs to be\n     * updated.\n     * @param {number} sum - The `sum` parameter represents the new value that should be assigned to the `sum` property of\n     * the `SegmentTreeNode` at the specified `index`.\n     * @param {SegmentTreeNodeVal} [val] - The `val` parameter is an optional value that can be assigned to the `val`\n     * property of the `SegmentTreeNode` object. It is not currently used in the code, but you can uncomment the line `//\n     * cur.val = val;` and pass a value for `val` in the\n     * @returns The function does not return anything.\n     */\n    updateNode(index, sum, val) {\n        const root = this.root || null;\n        if (!root) {\n            return;\n        }\n        const dfs = (cur, index, sum, val) => {\n            if (cur.start === cur.end && cur.start === index) {\n                cur.sum = sum;\n                if (val !== undefined)\n                    cur.val = val;\n                return;\n            }\n            const mid = cur.start + Math.floor((cur.end - cur.start) / 2);\n            if (index <= mid) {\n                if (cur.left) {\n                    dfs(cur.left, index, sum, val);\n                }\n            }\n            else {\n                if (cur.right) {\n                    dfs(cur.right, index, sum, val);\n                }\n            }\n            if (cur.left && cur.right) {\n                cur.sum = cur.left.sum + cur.right.sum;\n            }\n        };\n        dfs(root, index, sum, val);\n    }\n    /**\n     * The function `querySumByRange` calculates the sum of values within a given range in a segment tree.\n     * @param {number} indexA - The starting index of the range for which you want to calculate the sum.\n     * @param {number} indexB - The parameter `indexB` represents the ending index of the range for which you want to\n     * calculate the sum.\n     * @returns The function `querySumByRange` returns a number.\n     */\n    querySumByRange(indexA, indexB) {\n        const root = this.root || null;\n        if (!root) {\n            return 0;\n        }\n        if (indexA < 0 || indexB >= this.values.length || indexA > indexB) {\n            return NaN;\n        }\n        const dfs = (cur, i, j) => {\n            if (i <= cur.start && j >= cur.end) {\n                // The range [i, j] completely covers the current node's range [cur.start, cur.end]\n                return cur.sum;\n            }\n            const mid = cur.start + Math.floor((cur.end - cur.start) / 2);\n            if (j <= mid) {\n                if (cur.left) {\n                    return dfs(cur.left, i, j);\n                }\n                else {\n                    return NaN;\n                }\n            }\n            else if (i > mid) {\n                if (cur.right) {\n                    return dfs(cur.right, i, j);\n                }\n                else {\n                    return NaN;\n                }\n            }\n            else {\n                // Query both left and right subtrees\n                let leftSum = 0;\n                let rightSum = 0;\n                if (cur.left) {\n                    leftSum = dfs(cur.left, i, mid);\n                }\n                if (cur.right) {\n                    rightSum = dfs(cur.right, mid + 1, j);\n                }\n                return leftSum + rightSum;\n            }\n        };\n        return dfs(root, indexA, indexB);\n    }\n    _setValues(value) {\n        this._values = value;\n    }\n    _setStart(value) {\n        this._start = value;\n    }\n    _setEnd(value) {\n        this._end = value;\n    }\n    _setRoot(v) {\n        this._root = v;\n    }\n}\n","/**\n * data-structure-typed\n *\n * @author Tyler Zeng\n * @copyright Copyright (c) 2022 Tyler Zeng <zrwusa@gmail.com>\n * @license MIT License\n */\nimport { BST, BSTNode } from './bst';\nexport class AVLTreeNode extends BSTNode {\n    constructor(key, val) {\n        super(key, val);\n        this.height = 0;\n    }\n}\nexport class AVLTree extends BST {\n    /**\n     * This is a constructor function for an AVL tree data structure in TypeScript.\n     * @param {AVLTreeOptions} [options] - The `options` parameter is an optional object that can be passed to the\n     * constructor of the AVLTree class. It allows you to customize the behavior of the AVL tree by providing different\n     * options.\n     */\n    constructor(options) {\n        super(options);\n    }\n    /**\n     * The `swapLocation` function swaps the location of two nodes in a binary tree.\n     * @param {N} srcNode - The source node that you want to swap with the destination node.\n     * @param {N} destNode - The `destNode` parameter represents the destination node where the values from `srcNode` will\n     * be swapped to.\n     * @returns The `destNode` is being returned.\n     */\n    swapLocation(srcNode, destNode) {\n        const { key, val, height } = destNode;\n        const tempNode = this.createNode(key, val);\n        if (tempNode) {\n            tempNode.height = height;\n            destNode.key = srcNode.key;\n            destNode.val = srcNode.val;\n            destNode.height = srcNode.height;\n            srcNode.key = tempNode.key;\n            srcNode.val = tempNode.val;\n            srcNode.height = tempNode.height;\n        }\n        return destNode;\n    }\n    /**\n     * The function creates a new AVL tree node with the given key and value.\n     * @param {BinaryTreeNodeKey} key - The `key` parameter is the identifier for the binary tree node. It is used to uniquely\n     * identify each node in the tree.\n     * @param [val] - The `val` parameter is an optional value that can be assigned to the node. It represents the value\n     * that will be stored in the node.\n     * @returns a new AVLTreeNode object with the specified key and value.\n     */\n    createNode(key, val) {\n        return new AVLTreeNode(key, val);\n    }\n    /**\n     * The function overrides the add method of a binary tree node and balances the tree after inserting a new node.\n     * @param {BinaryTreeNodeKey} key - The `key` parameter is the identifier of the binary tree node that we want to add.\n     * @param [val] - The `val` parameter is an optional value that can be assigned to the node being added. It is of type\n     * `N['val']`, which means it should be of the same type as the `val` property of the nodes in the binary tree.\n     * @returns The method is returning the inserted node, or null or undefined if the insertion was not successful.\n     */\n    add(key, val) {\n        // TODO support node as a param\n        const inserted = super.add(key, val);\n        if (inserted)\n            this._balancePath(inserted);\n        return inserted;\n    }\n    /**\n     * The function overrides the remove method of a binary tree and performs additional operations to balance the tree after\n     * deletion.\n     * @param {BinaryTreeNodeKey} key - The `key` parameter represents the identifier of the binary tree node that needs to be\n     * removed.\n     * @returns The method is returning an array of `BinaryTreeDeletedResult<N>` objects.\n     */\n    remove(key) {\n        const deletedResults = super.remove(key);\n        for (const { needBalanced } of deletedResults) {\n            if (needBalanced) {\n                this._balancePath(needBalanced);\n            }\n        }\n        return deletedResults;\n    }\n    /**\n     * The balance factor of a given AVL tree node is calculated by subtracting the height of its left subtree from the\n     * height of its right subtree.\n     * @param node - The parameter \"node\" is of type N, which represents a node in an AVL tree.\n     * @returns The balance factor of the given AVL tree node.\n     */\n    _balanceFactor(node) {\n        if (!node.right)\n            // node has no right subtree\n            return -node.height;\n        else if (!node.left)\n            // node has no left subtree\n            return +node.height;\n        else\n            return node.right.height - node.left.height;\n    }\n    /**\n     * The function updates the height of a node in an AVL tree based on the heights of its left and right subtrees.\n     * @param node - The parameter `node` is an AVLTreeNode object, which represents a node in an AVL tree.\n     */\n    _updateHeight(node) {\n        if (!node.left && !node.right)\n            node.height = 0;\n        else if (!node.left) {\n            const rightHeight = node.right ? node.right.height : 0;\n            node.height = 1 + rightHeight;\n        }\n        else if (!node.right)\n            node.height = 1 + node.left.height;\n        else\n            node.height = 1 + Math.max(node.right.height, node.left.height);\n    }\n    /**\n     * The `_balancePath` function balances the AVL tree by performing appropriate rotations based on the balance factor of\n     * each node in the path from the given node to the root.\n     * @param node - The `node` parameter is an AVLTreeNode object, which represents a node in an AVL tree.\n     */\n    _balancePath(node) {\n        const path = this.getPathToRoot(node, false); // first O(log n) + O(log n)\n        for (let i = 0; i < path.length; i++) {\n            // second O(log n)\n            const A = path[i];\n            // Update Heights: After inserting a node, backtrack from the insertion point to the root node, updating the height of each node along the way.\n            this._updateHeight(A); // first O(1)\n            // Check Balance: Simultaneously with height updates, check if each node violates the balance property of an AVL tree.\n            // Balance Restoration: If a balance issue is discovered after inserting a node, it requires balance restoration operations. Balance restoration includes four basic cases where rotation operations need to be performed to fix the balance:\n            switch (this._balanceFactor(A) // second O(1)\n            ) {\n                case -2:\n                    if (A && A.left) {\n                        if (this._balanceFactor(A.left) <= 0) {\n                            // second O(1)\n                            // Left Rotation (LL Rotation): When the inserted node is in the left subtree of the left subtree, causing an imbalance.\n                            this._balanceLL(A);\n                        }\n                        else {\n                            // Left-Right Rotation (LR Rotation): When the inserted node is in the right subtree of the left subtree, causing an imbalance.\n                            this._balanceLR(A);\n                        }\n                    }\n                    break;\n                case +2:\n                    if (A && A.right) {\n                        if (this._balanceFactor(A.right) >= 0) {\n                            // Right Rotation (RR Rotation): When the inserted node is in the right subtree of the right subtree, causing an imbalance.\n                            this._balanceRR(A);\n                        }\n                        else {\n                            // Right-Left Rotation (RL Rotation): When the inserted node is in the left subtree of the right subtree, causing an imbalance.\n                            this._balanceRL(A);\n                        }\n                    }\n            }\n            // TODO So far, no sure if this is necessary that Recursive Repair: Once rotation operations are executed, it may cause imbalance issues at higher levels of the tree. Therefore, you need to recursively check and repair imbalance problems upwards until you reach the root node.\n        }\n    }\n    /**\n     * The `_balanceLL` function performs a left-left rotation on an AVL tree to balance it.\n     * @param A - The parameter A is an AVLTreeNode object.\n     */\n    _balanceLL(A) {\n        const parentOfA = A.parent;\n        const B = A.left;\n        A.parent = B;\n        if (B && B.right) {\n            B.right.parent = A;\n        }\n        if (B)\n            B.parent = parentOfA;\n        if (A === this.root) {\n            if (B)\n                this._setRoot(B);\n        }\n        else {\n            if ((parentOfA === null || parentOfA === void 0 ? void 0 : parentOfA.left) === A) {\n                parentOfA.left = B;\n            }\n            else {\n                if (parentOfA)\n                    parentOfA.right = B;\n            }\n        }\n        if (B) {\n            A.left = B.right;\n            B.right = A;\n        }\n        this._updateHeight(A);\n        if (B)\n            this._updateHeight(B);\n    }\n    /**\n     * The `_balanceLR` function performs a left-right rotation to balance an AVL tree.\n     * @param A - A is an AVLTreeNode object.\n     */\n    _balanceLR(A) {\n        const parentOfA = A.parent;\n        const B = A.left;\n        let C = null;\n        if (B) {\n            C = B.right;\n        }\n        if (A)\n            A.parent = C;\n        if (B)\n            B.parent = C;\n        if (C) {\n            if (C.left) {\n                C.left.parent = B;\n            }\n            if (C.right) {\n                C.right.parent = A;\n            }\n            C.parent = parentOfA;\n        }\n        if (A === this.root) {\n            if (C)\n                this._setRoot(C);\n        }\n        else {\n            if (parentOfA) {\n                if (parentOfA.left === A) {\n                    parentOfA.left = C;\n                }\n                else {\n                    parentOfA.right = C;\n                }\n            }\n        }\n        if (C) {\n            A.left = C.right;\n            if (B)\n                B.right = C.left;\n            C.left = B;\n            C.right = A;\n        }\n        this._updateHeight(A);\n        B && this._updateHeight(B);\n        C && this._updateHeight(C);\n    }\n    /**\n     * The `_balanceRR` function performs a right-right rotation on an AVL tree to balance it.\n     * @param A - The parameter A is an AVLTreeNode object.\n     */\n    _balanceRR(A) {\n        const parentOfA = A.parent;\n        const B = A.right;\n        A.parent = B;\n        if (B) {\n            if (B.left) {\n                B.left.parent = A;\n            }\n            B.parent = parentOfA;\n        }\n        if (A === this.root) {\n            if (B)\n                this._setRoot(B);\n        }\n        else {\n            if (parentOfA) {\n                if (parentOfA.left === A) {\n                    parentOfA.left = B;\n                }\n                else {\n                    parentOfA.right = B;\n                }\n            }\n        }\n        if (B) {\n            A.right = B.left;\n            B.left = A;\n        }\n        this._updateHeight(A);\n        B && this._updateHeight(B);\n    }\n    /**\n     * The `_balanceRL` function performs a right-left rotation to balance an AVL tree.\n     * @param A - A is an AVLTreeNode object.\n     */\n    _balanceRL(A) {\n        const parentOfA = A.parent;\n        const B = A.right;\n        let C = null;\n        if (B) {\n            C = B.left;\n        }\n        A.parent = C;\n        if (B)\n            B.parent = C;\n        if (C) {\n            if (C.left) {\n                C.left.parent = A;\n            }\n            if (C.right) {\n                C.right.parent = B;\n            }\n            C.parent = parentOfA;\n        }\n        if (A === this.root) {\n            if (C)\n                this._setRoot(C);\n        }\n        else {\n            if (parentOfA) {\n                if (parentOfA.left === A) {\n                    parentOfA.left = C;\n                }\n                else {\n                    parentOfA.right = C;\n                }\n            }\n        }\n        if (C)\n            A.right = C.left;\n        if (B && C)\n            B.left = C.right;\n        if (C)\n            C.left = A;\n        if (C)\n            C.right = B;\n        this._updateHeight(A);\n        B && this._updateHeight(B);\n        C && this._updateHeight(C);\n    }\n}\n","import { RBColor } from '../../types';\nimport { BST, BSTNode } from './bst';\nexport class RBTreeNode extends BSTNode {\n    constructor(key, val) {\n        super(key, val);\n        this._color = RBColor.RED;\n    }\n    get color() {\n        return this._color;\n    }\n    set color(value) {\n        this._color = value;\n    }\n}\nexport class RBTree extends BST {\n    constructor(options) {\n        super(options);\n    }\n    createNode(key, val) {\n        return new RBTreeNode(key, val);\n    }\n}\n","import { CP, FamilyPosition, LoopType } from '../../types';\nimport { AVLTree, AVLTreeNode } from './avl-tree';\nexport class TreeMultisetNode extends AVLTreeNode {\n    /**\n     * The constructor function initializes a BinaryTreeNode object with a key, value, and count.\n     * @param {BinaryTreeNodeKey} key - The `key` parameter is of type `BinaryTreeNodeKey` and represents the unique identifier\n     * of the binary tree node.\n     * @param {V} [val] - The `val` parameter is an optional parameter of type `V`. It represents the value of the binary\n     * tree node. If no value is provided, it will be `undefined`.\n     * @param {number} [count=1] - The `count` parameter is a number that represents the number of times a particular value\n     * occurs in a binary tree node. It has a default value of 1, which means that if no value is provided for the `count`\n     * parameter when creating a new instance of the `BinaryTreeNode` class.\n     */\n    constructor(key, val, count = 1) {\n        super(key, val);\n        this.count = count;\n    }\n}\n/**\n * The only distinction between a TreeMultiset and a AVLTree lies in the ability of the former to store duplicate nodes through the utilization of counters.\n */\nexport class TreeMultiset extends AVLTree {\n    /**\n     * The constructor function for a TreeMultiset class in TypeScript, which extends another class and sets an option to\n     * merge duplicated values.\n     * @param {TreeMultisetOptions} [options] - An optional object that contains additional configuration options for the\n     * TreeMultiset.\n     */\n    constructor(options) {\n        super(options);\n        this._count = 0;\n    }\n    get count() {\n        return this._count;\n    }\n    /**\n     * The function creates a new BSTNode with the given key, value, and count.\n     * @param {BinaryTreeNodeKey} key - The key parameter is the unique identifier for the binary tree node. It is used to\n     * distinguish one node from another in the tree.\n     * @param {N} val - The `val` parameter represents the value that will be stored in the binary search tree node.\n     * @param {number} [count] - The \"count\" parameter is an optional parameter of type number. It represents the number of\n     * occurrences of the value in the binary search tree node. If not provided, the count will default to 1.\n     * @returns A new instance of the BSTNode class with the specified key, value, and count (if provided).\n     */\n    createNode(key, val, count) {\n        return new TreeMultisetNode(key, val, count);\n    }\n    /**\n     * The function swaps the location of two nodes in a tree data structure.\n     * @param {N} srcNode - The source node that we want to swap with the destination node.\n     * @param {N} destNode - The `destNode` parameter represents the destination node where the values from `srcNode` will\n     * be swapped with.\n     * @returns the `destNode` after swapping its values with the `srcNode`.\n     */\n    swapLocation(srcNode, destNode) {\n        const { key, val, count, height } = destNode;\n        const tempNode = this.createNode(key, val, count);\n        if (tempNode) {\n            tempNode.height = height;\n            destNode.key = srcNode.key;\n            destNode.val = srcNode.val;\n            destNode.count = srcNode.count;\n            destNode.height = srcNode.height;\n            srcNode.key = tempNode.key;\n            srcNode.val = tempNode.val;\n            srcNode.count = tempNode.count;\n            srcNode.height = tempNode.height;\n        }\n        return destNode;\n    }\n    /**\n     * The `add` function adds a new node to a binary search tree, maintaining the tree's properties and balancing if\n     * necessary.\n     * @param {BinaryTreeNodeKey | N} keyOrNode - The `keyOrNode` parameter can be either a `BinaryTreeNodeKey` or a `N` (which\n     * represents a `BinaryTreeNode`).\n     * @param [val] - The `val` parameter represents the value to be added to the binary tree node.\n     * @param {number} [count] - The `count` parameter is an optional parameter that specifies the number of times the\n     * value should be added to the binary tree. If the `count` parameter is not provided, it defaults to 1.\n     * @returns The method `add` returns either the inserted node (`N`), `null`, or `undefined`.\n     */\n    add(keyOrNode, val, count = 1) {\n        let inserted = undefined, newNode;\n        if (keyOrNode instanceof TreeMultisetNode) {\n            newNode = this.createNode(keyOrNode.key, keyOrNode.val, keyOrNode.count);\n        }\n        else if (keyOrNode === null) {\n            newNode = null;\n        }\n        else {\n            newNode = this.createNode(keyOrNode, val, count);\n        }\n        if (!this.root) {\n            this._setRoot(newNode);\n            this._setSize(this.size + 1);\n            newNode && this._setCount(this.count + newNode.count);\n            inserted = this.root;\n        }\n        else {\n            let cur = this.root;\n            let traversing = true;\n            while (traversing) {\n                if (cur) {\n                    if (newNode) {\n                        if (this._compare(cur.key, newNode.key) === CP.eq) {\n                            cur.val = newNode.val;\n                            cur.count += newNode.count;\n                            this._setCount(this.count + newNode.count);\n                            traversing = false;\n                            inserted = cur;\n                        }\n                        else if (this._compare(cur.key, newNode.key) === CP.gt) {\n                            // Traverse left of the node\n                            if (cur.left === undefined) {\n                                //Add to the left of the current node\n                                cur.left = newNode;\n                                this._setSize(this.size + 1);\n                                this._setCount(this.count + newNode.count);\n                                traversing = false;\n                                inserted = cur.left;\n                            }\n                            else {\n                                //Traverse the left of the current node\n                                if (cur.left)\n                                    cur = cur.left;\n                            }\n                        }\n                        else if (this._compare(cur.key, newNode.key) === CP.lt) {\n                            // Traverse right of the node\n                            if (cur.right === undefined) {\n                                //Add to the right of the current node\n                                cur.right = newNode;\n                                this._setSize(this.size + 1);\n                                this._setCount(this.count + newNode.count);\n                                traversing = false;\n                                inserted = cur.right;\n                            }\n                            else {\n                                //Traverse the left of the current node\n                                if (cur.right)\n                                    cur = cur.right;\n                            }\n                        }\n                    }\n                    else {\n                        // TODO may need to support null inserted\n                    }\n                }\n                else {\n                    traversing = false;\n                }\n            }\n        }\n        if (inserted)\n            this._balancePath(inserted);\n        return inserted;\n    }\n    /**\n     * The function adds a new node to a binary tree if there is an available slot on the left or right side of the parent\n     * node.\n     * @param {N | null} newNode - The `newNode` parameter represents the node that needs to be added to the tree. It can\n     * be either a node object (`N`) or `null`.\n     * @param {N} parent - The `parent` parameter represents the parent node to which the new node will be added as a\n     * child.\n     * @returns The method returns either the `parent.left`, `parent.right`, or `undefined`.\n     */\n    _addTo(newNode, parent) {\n        if (parent) {\n            if (parent.left === undefined) {\n                parent.left = newNode;\n                if (newNode !== null) {\n                    this._setSize(this.size + 1);\n                    this._setCount(this.count + newNode.count);\n                }\n                return parent.left;\n            }\n            else if (parent.right === undefined) {\n                parent.right = newNode;\n                if (newNode !== null) {\n                    this._setSize(this.size + 1);\n                    this._setCount(this.count + newNode.count);\n                }\n                return parent.right;\n            }\n            else {\n                return;\n            }\n        }\n        else {\n            return;\n        }\n    }\n    /**\n     * The `addMany` function takes an array of node IDs or nodes and adds them to the tree multiset, returning an array of\n     * the inserted nodes.\n     * @param {(BinaryTreeNodeKey | null)[] | (N | null)[]} keysOrNodes - An array of BinaryTreeNodeKey or BinaryTreeNode\n     * objects, or null values.\n     * @param {N['val'][]} [data] - The `data` parameter is an optional array of values (`N['val'][]`) that corresponds to\n     * the nodes being added. It is used when adding nodes using the `keyOrNode` and `data` arguments in the `this.add()`\n     * method. If provided, the `data` array should\n     * @returns The function `addMany` returns an array of `N`, `null`, or `undefined` values.\n     */\n    addMany(keysOrNodes, data) {\n        const inserted = [];\n        for (let i = 0; i < keysOrNodes.length; i++) {\n            const keyOrNode = keysOrNodes[i];\n            if (keyOrNode instanceof TreeMultisetNode) {\n                inserted.push(this.add(keyOrNode.key, keyOrNode.val, keyOrNode.count));\n                continue;\n            }\n            if (keyOrNode === null) {\n                inserted.push(this.add(NaN, null, 0));\n                continue;\n            }\n            inserted.push(this.add(keyOrNode, data === null || data === void 0 ? void 0 : data[i], 1));\n        }\n        return inserted;\n    }\n    /**\n     * The `perfectlyBalance` function takes a binary tree, performs a depth-first search to sort the nodes, and then\n     * constructs a balanced binary search tree using either a recursive or iterative approach.\n     * @returns The function `perfectlyBalance()` returns a boolean value.\n     */\n    perfectlyBalance() {\n        const sorted = this.dfs('in', 'node'), n = sorted.length;\n        if (sorted.length < 1)\n            return false;\n        this.clear();\n        if (this.loopType === LoopType.RECURSIVE) {\n            const buildBalanceBST = (l, r) => {\n                if (l > r)\n                    return;\n                const m = l + Math.floor((r - l) / 2);\n                const midNode = sorted[m];\n                this.add(midNode.key, midNode.val, midNode.count);\n                buildBalanceBST(l, m - 1);\n                buildBalanceBST(m + 1, r);\n            };\n            buildBalanceBST(0, n - 1);\n            return true;\n        }\n        else {\n            const stack = [[0, n - 1]];\n            while (stack.length > 0) {\n                const popped = stack.pop();\n                if (popped) {\n                    const [l, r] = popped;\n                    if (l <= r) {\n                        const m = l + Math.floor((r - l) / 2);\n                        const midNode = sorted[m];\n                        this.add(midNode.key, midNode.val, midNode.count);\n                        stack.push([m + 1, r]);\n                        stack.push([l, m - 1]);\n                    }\n                }\n            }\n            return true;\n        }\n    }\n    /**\n     * The `remove` function removes a node from a binary search tree and returns the deleted node along with the parent\n     * node that needs to be balanced.\n     * @param {N | BinaryTreeNodeKey | null} nodeOrKey - The `nodeOrKey` parameter can be one of the following:\n     * @param {boolean} [ignoreCount] - The `ignoreCount` parameter is an optional boolean parameter that determines\n     * whether to ignore the count of the node being removed. If `ignoreCount` is set to `true`, the count of the node will\n     * not be taken into account when removing it. If `ignoreCount` is set to `false\n     * @returns The function `remove` returns an array of `BinaryTreeDeletedResult<N>` objects.\n     */\n    remove(nodeOrKey, ignoreCount = false) {\n        const bstDeletedResult = [];\n        if (!this.root)\n            return bstDeletedResult;\n        const curr = this.get(nodeOrKey);\n        if (!curr)\n            return bstDeletedResult;\n        const parent = (curr === null || curr === void 0 ? void 0 : curr.parent) ? curr.parent : null;\n        let needBalanced = null, orgCurrent = curr;\n        if (curr.count > 1 && !ignoreCount) {\n            curr.count--;\n            this._setCount(this.count - 1);\n        }\n        else {\n            if (!curr.left) {\n                if (!parent) {\n                    if (curr.right !== undefined)\n                        this._setRoot(curr.right);\n                }\n                else {\n                    const { familyPosition: fp } = curr;\n                    if (fp === FamilyPosition.LEFT || fp === FamilyPosition.ROOT_LEFT) {\n                        parent.left = curr.right;\n                    }\n                    else if (fp === FamilyPosition.RIGHT || fp === FamilyPosition.ROOT_RIGHT) {\n                        parent.right = curr.right;\n                    }\n                    needBalanced = parent;\n                }\n            }\n            else {\n                const leftSubTreeRightMost = curr.left ? this.getRightMost(curr.left) : null;\n                if (leftSubTreeRightMost) {\n                    const parentOfLeftSubTreeMax = leftSubTreeRightMost.parent;\n                    orgCurrent = this.swapLocation(curr, leftSubTreeRightMost);\n                    if (parentOfLeftSubTreeMax) {\n                        if (parentOfLeftSubTreeMax.right === leftSubTreeRightMost) {\n                            parentOfLeftSubTreeMax.right = leftSubTreeRightMost.left;\n                        }\n                        else {\n                            parentOfLeftSubTreeMax.left = leftSubTreeRightMost.left;\n                        }\n                        needBalanced = parentOfLeftSubTreeMax;\n                    }\n                }\n            }\n            this._setSize(this.size - 1);\n            // TODO How to handle when the count of target node is lesser than current node's count\n            this._setCount(this.count - orgCurrent.count);\n        }\n        bstDeletedResult.push({ deleted: orgCurrent, needBalanced });\n        if (needBalanced) {\n            this._balancePath(needBalanced);\n        }\n        return bstDeletedResult;\n    }\n    /**\n     * The function `getSubTreeCount` calculates the number of nodes and the sum of their counts in a subtree, using either\n     * recursive or iterative traversal.\n     * @param {N | null | undefined} subTreeRoot - The `subTreeRoot` parameter represents the root node of a subtree in a\n     * binary tree.\n     * @returns The function `getSubTreeCount` returns an array `[number, number]`.\n     */\n    getSubTreeCount(subTreeRoot) {\n        const res = [0, 0];\n        if (!subTreeRoot)\n            return res;\n        if (this.loopType === LoopType.RECURSIVE) {\n            const _traverse = (cur) => {\n                res[0]++;\n                res[1] += cur.count;\n                cur.left && _traverse(cur.left);\n                cur.right && _traverse(cur.right);\n            };\n            _traverse(subTreeRoot);\n            return res;\n        }\n        else {\n            const stack = [subTreeRoot];\n            while (stack.length > 0) {\n                const cur = stack.pop();\n                res[0]++;\n                res[1] += cur.count;\n                cur.right && stack.push(cur.right);\n                cur.left && stack.push(cur.left);\n            }\n            return res;\n        }\n    }\n    /**\n     * The function `subTreeSumCount` calculates the sum of the `count` property of each node in a subtree, either\n     * recursively or iteratively.\n     * @param {N | BinaryTreeNodeKey | null} subTreeRoot - The `subTreeRoot` parameter represents the root node of a subtree\n     * in a binary tree. It can be either a `BinaryTreeNodeKey` (a unique identifier for a node in the binary tree) or\n     * `null` if the subtree is empty.\n     * @returns the sum of the count values of all nodes in the subtree rooted at `subTreeRoot`.\n     */\n    subTreeSumCount(subTreeRoot) {\n        if (typeof subTreeRoot === 'number')\n            subTreeRoot = this.get(subTreeRoot, 'key');\n        if (!subTreeRoot)\n            return 0;\n        let sum = 0;\n        if (this.loopType === LoopType.RECURSIVE) {\n            const _traverse = (cur) => {\n                sum += cur.count;\n                cur.left && _traverse(cur.left);\n                cur.right && _traverse(cur.right);\n            };\n            _traverse(subTreeRoot);\n        }\n        else {\n            const stack = [subTreeRoot];\n            while (stack.length > 0) {\n                const cur = stack.pop();\n                sum += cur.count;\n                cur.right && stack.push(cur.right);\n                cur.left && stack.push(cur.left);\n            }\n        }\n        return sum;\n    }\n    /**\n     * The function `subTreeAddCount` recursively or iteratively traverses a binary tree and adds a given delta value to\n     * the `count` property of each node.\n     * @param {N | BinaryTreeNodeKey | null} subTreeRoot - The `subTreeRoot` parameter represents the root node of a subtree\n     * in a binary tree. It can be either a `BinaryTreeNodeKey` (a unique identifier for a node in the binary tree), a\n     * `BinaryTreeNode` object, or `null` if the subtree is empty.\n     * @param {number} delta - The delta parameter is a number that represents the amount by which the count of each node\n     * in the subtree should be increased or decreased.\n     * @returns a boolean value.\n     */\n    subTreeAddCount(subTreeRoot, delta) {\n        if (typeof subTreeRoot === 'number')\n            subTreeRoot = this.get(subTreeRoot, 'key');\n        if (!subTreeRoot)\n            return false;\n        const _addByProperty = (cur) => {\n            cur.count += delta;\n            this._setCount(this.count + delta);\n        };\n        if (this.loopType === LoopType.RECURSIVE) {\n            const _traverse = (cur) => {\n                _addByProperty(cur);\n                cur.left && _traverse(cur.left);\n                cur.right && _traverse(cur.right);\n            };\n            _traverse(subTreeRoot);\n        }\n        else {\n            const stack = [subTreeRoot];\n            while (stack.length > 0) {\n                const cur = stack.pop();\n                _addByProperty(cur);\n                cur.right && stack.push(cur.right);\n                cur.left && stack.push(cur.left);\n            }\n        }\n        return true;\n    }\n    /**\n     * The function `getNodesByCount` returns an array of nodes that have a specific count property, either recursively or\n     * using a queue.\n     * @param {BinaryTreeNodeKey | N} nodeProperty - The `nodeProperty` parameter can be either a `BinaryTreeNodeKey` or a\n     * `N`. It represents the property of the nodes that you want to search for.\n     * @param {boolean} [onlyOne] - The `onlyOne` parameter is an optional boolean parameter that determines whether to\n     * return only one node that matches the `nodeProperty` or all nodes that match the `nodeProperty`. If `onlyOne` is set\n     * to `true`, the function will return only one node. If `onlyOne`\n     * @returns an array of nodes that match the given nodeProperty.\n     */\n    getNodesByCount(nodeProperty, onlyOne = false) {\n        if (!this.root)\n            return [];\n        const result = [];\n        if (this.loopType === LoopType.RECURSIVE) {\n            const _traverse = (cur) => {\n                if (cur.count === nodeProperty) {\n                    result.push(cur);\n                    if (onlyOne)\n                        return;\n                }\n                if (!cur.left && !cur.right)\n                    return;\n                cur.left && _traverse(cur.left);\n                cur.right && _traverse(cur.right);\n            };\n            _traverse(this.root);\n        }\n        else {\n            const queue = [this.root];\n            while (queue.length > 0) {\n                const cur = queue.shift();\n                if (cur) {\n                    if (cur.count === nodeProperty) {\n                        result.push(cur);\n                        if (onlyOne)\n                            return result;\n                    }\n                    cur.left && queue.push(cur.left);\n                    cur.right && queue.push(cur.right);\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * The BFSCount function returns an array of counts from a breadth-first search of nodes.\n     * @returns The BFSCount() function returns an array of numbers, specifically the count property of each node in the\n     * bfs traversal.\n     */\n    BFSCount() {\n        const nodes = super.bfs('node');\n        return nodes.map(node => node.count);\n    }\n    /**\n     * The function \"listLevelsCount\" takes a node and returns an array of arrays, where each inner array contains the\n     * count property of each node at that level.\n     * @param {N | null} node - The parameter `node` is of type `N | null`. This means that it can either be an instance of\n     * the class `N` or `null`.\n     * @returns a 2D array of numbers. Each inner array represents a level in the binary tree, and each number in the inner\n     * array represents the count property of a node in that level.\n     */\n    listLevelsCount(node) {\n        const levels = super.listLevels(node, 'node');\n        return levels.map(level => level.map(node => node.count));\n    }\n    /**\n     * The `morrisCount` function returns an array of counts for each node in a binary tree, based on a specified traversal\n     * pattern.\n     * @param {'in' | 'pre' | 'post'} [pattern] - The `pattern` parameter is an optional parameter that specifies the\n     * traversal pattern for the Morris traversal algorithm. It can have one of three values: 'in', 'pre', or 'post'.\n     * @returns The function `morrisCount` returns an array of numbers.\n     */\n    morrisCount(pattern = 'in') {\n        const nodes = super.morris(pattern, 'node');\n        return nodes.map(node => node.count);\n    }\n    /**\n     * The function dfsCountIterative performs an iterative depth-first search and returns an array of node counts based on\n     * the specified traversal pattern.\n     * @param {'in' | 'pre' | 'post'} [pattern] - The pattern parameter is a string that specifies the traversal order for\n     * the Depth-First Search (dfs) algorithm. It can have three possible values: 'in', 'pre', or 'post'.\n     * @returns The dfsCountIterative function returns an array of numbers, which represents the count property of each node\n     * in the dfs traversal.\n     */\n    dfsCountIterative(pattern = 'in') {\n        const nodes = super.dfsIterative(pattern, 'node');\n        return nodes.map(node => node.count);\n    }\n    /**\n     * The dfsCount function returns an array of counts for each node in a depth-first search traversal.\n     * @param {DFSOrderPattern} [pattern] - The pattern parameter is an optional parameter that specifies the order in which\n     * the Depth-First Search (dfs) algorithm should traverse the nodes. It can have one of the following values:\n     * @returns The dfsCount function returns an array of numbers, specifically the count property of each node in the dfs\n     * traversal.\n     */\n    dfsCount(pattern = 'in') {\n        const nodes = super.dfs(pattern, 'node');\n        return nodes.map(node => node.count);\n    }\n    /**\n     * The `lesserSumCount` function calculates the sum of the counts of all nodes in a binary tree that have a lesser\n     * value than a given node.\n     * @param {N | BinaryTreeNodeKey | null} beginNode - The `beginNode` parameter can be one of the following:\n     * @returns the sum of the counts of nodes in the binary tree that have a lesser value than the given beginNode.\n     */\n    lesserSumCount(beginNode) {\n        if (typeof beginNode === 'number')\n            beginNode = this.get(beginNode, 'key');\n        if (!beginNode)\n            return 0;\n        if (!this.root)\n            return 0;\n        const key = beginNode.key;\n        let sum = 0;\n        if (this.loopType === LoopType.RECURSIVE) {\n            const _traverse = (cur) => {\n                const compared = this._compare(cur.key, key);\n                if (compared === CP.eq) {\n                    if (cur.right)\n                        sum += this.subTreeSumCount(cur.right);\n                    return;\n                }\n                else if (compared === CP.lt) {\n                    if (cur.left)\n                        sum += this.subTreeSumCount(cur.left);\n                    sum += cur.count;\n                    if (cur.right)\n                        _traverse(cur.right);\n                    else\n                        return;\n                }\n                else {\n                    if (cur.left)\n                        _traverse(cur.left);\n                    else\n                        return;\n                }\n            };\n            _traverse(this.root);\n        }\n        else {\n            const queue = [this.root];\n            while (queue.length > 0) {\n                const cur = queue.shift();\n                if (cur) {\n                    const compared = this._compare(cur.key, key);\n                    if (compared === CP.eq) {\n                        if (cur.right)\n                            sum += this.subTreeSumCount(cur.right);\n                        return sum;\n                    }\n                    else if (compared === CP.lt) {\n                        // todo maybe a bug\n                        if (cur.left)\n                            sum += this.subTreeSumCount(cur.left);\n                        sum += cur.count;\n                        if (cur.right)\n                            queue.push(cur.right);\n                        else\n                            return sum;\n                    }\n                    else {\n                        if (cur.left)\n                            queue.push(cur.left);\n                        else\n                            return sum;\n                    }\n                }\n            }\n        }\n        return sum;\n    }\n    /**\n     * The function `allGreaterNodesAddCount` updates the count property of all nodes in a binary tree that have an ID\n     * greater than a given ID by a specified delta value.\n     * @param {N | BinaryTreeNodeKey | null} node - The `node` parameter can be one of the following:\n     * @param {number} delta - The `delta` parameter is a number that represents the amount by which the `count` property\n     * of each node should be increased.\n     * @returns a boolean value.\n     */\n    allGreaterNodesAddCount(node, delta) {\n        if (typeof node === 'number')\n            node = this.get(node, 'key');\n        if (!node)\n            return false;\n        const key = node.key;\n        if (!this.root)\n            return false;\n        if (this.loopType === LoopType.RECURSIVE) {\n            const _traverse = (cur) => {\n                const compared = this._compare(cur.key, key);\n                if (compared === CP.gt)\n                    cur.count += delta;\n                if (!cur.left && !cur.right)\n                    return;\n                if (cur.left && this._compare(cur.left.key, key) === CP.gt)\n                    _traverse(cur.left);\n                if (cur.right && this._compare(cur.right.key, key) === CP.gt)\n                    _traverse(cur.right);\n            };\n            _traverse(this.root);\n            return true;\n        }\n        else {\n            const queue = [this.root];\n            while (queue.length > 0) {\n                const cur = queue.shift();\n                if (cur) {\n                    const compared = this._compare(cur.key, key);\n                    if (compared === CP.gt)\n                        cur.count += delta;\n                    if (cur.left && this._compare(cur.left.key, key) === CP.gt)\n                        queue.push(cur.left);\n                    if (cur.right && this._compare(cur.right.key, key) === CP.gt)\n                        queue.push(cur.right);\n                }\n            }\n            return true;\n        }\n    }\n    /**\n     * The clear() function clears the data and sets the count to 0.\n     */\n    clear() {\n        super.clear();\n        this._setCount(0);\n    }\n    /**\n     * The function \"_setCount\" is used to set the value of the \"_count\" property.\n     * @param {number} v - number\n     */\n    _setCount(v) {\n        this._count = v;\n    }\n}\n","export class TreeNode {\n    constructor(key, value, children) {\n        this._key = key;\n        this._value = value || undefined;\n        this._children = children || [];\n    }\n    get key() {\n        return this._key;\n    }\n    set key(value) {\n        this._key = value;\n    }\n    get value() {\n        return this._value;\n    }\n    set value(value) {\n        this._value = value;\n    }\n    get children() {\n        return this._children;\n    }\n    set children(value) {\n        this._children = value;\n    }\n    addChildren(children) {\n        if (!this.children) {\n            this.children = [];\n        }\n        if (children instanceof TreeNode) {\n            this.children.push(children);\n        }\n        else {\n            this.children = this.children.concat(children);\n        }\n    }\n    getHeight() {\n        let maxDepth = 0;\n        if (this) {\n            const bfs = (node, level) => {\n                if (level > maxDepth) {\n                    maxDepth = level;\n                }\n                const { children } = node;\n                if (children) {\n                    for (let i = 0, len = children.length; i < len; i++) {\n                        bfs(children[i], level + 1);\n                    }\n                }\n            };\n            bfs(this, 0);\n        }\n        return maxDepth;\n    }\n}\n","/**\n * data-structure-typed\n *\n * @author Kirk Qi\n * @copyright Copyright (c) 2022 Kirk Qi <qilinaus@gmail.com>\n * @license MIT License\n */\nimport { Heap } from './heap';\nexport class MaxHeap extends Heap {\n    constructor(comparator = (a, b) => {\n        if (!(typeof a === 'number' && typeof b === 'number')) {\n            throw new Error('The a, b params of compare function must be number');\n        }\n        else {\n            return b - a;\n        }\n    }) {\n        super(comparator);\n    }\n}\n","/**\n * data-structure-typed\n *\n * @author Kirk Qi\n * @copyright Copyright (c) 2022 Kirk Qi <qilinaus@gmail.com>\n * @license MIT License\n */\nimport { Heap } from './heap';\nexport class MinHeap extends Heap {\n    constructor(comparator = (a, b) => {\n        if (!(typeof a === 'number' && typeof b === 'number')) {\n            throw new Error('The a, b params of compare function must be number');\n        }\n        else {\n            return a - b;\n        }\n    }) {\n        super(comparator);\n    }\n}\n","/**\n * data-structure-typed\n *\n * @author Kirk Qi\n * @copyright Copyright (c) 2022 Kirk Qi <qilinaus@gmail.com>\n * @license MIT License\n */\nimport { PriorityQueue } from './priority-queue';\nexport class MinPriorityQueue extends PriorityQueue {\n    constructor(compare = (a, b) => {\n        if (!(typeof a === 'number' && typeof b === 'number')) {\n            throw new Error('The a, b params of compare function must be number');\n        }\n        else {\n            return a - b;\n        }\n    }) {\n        super(compare);\n    }\n}\n","/**\n * data-structure-typed\n *\n * @author Kirk Qi\n * @copyright Copyright (c) 2022 Kirk Qi <qilinaus@gmail.com>\n * @license MIT License\n */\nimport { PriorityQueue } from './priority-queue';\nexport class MaxPriorityQueue extends PriorityQueue {\n    constructor(compare = (a, b) => {\n        if (!(typeof a === 'number' && typeof b === 'number')) {\n            throw new Error('The a, b params of compare function must be number');\n        }\n        else {\n            return b - a;\n        }\n    }) {\n        super(compare);\n    }\n}\n","/**\n * data-structure-typed\n *\n * @author Tyler Zeng\n * @copyright Copyright (c) 2022 Tyler Zeng <zrwusa@gmail.com>\n * @license MIT License\n */\n// todo need to be improved\nexport class MatrixNTI2D {\n    /**\n     * The constructor creates a matrix with the specified number of rows and columns, and initializes all elements to a\n     * given initial value or 0 if not provided.\n     * @param options - An object containing the following properties:\n     */\n    constructor(options) {\n        const { row, col, initialVal } = options;\n        this._matrix = new Array(row).fill(undefined).map(() => new Array(col).fill(initialVal || 0));\n    }\n    /* The `toArray` method returns the matrix as a two-dimensional array. It converts the internal representation of the\n    matrix, which is an array of arrays, into a format that is more commonly used in JavaScript. */\n    toArray() {\n        return this._matrix;\n    }\n}\n","/**\n * data-structure-typed\n *\n * @author Tyler Zeng\n * @copyright Copyright (c) 2022 Tyler Zeng <zrwusa@gmail.com>\n * @license MIT License\n */\nexport class Vector2D {\n    constructor(x = 0, y = 0, w = 1 // needed for matrix multiplication\n    ) {\n        this.x = x;\n        this.y = y;\n        this.w = w;\n    }\n    /**\n     * The function checks if the x and y values of a point are both zero.\n     * @returns A boolean value indicating whether both the x and y properties of the object are equal to 0.\n     */\n    get isZero() {\n        return this.x === 0 && this.y === 0;\n    }\n    /**\n     * The above function calculates the length of a vector using the Pythagorean theorem.\n     * @returns The length of a vector, calculated using the Pythagorean theorem.\n     */\n    get length() {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n    }\n    /**\n     * The function calculates the square of the length of a vector.\n     * @returns The method is returning the sum of the squares of the x and y values.\n     */\n    get lengthSq() {\n        return this.x * this.x + this.y * this.y;\n    }\n    /**\n     * The \"rounded\" function returns a new Vector2D object with the x and y values rounded to the nearest whole number.\n     * @returns The method is returning a new instance of the Vector2D class with the x and y values rounded to the nearest\n     * whole number.\n     */\n    get rounded() {\n        return new Vector2D(Math.round(this.x), Math.round(this.y));\n    }\n    /**\n     * The function \"add\" takes two Vector2D objects as parameters and returns a new Vector2D object with the sum of their\n     * x and y components.\n     * @param {Vector2D} vector1 - The parameter `vector1` is an instance of the `Vector2D` class. It represents a\n     * 2-dimensional vector with an `x` and `y` component.\n     * @param {Vector2D} vector2 - The parameter \"vector2\" is of type Vector2D. It represents a 2-dimensional vector with\n     * an x and y component.\n     * @returns The method is returning a new instance of the Vector2D class with the x and y components of the two input\n     * vectors added together.\n     */\n    static add(vector1, vector2) {\n        return new Vector2D(vector1.x + vector2.x, vector1.y + vector2.y);\n    }\n    /**\n     * The subtract function takes two Vector2D objects as parameters and returns a new Vector2D object with the x and y\n     * components subtracted.\n     * @param {Vector2D} vector1 - The parameter `vector1` is an instance of the `Vector2D` class, representing a\n     * 2-dimensional vector. It has properties `x` and `y` which represent the x and y components of the vector\n     * respectively.\n     * @param {Vector2D} vector2 - The parameter \"vector2\" is a Vector2D object. It represents the second vector that you\n     * want to subtract from the first vector.\n     * @returns The method is returning a new Vector2D object with the x and y components subtracted from vector1 and\n     * vector2.\n     */\n    static subtract(vector1, vector2) {\n        return new Vector2D(vector1.x - vector2.x, vector1.y - vector2.y);\n    }\n    /**\n     * The function subtracts a given value from the x and y components of a Vector2D object and returns a new Vector2D\n     * object.\n     * @param {Vector2D} vector - The parameter \"vector\" is of type Vector2D, which represents a 2-dimensional vector with\n     * x and y components.\n     * @param {number} value - The \"value\" parameter is a number that will be subtracted from both the x and y components\n     * of the \"vector\" parameter.\n     * @returns A new Vector2D object with the x and y values subtracted by the given value.\n     */\n    static subtractValue(vector, value) {\n        return new Vector2D(vector.x - value, vector.y - value);\n    }\n    /**\n     * The function multiplies a Vector2D object by a given value.\n     * @param {Vector2D} vector - The parameter \"vector\" is of type Vector2D, which represents a 2-dimensional vector with\n     * x and y components.\n     * @param {number} value - The \"value\" parameter is a number that represents the value by which the x and y components\n     * of the vector will be multiplied.\n     * @returns A new Vector2D object with the x and y values multiplied by the given value.\n     */\n    static multiply(vector, value) {\n        return new Vector2D(vector.x * value, vector.y * value);\n    }\n    /**\n     * The function divides the x and y components of a Vector2D by a given value and returns a new Vector2D.\n     * @param {Vector2D} vector - The parameter \"vector\" is of type Vector2D, which represents a 2-dimensional vector with\n     * x and y components.\n     * @param {number} value - The value parameter is a number that will be used to divide the x and y components of the\n     * vector.\n     * @returns A new instance of the Vector2D class with the x and y values divided by the given value.\n     */\n    static divide(vector, value) {\n        return new Vector2D(vector.x / value, vector.y / value);\n    }\n    /**\n     * The function checks if two Vector2D objects are equal by comparing their x and y values.\n     * @param {Vector2D} vector1 - The parameter `vector1` is of type `Vector2D`, which represents a 2-dimensional vector.\n     * It has two properties: `x` and `y`, which represent the x and y components of the vector, respectively.\n     * @param {Vector2D} vector2 - The parameter \"vector2\" is of type Vector2D.\n     * @returns a boolean value, which indicates whether the two input vectors are equal or not.\n     */\n    static equals(vector1, vector2) {\n        return vector1.x === vector2.x && vector1.y === vector2.y;\n    }\n    /**\n     * The function checks if two Vector2D objects are equal within a specified rounding factor.\n     * @param {Vector2D} vector1 - The first vector to compare.\n     * @param {Vector2D} vector2 - The parameter \"vector2\" is a Vector2D object, which represents a 2-dimensional vector.\n     * It is used as one of the inputs for the \"equalsRounded\" function.\n     * @param [roundingFactor=12] - The roundingFactor parameter is used to determine the threshold for considering two\n     * vectors as equal. If the absolute difference in the x and y components of the vectors is less than the\n     * roundingFactor, the vectors are considered equal.\n     * @returns a boolean value.\n     */\n    static equalsRounded(vector1, vector2, roundingFactor = 12) {\n        const vector = Vector2D.abs(Vector2D.subtract(vector1, vector2));\n        if (vector.x < roundingFactor && vector.y < roundingFactor) {\n            return true;\n        }\n        return false;\n    }\n    /**\n     * The normalize function takes a vector as input and returns a normalized version of the vector.Normalizes the vector if it matches a certain condition\n     * @param {Vector2D} vector - The parameter \"vector\" is of type Vector2D.\n     * @returns the normalized vector if its length is greater than a very small value (epsilon), otherwise it returns the\n     * original vector.\n     */\n    static normalize(vector) {\n        const length = vector.length;\n        if (length > 2.220446049250313e-16) {\n            // Epsilon\n            return Vector2D.divide(vector, length);\n        }\n        return vector;\n    }\n    /**\n     * The function truncates a vector to a maximum length if it exceeds that length.Adjusts x and y so that the length of the vector does not exceed max\n     * @param {Vector2D} vector - A 2D vector represented by the Vector2D class.\n     * @param {number} max - The `max` parameter is a number that represents the maximum length that the `vector` should\n     * have.\n     * @returns either the original vector or a truncated version of the vector, depending on whether the length of the\n     * vector is greater than the maximum value specified.\n     */\n    static truncate(vector, max) {\n        if (vector.length > max) {\n            return Vector2D.multiply(Vector2D.normalize(vector), max);\n        }\n        return vector;\n    }\n    /**\n     * The function returns a new Vector2D object that is perpendicular to the input vector.The vector that is perpendicular to this one\n     * @param {Vector2D} vector - The parameter \"vector\" is of type Vector2D.\n     * @returns A new Vector2D object is being returned.\n     */\n    static perp(vector) {\n        return new Vector2D(-vector.y, vector.x);\n    }\n    /**\n     * The reverse function takes a Vector2D object and returns a new Vector2D object with the negated x and y values.\n     * @param {Vector2D} vector - The parameter \"vector\" is of type Vector2D, which represents a 2-dimensional vector. It\n     * has two properties: \"x\" and \"y\", which represent the x and y components of the vector, respectively.\n     * @returns A new Vector2D object with the negated x and y values of the input vector. Returns the vector that is the reverse of this vector\n     */\n    static reverse(vector) {\n        return new Vector2D(-vector.x, -vector.y);\n    }\n    /**\n     * The function takes a Vector2D object as input and returns a new Vector2D object with the absolute values of its x\n     * and y components.\n     * @param {Vector2D} vector - The parameter \"vector\" is of type Vector2D, which represents a 2-dimensional vector. It\n     * has two properties: \"x\" and \"y\", which represent the x and y components of the vector, respectively.\n     * @returns The method is returning a new Vector2D object with the absolute values of the x and y components of the\n     * input vector.\n     */\n    static abs(vector) {\n        return new Vector2D(Math.abs(vector.x), Math.abs(vector.y));\n    }\n    /**\n     * The dot function calculates the dot product of two 2D vectors.The dot product of v1 and v2\n     * @param {Vector2D} vector1 - The parameter `vector1` represents a 2D vector with its x and y components.\n     * @param {Vector2D} vector2 - The \"vector2\" parameter is a Vector2D object. It represents a two-dimensional vector\n     * with an x and y component.\n     * @returns The dot product of the two input vectors.\n     */\n    static dot(vector1, vector2) {\n        return vector1.x * vector2.x + vector1.y * vector2.y;\n    }\n    // /**\n    //  * Transform vectors based on the current tranformation matrices: translation, rotation and scale\n    //  * @param vectors The vectors to transform\n    //  */\n    // static transform(vector: Vector2D, transformation: Matrix2D): Vector2D {\n    //     return Matrix2D.multiplyByVector(transformation, vector)\n    // }\n    // /**\n    //  * Transform vectors based on the current tranformation matrices: translation, rotation and scale\n    //  * @param vectors The vectors to transform\n    //  */\n    // static transformList(vectors: Vector2D[], transformation: Matrix2D): Vector2D[] {\n    //     return vectors.map(vector => Matrix2D.multiplyByVector(transformation, vector))\n    // }\n    /**\n     * The function calculates the distance between two points in a two-dimensional space.\n     * @param {Vector2D} vector1 - The parameter `vector1` represents the first vector in 2D space, while `vector2`\n     * represents the second vector. Each vector has an `x` and `y` component, which represent their respective coordinates\n     * in the 2D space.\n     * @param {Vector2D} vector2 - The `vector2` parameter represents the second vector in the calculation of distance. It\n     * is an instance of the `Vector2D` class, which typically has properties `x` and `y` representing the coordinates of\n     * the vector in a 2D space.\n     * @returns The distance between vector1 and vector2.\n     */\n    static distance(vector1, vector2) {\n        const ySeparation = vector2.y - vector1.y;\n        const xSeparation = vector2.x - vector1.x;\n        return Math.sqrt(ySeparation * ySeparation + xSeparation * xSeparation);\n    }\n    /**\n     * The function calculates the squared distance between two 2D vectors.\n     * @param {Vector2D} vector1 - The parameter `vector1` represents the first vector, which is an instance of the\n     * `Vector2D` class. It contains the x and y coordinates of the vector.\n     * @param {Vector2D} vector2 - The `vector2` parameter represents the second vector in a two-dimensional space. It has\n     * properties `x` and `y` which represent the coordinates of the vector.\n     * @returns the square of the distance between the two input vectors.\n     */\n    static distanceSq(vector1, vector2) {\n        const ySeparation = vector2.y - vector1.y;\n        const xSeparation = vector2.x - vector1.x;\n        return ySeparation * ySeparation + xSeparation * xSeparation;\n    }\n    /**\n     * The sign function determines the sign of the cross product between two 2D vectors.\n     * (assuming the Y axis is pointing down, X axis to right like a Window app)\n     * @param {Vector2D} vector1 - The parameter `vector1` is of type `Vector2D`, which represents a 2-dimensional vector.\n     * It likely has properties `x` and `y` representing the x and y components of the vector, respectively.\n     * @param {Vector2D} vector2 - The above code defines a function called \"sign\" that takes two parameters: vector1 and\n     * vector2. Both vector1 and vector2 are of type Vector2D.\n     * @returns either -1 or 1. Returns positive if v2 is clockwise of this vector, negative if counterclockwise\n     */\n    static sign(vector1, vector2) {\n        if (vector1.y * vector2.x > vector1.x * vector2.y) {\n            return -1;\n        }\n        return 1;\n    }\n    /**\n     * The function calculates the angle between a given vector and the negative y-axis.\n     * @param {Vector2D} vector - The \"vector\" parameter is an instance of the Vector2D class, which represents a\n     * 2-dimensional vector. It has two properties: \"x\" and \"y\", which represent the x and y components of the vector,\n     * respectively.\n     * @returns the angle between the given vector and the vector (0, -1) in radians.Returns the angle between origin and the given vector in radians\n     */\n    static angle(vector) {\n        const origin = new Vector2D(0, -1);\n        const radian = Math.acos(Vector2D.dot(vector, origin) / (vector.length * origin.length));\n        return Vector2D.sign(vector, origin) === 1 ? Math.PI * 2 - radian : radian;\n    }\n    /**\n     * The function \"random\" generates a random Vector2D object with x and y values within the specified range.\n     * @param {number} maxX - The maxX parameter represents the maximum value for the x-coordinate of the random vector.\n     * @param {number} maxY - The `maxY` parameter represents the maximum value for the y-coordinate of the generated\n     * random vector.\n     * @returns a new instance of the Vector2D class with random x and y values.\n     */\n    static random(maxX, maxY) {\n        const randX = Math.floor(Math.random() * maxX - maxX / 2);\n        const randY = Math.floor(Math.random() * maxY - maxY / 2);\n        return new Vector2D(randX, randY);\n    }\n    /**\n     * The function sets the values of x and y to zero.\n     */\n    zero() {\n        this.x = 0;\n        this.y = 0;\n    }\n}\nexport default Vector2D;\n","/**\n * data-structure-typed\n *\n * @author Tyler Zeng\n * @copyright Copyright (c) 2022 Tyler Zeng <zrwusa@gmail.com>\n * @license MIT License\n */\nimport Vector2D from './vector2d';\nexport class Matrix2D {\n    /**\n     * The constructor function initializes a Matrix2D object with either a default identity matrix, or a provided matrix\n     * or Vector2D object.\n     * @param {number[][] | Vector2D} [value] - The `value` parameter can be either a 2D array of numbers (`number[][]`) or\n     * an instance of the `Vector2D` class.\n     */\n    constructor(value) {\n        if (typeof value === 'undefined') {\n            this._matrix = Matrix2D.identity;\n        }\n        else if (value instanceof Vector2D) {\n            this._matrix = Matrix2D.identity;\n            this._matrix[0][0] = value.x;\n            this._matrix[1][0] = value.y;\n            this._matrix[2][0] = value.w;\n        }\n        else {\n            this._matrix = value;\n        }\n    }\n    /**\n     * The function returns a 2D array with three empty arrays.\n     * @returns An empty 2-dimensional array with 3 empty arrays inside.\n     */\n    static get empty() {\n        return [[], [], []];\n    }\n    /**\n     * The above function returns a 3x3 identity matrix.\n     * @returns The method is returning a 2-dimensional array of numbers representing the identity matrix.\n     */\n    static get identity() {\n        return [\n            [1, 0, 0],\n            [0, 1, 0],\n            [0, 0, 1]\n        ];\n    }\n    /**\n     * The function returns a two-dimensional array of numbers.\n     * @returns The getter method is returning the value of the private variable `_matrix`, which is a two-dimensional\n     * array of numbers.\n     */\n    get m() {\n        return this._matrix;\n    }\n    /**\n     * The function \"toVector\" returns a new Vector2D object with the values from the first and second elements of the\n     * _matrix array.\n     * @returns A new instance of the Vector2D class is being returned. The values of the returned vector are taken from\n     * the first column of the matrix.\n     */\n    toVector() {\n        return new Vector2D(this._matrix[0][0], this._matrix[1][0]);\n    }\n    /**\n     * The function takes two 2D matrices as input and returns their sum as a new 2D matrix.\n     * @param {Matrix2D} matrix1 - Matrix2D - The first matrix to be added.\n     * @param {Matrix2D} matrix2 - The parameter `matrix2` is a Matrix2D object.\n     * @returns a new instance of the Matrix2D class, which is created using the result array.\n     */\n    static add(matrix1, matrix2) {\n        const result = Matrix2D.empty;\n        for (let i = 0; i < 3; i++) {\n            for (let j = 0; j < 3; j++) {\n                result[i][j] = matrix1.m[i][j] + matrix2.m[i][j];\n            }\n        }\n        return new Matrix2D(result);\n    }\n    /**\n     * The function subtracts two 2D matrices and returns the result as a new Matrix2D object.\n     * @param {Matrix2D} matrix1 - Matrix2D - The first matrix to subtract from.\n     * @param {Matrix2D} matrix2 - Matrix2D is a class representing a 2D matrix. It has a property `m` which is a 2D array\n     * representing the matrix elements.\n     * @returns a new instance of the Matrix2D class, which is created using the result array.\n     */\n    static subtract(matrix1, matrix2) {\n        const result = Matrix2D.empty;\n        for (let i = 0; i < 3; i++) {\n            for (let j = 0; j < 3; j++) {\n                result[i][j] = matrix1.m[i][j] - matrix2.m[i][j];\n            }\n        }\n        return new Matrix2D(result);\n    }\n    /**\n     * The function multiplies two 2D matrices and returns the result as a new Matrix2D object.\n     * @param {Matrix2D} matrix1 - A 2D matrix represented by the Matrix2D class.\n     * @param {Matrix2D} matrix2 - The parameter `matrix2` is a 2D matrix of size 3x3.\n     * @returns a new instance of the Matrix2D class, created using the result array.\n     */\n    static multiply(matrix1, matrix2) {\n        const result = Matrix2D.empty;\n        for (let i = 0; i < 3; i++) {\n            for (let j = 0; j < 3; j++) {\n                result[i][j] = 0;\n                for (let k = 0; k < 3; k++) {\n                    result[i][j] += matrix1.m[i][k] * matrix2.m[k][j];\n                }\n            }\n        }\n        return new Matrix2D(result);\n    }\n    /**\n     * The function multiplies each element of a 2D matrix by a given value and returns the resulting matrix.\n     * @param {Matrix2D} matrix - The `matrix` parameter is an instance of the `Matrix2D` class, which represents a 2D\n     * matrix. It contains a property `m` that is a 2D array representing the matrix elements.\n     * @param {number} value - The `value` parameter is a number that you want to multiply each element of the `matrix` by.\n     * @returns a new instance of the Matrix2D class, which is created using the result array.\n     */\n    static multiplyByValue(matrix, value) {\n        const result = Matrix2D.empty;\n        for (let i = 0; i < 3; i++) {\n            for (let j = 0; j < 3; j++) {\n                result[i][j] = matrix.m[i][j] * value;\n            }\n        }\n        return new Matrix2D(result);\n    }\n    /**\n     * The function multiplies a 2D matrix by a 2D vector and returns the result as a 2D vector.\n     * @param {Matrix2D} matrix - The parameter \"matrix\" is of type Matrix2D. It represents a 2-dimensional matrix.\n     * @param {Vector2D} vector - The \"vector\" parameter is a 2D vector, represented by an object of type Vector2D.\n     * @returns a Vector2D.\n     */\n    static multiplyByVector(matrix, vector) {\n        const resultMatrix = Matrix2D.multiply(matrix, new Matrix2D(vector));\n        return resultMatrix.toVector();\n    }\n    /**\n     * The function returns a 2D matrix that scales and flips a vector around the center of a given width and height.\n     * @param {number} width - The width parameter represents the width of the view or the canvas. It is a number that\n     * specifies the width in pixels or any other unit of measurement.\n     * @param {number} height - The height parameter represents the height of the view or the canvas. It is used to\n     * calculate the centerY value, which is the vertical center of the view.\n     * @returns a Matrix2D object.\n     */\n    static view(width, height) {\n        const scaleStep = 1; // Scale every vector * scaleStep\n        const centerX = width / 2;\n        const centerY = height / 2;\n        const flipX = Math.cos(Math.PI); // rotate 180deg / 3.14radian around X-axis\n        return new Matrix2D([\n            [scaleStep, 0, centerX],\n            [0, flipX * scaleStep, centerY],\n            [0, 0, 1]\n        ]);\n    }\n    /**\n     * The function scales a matrix by a given factor.\n     * @param {number} factor - The factor parameter is a number that represents the scaling factor by which the matrix\n     * should be scaled.\n     * @returns the result of multiplying a new instance of Matrix2D by the given factor.\n     */\n    static scale(factor) {\n        return Matrix2D.multiplyByValue(new Matrix2D(), factor);\n    }\n    /**\n     * The function \"rotate\" takes an angle in radians and returns a 2D transformation matrix for rotating objects.\n     * @param {number} radians - The \"radians\" parameter is the angle in radians by which you want to rotate an object.\n     * @returns The code is returning a new instance of a Matrix2D object.\n     */\n    static rotate(radians) {\n        const cos = Math.cos(radians);\n        const sin = Math.sin(radians);\n        return new Matrix2D([\n            [cos, -sin, 0],\n            [sin, cos, 0],\n            [0, 0, 1]\n        ]);\n    }\n    /**\n     * The translate function takes a 2D vector and returns a 2D matrix that represents a translation transformation.\n     * @param {Vector2D} vector - The parameter \"vector\" is of type Vector2D. It represents a 2D vector with components x\n     * and y, and an optional w component.\n     * @returns The method is returning a new instance of the Matrix2D class.\n     */\n    static translate(vector) {\n        return new Matrix2D([\n            [1, 0, vector.x],\n            [0, 1, vector.y],\n            [0, 0, vector.w]\n        ]);\n    }\n}\nexport default Matrix2D;\n","export class Character {\n    /**\n     * The constructor function takes in a direction and turning object and sets the direction and turn properties of the\n     * Character class.\n     * @param {Direction} direction - The direction parameter is used to specify the current direction of the character. It\n     * can be any value that represents a direction, such as \"north\", \"south\", \"east\", or \"west\".\n     * @param {Turning} turning - The `turning` parameter is an object that maps each direction to the corresponding\n     * turning direction. It is used to determine the new direction when the character turns.\n     */\n    constructor(direction, turning) {\n        this.direction = direction;\n        this.turn = () => new Character(turning[direction], turning);\n    }\n}\nexport class Navigator {\n    /**\n     * The constructor initializes the Navigator object with the given parameters and sets the current position as visited\n     * in the matrix.\n     * @param  - - `matrix`: a 2D array representing the grid or map\n     */\n    constructor({ matrix, turning, onMove, init: { cur, charDir, VISITED } }) {\n        this._matrix = matrix;\n        this._cur = cur;\n        this._character = new Character(charDir, turning);\n        this.onMove = onMove;\n        this.onMove && this.onMove(this._cur);\n        this._VISITED = VISITED;\n        this._matrix[this._cur[0]][this._cur[1]] = this._VISITED;\n    }\n    /**\n     * The \"start\" function moves the character in its current direction until it encounters an obstacle, then it turns the\n     * character and repeats the process.\n     */\n    start() {\n        while (this.check(this._character.direction) || this.check(this._character.turn().direction)) {\n            const { direction } = this._character;\n            if (this.check(direction)) {\n                this.move(direction);\n            }\n            else if (this.check(this._character.turn().direction)) {\n                this._character = this._character.turn();\n            }\n        }\n    }\n    /**\n     * The function checks if there is a valid move in the specified direction in a matrix.\n     * @param {Direction} direction - The direction parameter is a string that represents the direction in which to check.\n     * It can be one of the following values: 'up', 'right', 'down', or 'left'.\n     * @returns a boolean value.\n     */\n    check(direction) {\n        let forward, row;\n        const matrix = this._matrix;\n        const [i, j] = this._cur;\n        switch (direction) {\n            case 'up':\n                row = matrix[i - 1];\n                if (!row)\n                    return false;\n                forward = row[j];\n                break;\n            case 'right':\n                forward = matrix[i][j + 1];\n                break;\n            case 'down':\n                row = matrix[i + 1];\n                if (!row)\n                    return false;\n                forward = row[j];\n                break;\n            case 'left':\n                forward = matrix[i][j - 1];\n                break;\n        }\n        return forward !== undefined && forward !== this._VISITED;\n    }\n    /**\n     * The `move` function updates the current position based on the given direction and updates the matrix accordingly.\n     * @param {Direction} direction - The `direction` parameter is a string that represents the direction in which to move.\n     * It can have one of the following values: 'up', 'right', 'down', or 'left'.\n     */\n    move(direction) {\n        switch (direction) {\n            case 'up':\n                this._cur[0]--;\n                break;\n            case 'right':\n                this._cur[1]++;\n                break;\n            case 'down':\n                this._cur[0]++;\n                break;\n            case 'left':\n                this._cur[1]--;\n                break;\n        }\n        const [i, j] = this._cur;\n        this._matrix[i][j] = this._VISITED;\n        this.onMove && this.onMove(this._cur);\n    }\n}\n","/**\n * data-structure-typed\n *\n * @author Tyler Zeng\n * @copyright Copyright (c) 2022 Tyler Zeng <zrwusa@gmail.com>\n * @license MIT License\n */\n/**\n * TrieNode represents a node in the Trie data structure. It holds a character key, a map of children nodes,\n * and a flag indicating whether it's the end of a word.\n */\nexport class TrieNode {\n    constructor(key) {\n        this._key = key;\n        this._isEnd = false;\n        this._children = new Map();\n    }\n    get key() {\n        return this._key;\n    }\n    set key(v) {\n        this._key = v;\n    }\n    get children() {\n        return this._children;\n    }\n    set children(v) {\n        this._children = v;\n    }\n    get isEnd() {\n        return this._isEnd;\n    }\n    set isEnd(v) {\n        this._isEnd = v;\n    }\n}\n/**\n * Trie represents a Trie data structure. It provides basic Trie operations and additional methods.\n */\nexport class Trie {\n    constructor(words, caseSensitive = true) {\n        this._root = new TrieNode('');\n        this._caseSensitive = caseSensitive;\n        if (words) {\n            for (const i of words) {\n                this.add(i);\n            }\n        }\n    }\n    get root() {\n        return this._root;\n    }\n    set root(v) {\n        this._root = v;\n    }\n    /**\n     * Add a word to the Trie structure.\n     * @param {string} word - The word to add.\n     * @returns {boolean} True if the word was successfully added.\n     */\n    add(word) {\n        word = this._caseProcess(word);\n        let cur = this.root;\n        for (const c of word) {\n            let nodeC = cur.children.get(c);\n            if (!nodeC) {\n                nodeC = new TrieNode(c);\n                cur.children.set(c, nodeC);\n            }\n            cur = nodeC;\n        }\n        cur.isEnd = true;\n        return true;\n    }\n    /**\n     * Check if the Trie contains a given word.\n     * @param {string} word - The word to check for.\n     * @returns {boolean} True if the word is present in the Trie.\n     */\n    has(word) {\n        word = this._caseProcess(word);\n        let cur = this.root;\n        for (const c of word) {\n            const nodeC = cur.children.get(c);\n            if (!nodeC)\n                return false;\n            cur = nodeC;\n        }\n        return cur.isEnd;\n    }\n    _caseProcess(str) {\n        if (!this._caseSensitive) {\n            str = str.toLowerCase(); // Convert str to lowercase if case-insensitive\n        }\n        return str;\n    }\n    /**\n     * Remove a word from the Trie structure.\n     * @param{string} word - The word to remove.\n     * @returns {boolean} True if the word was successfully removed.\n     */\n    remove(word) {\n        word = this._caseProcess(word);\n        let isDeleted = false;\n        const dfs = (cur, i) => {\n            const char = word[i];\n            const child = cur.children.get(char);\n            if (child) {\n                if (i === word.length - 1) {\n                    if (child.isEnd) {\n                        if (child.children.size > 0) {\n                            child.isEnd = false;\n                        }\n                        else {\n                            cur.children.delete(char);\n                        }\n                        isDeleted = true;\n                        return true;\n                    }\n                    return false;\n                }\n                const res = dfs(child, i + 1);\n                if (res && !cur.isEnd && child.children.size === 0) {\n                    cur.children.delete(char);\n                    return true;\n                }\n                return false;\n            }\n            return false;\n        };\n        dfs(this.root, 0);\n        return isDeleted;\n    }\n    getHeight() {\n        const beginRoot = this.root;\n        let maxDepth = 0;\n        if (beginRoot) {\n            const bfs = (node, level) => {\n                if (level > maxDepth) {\n                    maxDepth = level;\n                }\n                const { children } = node;\n                if (children) {\n                    for (const child of children.entries()) {\n                        bfs(child[1], level + 1);\n                    }\n                }\n            };\n            bfs(beginRoot, 0);\n        }\n        return maxDepth;\n    }\n    // --- start additional methods ---\n    /**\n     * Check if a given input string has an absolute prefix in the Trie, meaning it's not a complete word.\n     * @param {string} input - The input string to check.\n     * @returns {boolean} True if it's an absolute prefix in the Trie.\n     */\n    hasPurePrefix(input) {\n        input = this._caseProcess(input);\n        let cur = this.root;\n        for (const c of input) {\n            const nodeC = cur.children.get(c);\n            if (!nodeC)\n                return false;\n            cur = nodeC;\n        }\n        return !cur.isEnd;\n    }\n    /**\n     * Check if a given input string is a prefix of any existing word in the Trie, whether as an absolute prefix or a complete word.\n     * @param {string} input - The input string representing the prefix to check.\n     * @returns {boolean} True if it's a prefix in the Trie.\n     */\n    hasPrefix(input) {\n        input = this._caseProcess(input);\n        let cur = this.root;\n        for (const c of input) {\n            const nodeC = cur.children.get(c);\n            if (!nodeC)\n                return false;\n            cur = nodeC;\n        }\n        return true;\n    }\n    /**\n     * Check if the input string is a common prefix in the Trie, meaning it's a prefix shared by all words in the Trie.\n     * @param {string} input - The input string representing the common prefix to check for.\n     * @returns {boolean} True if it's a common prefix in the Trie.\n     */\n    hasCommonPrefix(input) {\n        input = this._caseProcess(input);\n        let commonPre = '';\n        const dfs = (cur) => {\n            commonPre += cur.key;\n            if (commonPre === input)\n                return;\n            if (cur.isEnd)\n                return;\n            if (cur && cur.children && cur.children.size === 1)\n                dfs(Array.from(cur.children.values())[0]);\n            else\n                return;\n        };\n        dfs(this.root);\n        return commonPre === input;\n    }\n    /**\n     * Get the longest common prefix among all the words stored in the Trie.\n     * @returns {string} The longest common prefix found in the Trie.\n     */\n    getLongestCommonPrefix() {\n        let commonPre = '';\n        const dfs = (cur) => {\n            commonPre += cur.key;\n            if (cur.isEnd)\n                return;\n            if (cur && cur.children && cur.children.size === 1)\n                dfs(Array.from(cur.children.values())[0]);\n            else\n                return;\n        };\n        dfs(this.root);\n        return commonPre;\n    }\n    /**\n     * The `getAll` function returns an array of all words in a Trie data structure that start with a given prefix.\n     * @param {string} prefix - The `prefix` parameter is a string that represents the prefix that we want to search for in the\n     * trie. It is an optional parameter, so if no prefix is provided, it will default to an empty string.\n     * @param {number} max - The max count of words will be found\n     * @returns {string[]} an array of strings.\n     */\n    getWords(prefix = '', max = Number.MAX_SAFE_INTEGER) {\n        prefix = this._caseProcess(prefix);\n        const words = [];\n        let found = 0;\n        function dfs(node, word) {\n            for (const char of node.children.keys()) {\n                const charNode = node.children.get(char);\n                if (charNode !== undefined) {\n                    dfs(charNode, word.concat(char));\n                }\n            }\n            if (node.isEnd) {\n                if (found > max - 1)\n                    return;\n                words.push(word);\n                found++;\n            }\n        }\n        let startNode = this.root;\n        if (prefix) {\n            for (const c of prefix) {\n                const nodeC = startNode.children.get(c);\n                if (nodeC)\n                    startNode = nodeC;\n            }\n        }\n        if (startNode !== this.root)\n            dfs(startNode, prefix);\n        return words;\n    }\n}\n"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","HashTableNode","constructor","val","this","next","HashTable","hashFn","_hashFn","buckets","_buckets","capacity","_capacity","DEFAULT_CAPACITY","_defaultHashFn","Math","max","_size","Array","fill","_murmurStringHashFn","_objectHash","_multiplicativeStringHashFn","keyString","String","hash","i","length","charCodeAt","abs","_hash","_stringHash","JSON","stringify","set","index","newNode","currentNode","LOAD_FACTOR","_expand","remove","prevNode","newCapacity","newBuckets","bucket","newIndex","currentNewNode","size","CoordinateMap","Map","joint","super","_joint","undefined","has","join","delete","_setJoint","v","CoordinateSet","Set","add","TreeMap","TreeSet","HashMap","table","_table","capacityMultiplier","_capacityMultiplier","loadFactor","_loadFactor","initialCapacity","_initialCapacity","strKey","resizeTable","newTable","push","k","splice","entries","iterator","clear","isEmpty","SinglyLinkedListNode","_val","_next","SinglyLinkedList","_head","_tail","_length","head","tail","fromArray","data","singlyLinkedList","item","getLength","pop","current","shift","removedNode","unshift","getAt","getNodeAt","deleteAt","valueOrNode","prev","insertAt","toArray","array","reverse","find","callback","indexOf","findNode","insertBefore","existingValueOrNode","newValue","existingValue","insertAfter","existingNode","countOccurrences","count","DoublyLinkedListNode","_prev","DoublyLinkedList","doublyLinkedList","addLast","pollLast","pollFirst","addFirst","peekFirst","_a","peekLast","nextNode","valOrNode","node","findLast","toArrayReverse","forEach","map","mappedList","filter","filteredList","reduce","initialValue","accumulator","SkipListNode","level","forward","SkipList","probability","_probability","maxLevel","_maxLevel","_level","randomLevel","random","update","Stack","elements","_elements","isArray","peek","element","slice","clone","LinkedListQueue","enqueue","dequeue","Queue","_nodes","_offset","nodes","offset","first","Deque","ObjectDeque","Number","MAX_SAFE_INTEGER","_first","_last","last","mid","floor","_seNodes","_setSize","ArrayDeque","insert","uuidV4","replace","c","r","toString","arrayRemove","predicate","len","result","THUNK_SYMBOL","isThunk","fnOrValue","__THUNK__","toThunk","fn","thunk","trampoline","assign","args","cont","trampolineAsync","__awaiter","thisArg","_arguments","generator","P","Promise","resolve","reject","fulfilled","step","e","rejected","done","then","apply","Heap","comparator","bubbleUp","poll","topValue","sinkDown","parentIndex","parent","leftChildIndex","rightChildIndex","targetIndex","temp","fix","leaf","refill","includes","dfs","order","dfsHelper","getNodes","clonedHeap","sort","visitedNode","cloned","top","heapify","binaryHeap","PriorityQueue","AbstractVertex","_key","AbstractEdge","weight","_weight","_hashCode","hashCode","_setHashCode","AbstractGraph","_vertices","vertices","getVertex","vertexKey","hasVertex","vertexOrKey","_getVertexKey","addVertex","keyOrVertex","_addVertexOnly","newVertex","createVertex","removeVertex","removeAllVertices","removed","hasEdge","v1","v2","getEdge","addEdge","srcOrEdge","dest","_addEdgeOnly","newEdge","createEdge","Error","setEdgeWeight","srcOrKey","destOrKey","edge","getAllPathsBetween","paths","vertex1","_getVertex","vertex2","cur","visiting","path","neighbors","getNeighbors","neighbor","vertex","getPathSumWeight","sum","getMinCostBetween","isWeight","allPaths","min","Infinity","visited","queue","cost","getMinPathBetween","minIndex","pathSumWeight","minPath","dijkstraWithoutHeap","src","getMinDist","genPaths","minDist","minDest","distMap","seen","preMap","srcVertex","destVertex","getMinOfNoSeen","minV","getPaths","reversed","curFromMap","neighborFromMap","d","dijkstra","heap","a","b","curHeapNode","dist","distSrcToNeighbor","bellmanFord","scanNegativeCycle","getMin","genPath","hasNegativeCycle","numOfVertices","edges","edgeSet","numOfEdges","j","ends","getEndsOfEdge","s","sWeight","dWeight","floyd","idAndVertices","n","costs","predecessor","tarjan","needArticulationPoints","needBridges","needSCCs","needCycles","defaultConfig","dfnMap","lowMap","values","articulationPoints","bridges","dfn","childCount","childLow","curLow","edgeCurToNeighbor","SCCs","getSCCs","low","cycles","SCC","_setVertices","DirectedVertex","DirectedEdge","_src","_dest","DirectedGraph","_outEdgeMap","_inEdgeMap","outEdgeMap","inEdgeMap","srcOutEdges","removeEdgeSrcToDest","destInEdges","removeEdge","removeEdgesBetween","v1ToV2","v2ToV1","incomingEdgesOf","target","outgoingEdgesOf","degreeOf","outDegreeOf","inDegreeOf","edgesOf","getEdgeSrc","getEdgeDest","getDestinations","destinations","outgoingEdges","outEdge","child","topologicalSort","propertyName","statusMap","entry","sorted","hasCycle","children","childStatus","outEdges","_setOutEdgeMap","_setInEdgeMap","UndirectedVertex","UndirectedEdge","UndirectedGraph","_edges","removeEdgeBetween","v1Edges","v2Edges","neighborEdges","end","endVertex","_setEdges","MapVertex","lat","long","_lat","_long","MapEdge","MapGraph","origin","bottomRight","_origin","_bottomRight","LoopType","FamilyPosition","CP","RBColor","TopologicalProperty","BinaryTreeNode","left","_left","right","_right","familyPosition","that","ROOT_LEFT","LEFT","ROOT_RIGHT","RIGHT","MAL_NODE","ROOT","ISOLATED","BinaryTree","options","_root","_loopType","ITERATIVE","visitedKey","visitedVal","loopType","createNode","swapLocation","srcNode","destNode","tempNode","_clearResults","keyOrNode","inserted","needInsert","existNode","_addTo","_bfs","_setRoot","addMany","keysOrNodes","nodeOrKey","bstDeletedResult","curr","needBalanced","orgCurrent","leftSubTreeRightMost","getRightMost","parentOfLeftSubTreeMax","fp","deleted","getDepth","distNode","beginRoot","depth","getHeight","RECURSIVE","_getMaxHeight","leftHeight","rightHeight","stack","maxHeight","getMinHeight","_b","_c","_getMinHeight","leftMinHeight","rightMinHeight","depths","isPerfectlyBalanced","nodeProperty","onlyOne","_traverse","_pushByPropertyNameStopOrNot","getPathToRoot","isReverse","getLeftMost","isSubtreeBST","MIN_SAFE_INTEGER","isBST","getSubTreeSize","subTreeRoot","subTreeSum","_sumByProperty","needSum","subTreeAdd","delta","_addByProperty","bfs","nodeOrPropertyName","_accumulatedByPropertyName","_getResultByPropertyName","pattern","dfsIterative","opt","levelIterative","listLevels","levelsNodes","collectByProperty","_recursive","getPredecessor","morris","_reverseEdge","pre","_printEdge","_setLoopType","BSTNode","BST","_comparator","traversing","_compare","eq","gt","lt","isBalanceAdd","combinedArr","sortedKeysOrNodes","sortedData","arr","isNodeOrNullTuple","isBinaryTreeKeyOrNullTuple","recursive","popped","l","m","iterative","lastKey","_d","_e","_f","lesserSum","beginNode","getSumByPropertyName","compared","allGreaterNodesAdd","_sumByPropertyName","perfectlyBalance","buildBalanceBST","midNode","isAVLBalanced","balanced","_height","BinaryIndexedTree","_sumTree","sumTree","lowBit","x","getPrefixSum","getRangeSum","start","_setSumTree","SegmentTreeNode","_start","_end","_sum","SegmentTree","_values","build","updateNode","querySumByRange","indexA","indexB","NaN","leftSum","rightSum","_setValues","_setStart","_setEnd","AVLTreeNode","height","AVLTree","_balancePath","deletedResults","_balanceFactor","_updateHeight","A","_balanceLL","_balanceLR","_balanceRR","_balanceRL","parentOfA","B","C","RBTreeNode","_color","RED","color","RBTree","TreeMultisetNode","TreeMultiset","_count","_setCount","ignoreCount","getSubTreeCount","res","subTreeSumCount","subTreeAddCount","getNodesByCount","BFSCount","listLevelsCount","morrisCount","dfsCountIterative","dfsCount","lesserSumCount","allGreaterNodesAddCount","TreeNode","_value","_children","addChildren","concat","maxDepth","MaxHeap","MinHeap","MinPriorityQueue","compare","MaxPriorityQueue","MatrixNTI2D","row","col","initialVal","_matrix","Vector2D","y","w","isZero","sqrt","lengthSq","rounded","round","vector1","vector2","subtract","subtractValue","vector","multiply","divide","equals","equalsRounded","roundingFactor","normalize","truncate","perp","dot","distance","ySeparation","xSeparation","distanceSq","sign","angle","radian","acos","PI","maxX","maxY","randX","randY","zero","Matrix2D","identity","empty","toVector","matrix1","matrix2","multiplyByValue","matrix","multiplyByVector","view","width","centerX","centerY","flipX","cos","scale","factor","rotate","radians","sin","translate","Character","direction","turning","turn","Navigator","onMove","init","charDir","VISITED","_cur","_character","_VISITED","check","move","TrieNode","_isEnd","isEnd","Trie","words","caseSensitive","_caseSensitive","word","_caseProcess","nodeC","str","toLowerCase","isDeleted","char","hasPurePrefix","input","hasPrefix","hasCommonPrefix","commonPre","from","getLongestCommonPrefix","getWords","prefix","found","startNode","keys","charNode"],"sourceRoot":""}