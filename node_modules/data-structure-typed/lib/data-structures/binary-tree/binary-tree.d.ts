/**
 * data-structure-typed
 *
 * @author Tyler Zeng
 * @copyright Copyright (c) 2022 Tyler Zeng <zrwusa@gmail.com>
 * @license MIT License
 */
import type { BinaryTreeNodeKey, BinaryTreeNodeNested, BinaryTreeNodeProperties, BinaryTreeOptions } from '../../types';
import { IBinaryTree } from '../../interfaces';
import { BinaryTreeDeletedResult, BinaryTreeNodePropertyName, DFSOrderPattern, FamilyPosition, LoopType, NodeOrPropertyName } from '../../types';
export declare class BinaryTreeNode<V = any, FAMILY extends BinaryTreeNode<V, FAMILY> = BinaryTreeNodeNested<V>> {
    /**
     * The constructor function initializes a BinaryTreeNode object with a key and an optional value.
     * @param {BinaryTreeNodeKey} key - The `key` parameter is of type `BinaryTreeNodeKey` and represents the unique identifier
     * of the binary tree node. It is used to distinguish one node from another in the binary tree.
     * @param {V} [val] - The "val" parameter is an optional parameter of type V. It represents the value that will be
     * stored in the binary tree node. If no value is provided, it will be set to undefined.
     */
    constructor(key: BinaryTreeNodeKey, val?: V);
    key: BinaryTreeNodeKey;
    val: V | undefined;
    private _left;
    get left(): FAMILY | null | undefined;
    set left(v: FAMILY | null | undefined);
    private _right;
    get right(): FAMILY | null | undefined;
    set right(v: FAMILY | null | undefined);
    parent: FAMILY | null | undefined;
    /**
     * The function determines the position of a node in a family tree structure.
     * @returns a value of type `FamilyPosition`.
     */
    get familyPosition(): FamilyPosition;
}
export declare class BinaryTree<N extends BinaryTreeNode<N['val'], N> = BinaryTreeNode> implements IBinaryTree<N> {
    /**
     * This is a constructor function for a binary tree class that takes an optional options parameter.
     * @param {BinaryTreeOptions} [options] - The `options` parameter is an optional object that can be passed to the
     * constructor of the `BinaryTree` class. It allows you to customize the behavior of the binary tree by providing
     * different configuration options.
     */
    constructor(options?: BinaryTreeOptions);
    /**
     * The function creates a new binary tree node with an optional value.
     * @param {BinaryTreeNodeKey} key - The `key` parameter is the identifier for the binary tree node. It is of type
     * `BinaryTreeNodeKey`, which represents the unique identifier for each node in the binary tree.
     * @param [val] - The `val` parameter is an optional value that can be assigned to the node. It represents the value
     * stored in the node.
     * @returns a new instance of a BinaryTreeNode with the specified key and value.
     */
    createNode(key: BinaryTreeNodeKey, val?: N['val']): N;
    private _root;
    get root(): N | null;
    private _size;
    get size(): number;
    private _loopType;
    get loopType(): LoopType;
    visitedKey: BinaryTreeNodeKey[];
    visitedVal: N['val'][];
    visitedNode: N[];
    /**
     * The `swapLocation` function swaps the location of two nodes in a binary tree.
     * @param {N} srcNode - The source node that you want to swap with the destination node.
     * @param {N} destNode - The `destNode` parameter represents the destination node where the values from `srcNode` will
     * be swapped to.
     * @returns The `destNode` is being returned.
     */
    swapLocation(srcNode: N, destNode: N): N;
    /**
     * The clear() function resets the root, size, and maxKey properties to their initial values.
     */
    clear(): void;
    /**
     * The function checks if the size of an object is equal to zero and returns a boolean value.
     * @returns A boolean value indicating whether the size of the object is 0 or not.
     */
    isEmpty(): boolean;
    /**
     * When all leaf nodes are null, it will no longer be possible to add new entity nodes to this binary tree.
     * In this scenario, null nodes serve as "sentinel nodes," "virtual nodes," or "placeholder nodes."
     */
    /**
     * The `add` function adds a new node to a binary tree, either by ID or by creating a new node with a given value.
     * @param {BinaryTreeNodeKey | N | null} keyOrNode - The `keyOrNode` parameter can be either a `BinaryTreeNodeKey`, which
     * is a number representing the ID of a binary tree node, or it can be a `N` object, which represents a binary tree
     * node itself. It can also be `null` if no node is specified.
     * @param [val] - The `val` parameter is an optional value that can be assigned to the `val` property of the new node
     * being added to the binary tree.
     * @returns The function `add` returns either the inserted node (`N`), `null`, or `undefined`.
     */
    add(keyOrNode: BinaryTreeNodeKey | N | null, val?: N['val']): N | null | undefined;
    /**
     * The `addMany` function takes an array of binary tree node IDs or nodes, and optionally an array of corresponding data
     * values, and adds them to the binary tree.
     * @param {(BinaryTreeNodeKey | null)[] | (N | null)[]} keysOrNodes - An array of BinaryTreeNodeKey or BinaryTreeNode
     * objects, or null values.
     * @param {N['val'][]} [data] - The `data` parameter is an optional array of values (`N['val'][]`) that corresponds to
     * the nodes or node IDs being added. It is used to set the value of each node being added. If `data` is not provided,
     * the value of the nodes will be `undefined`.
     * @returns The function `addMany` returns an array of `N`, `null`, or `undefined` values.
     */
    addMany(keysOrNodes: (BinaryTreeNodeKey | null)[] | (N | null)[], data?: N['val'][]): (N | null | undefined)[];
    /**
     * The `refill` function clears the binary tree and adds multiple nodes with the given IDs or nodes and optional data.
     * @param {(BinaryTreeNodeKey | N)[]} keysOrNodes - The `keysOrNodes` parameter is an array that can contain either
     * `BinaryTreeNodeKey` or `N` values.
     * @param {N[] | Array<N['val']>} [data] - The `data` parameter is an optional array of values that will be assigned to
     * the nodes being added. If provided, the length of the `data` array should be equal to the length of the `keysOrNodes`
     * array. Each value in the `data` array will be assigned to the
     * @returns The method is returning a boolean value.
     */
    refill(keysOrNodes: (BinaryTreeNodeKey | null)[] | (N | null)[], data?: N[] | Array<N['val']>): boolean;
    /**
     * The `remove` function in TypeScript is used to delete a node from a binary search tree and returns an array of objects
     * containing the deleted node and the node that needs to be balanced.
     * @param {N | BinaryTreeNodeKey} nodeOrKey - The `nodeOrKey` parameter can be either a node object (`N`) or a binary tree
     * node ID (`BinaryTreeNodeKey`).
     * @returns The function `remove` returns an array of `BinaryTreeDeletedResult<N>` objects.
     */
    remove(nodeOrKey: N | BinaryTreeNodeKey): BinaryTreeDeletedResult<N>[];
    /**
     * The function calculates the depth of a node in a binary tree.
     * @param {N | BinaryTreeNodeKey | null} distNode - The `distNode` parameter can be any node of the tree
     * @param {N | BinaryTreeNodeKey | null} beginRoot - The `beginRoot` parameter can be the predecessor node of distNode
     * @returns the depth of the given node or binary tree.
     */
    getDepth(distNode: N | BinaryTreeNodeKey | null, beginRoot?: N | BinaryTreeNodeKey | null): number;
    /**
     * The `getHeight` function calculates the maximum height of a binary tree, either recursively or iteratively.
     * @param {N | BinaryTreeNodeKey | null} [beginRoot] - The `beginRoot` parameter is optional and can be of type `N` (a
     * generic type representing a node in a binary tree), `BinaryTreeNodeKey` (a type representing the ID of a binary tree
     * node), or `null`.
     * @returns the height of the binary tree.
     */
    getHeight(beginRoot?: N | BinaryTreeNodeKey | null): number;
    /**
     * The `getMinHeight` function calculates the minimum height of a binary tree using either a recursive or iterative
     * approach.
     * @param {N | null} [beginRoot] - The `beginRoot` parameter is an optional parameter of type `N` or `null`. It
     * represents the starting node from which to calculate the minimum height of a binary tree. If no value is provided
     * for `beginRoot`, the `this.root` property is used as the default value.
     * @returns The function `getMinHeight` returns the minimum height of the binary tree.
     */
    getMinHeight(beginRoot?: N | null): number;
    /**
     * The function checks if a binary tree is perfectly balanced by comparing the minimum height and the height of the
     * tree.
     * @param {N | null} [beginRoot] - The parameter `beginRoot` is of type `N` or `null`. It represents the root node of a
     * tree or null if the tree is empty.
     * @returns The method is returning a boolean value.
     */
    isPerfectlyBalanced(beginRoot?: N | null): boolean;
    /**
     * The function `getNodes` returns an array of nodes that match a given property name and value in a binary tree.
     * @param {BinaryTreeNodeKey | N} nodeProperty - The `nodeProperty` parameter can be either a `BinaryTreeNodeKey` or a
     * generic type `N`. It represents the property of the binary tree node that you want to search for.
     * @param {BinaryTreeNodePropertyName} [propertyName] - The `propertyName` parameter is an optional parameter that
     * specifies the property name to use when searching for nodes. If not provided, it defaults to 'key'.
     * @param {boolean} [onlyOne] - The `onlyOne` parameter is an optional boolean parameter that determines whether to
     * return only one node that matches the given `nodeProperty` or `propertyName`. If `onlyOne` is set to `true`, the
     * function will stop traversing the tree and return the first matching node. If `only
     * @returns an array of nodes (type N).
     */
    getNodes(nodeProperty: BinaryTreeNodeKey | N, propertyName?: BinaryTreeNodePropertyName, onlyOne?: boolean): N[];
    /**
     * The function checks if a binary tree node has a specific property.
     * @param {BinaryTreeNodeKey | N} nodeProperty - The `nodeProperty` parameter can be either a `BinaryTreeNodeKey` or `N`.
     * It represents the property of the binary tree node that you want to check.
     * @param {BinaryTreeNodePropertyName} [propertyName] - The `propertyName` parameter is an optional parameter that
     * specifies the name of the property to be checked in the nodes. If not provided, it defaults to 'key'.
     * @returns a boolean value.
     */
    has(nodeProperty: BinaryTreeNodeKey | N, propertyName?: BinaryTreeNodePropertyName): boolean;
    /**
     * The function returns the first node that matches the given property name and value, or null if no matching node is
     * found.
     * @param {BinaryTreeNodeKey | N} nodeProperty - The `nodeProperty` parameter can be either a `BinaryTreeNodeKey` or `N`.
     * It represents the property of the binary tree node that you want to search for.
     * @param {BinaryTreeNodePropertyName} [propertyName] - The `propertyName` parameter is an optional parameter that
     * specifies the property name to be used for searching the binary tree nodes. If this parameter is not provided, the
     * default value is set to `'key'`.
     * @returns either the value of the specified property of the node, or the node itself if no property name is provided.
     * If no matching node is found, it returns null.
     */
    get(nodeProperty: BinaryTreeNodeKey | N, propertyName?: BinaryTreeNodePropertyName): N | null;
    /**
     * The function `getPathToRoot` returns an array of nodes representing the path from a given node to the root node, with
     * an option to reverse the order of the nodes.
     * @param {N} node - The `node` parameter represents a node in a tree structure. It is of type `N`, which could be any
     * type that represents a node in your specific implementation.
     * @param {boolean} [isReverse=true] - The `isReverse` parameter is a boolean flag that determines whether the resulting
     * path should be reversed or not. If `isReverse` is set to `true`, the path will be reversed before returning it. If
     * `isReverse` is set to `false` or not provided, the path will
     * @returns The function `getPathToRoot` returns an array of nodes (`N[]`).
     */
    getPathToRoot(node: N, isReverse?: boolean): N[];
    /**
     * The function `getLeftMost` returns the leftmost node in a binary tree, starting from a specified node or the root if
     * no node is specified.
     * generic type representing a node in a binary tree), `BinaryTreeNodeKey` (a type representing the ID of a binary tree
     * node), or `null`.
     * @returns The function `getLeftMost` returns the leftmost node in a binary tree. If the `beginRoot` parameter is
     * provided, it starts the traversal from that node. If `beginRoot` is not provided or is `null`, it starts the traversal
     * from the root of the binary tree. The function returns the leftmost node found during the traversal. If no leftmost
     * node is found (
     */
    getLeftMost(): N | null;
    /**
     * The function `getLeftMost` returns the leftmost node in a binary tree, starting from a specified node or the root if
     * no node is specified.
     * @param {N | BinaryTreeNodeKey | null} [node] - The `beginRoot` parameter is optional and can be of type `N` (a
     * generic type representing a node in a binary tree), `BinaryTreeNodeKey` (a type representing the ID of a binary tree
     * node).
     * @returns The function `getLeftMost` returns the leftmost node in a binary tree. If the `beginRoot` parameter is
     * provided, it starts the traversal from that node. If `beginRoot` is not provided or is `null`, it starts the traversal
     * from the root of the binary tree. The function returns the leftmost node found during the traversal. If no leftmost
     * node is found (
     */
    getLeftMost(node: N): N;
    /**
     * The `getRightMost` function returns the rightmost node in a binary tree, either recursively or iteratively using tail
     * recursion optimization.
     * @returns The `getRightMost` function returns the rightmost node in a binary tree. It returns the
     * rightmost node starting from the root of the binary tree.
     */
    getRightMost(): N | null;
    /**
     * The `getRightMost` function returns the rightmost node in a binary tree, either recursively or iteratively using tail
     * recursion optimization.
     * @param {N | null} [beginRoot] - The `node` parameter is an optional parameter of type `N` or `null`. It represents the
     * starting node from which we want to find the rightmost node. If no node is provided, the function will default to
     * using the root node of the data structure.
     * @returns The `getRightMost` function returns the rightmost node in a binary tree. It returns the rightmost node
     * starting from that node.
     */
    getRightMost(beginRoot: N): N;
    /**
     * The function checks if a binary search tree is valid by traversing it either recursively or iteratively.
     * @param {N | null} node - The `node` parameter represents the root node of a binary search tree (BST).
     * @returns a boolean value.
     */
    isSubtreeBST(node: N | null): boolean;
    /**
     * The function isBST checks if the binary tree is valid binary search tree.
     * @returns The `isBST()` function is returning a boolean value.
     */
    isBST(): boolean;
    /**
     * The function calculates the size of a subtree by traversing it either recursively or iteratively.
     * @param {N | null | undefined} subTreeRoot - The `subTreeRoot` parameter represents the root node of a subtree in a
     * binary tree.
     * @returns the size of the subtree rooted at `subTreeRoot`.
     */
    getSubTreeSize(subTreeRoot: N | null | undefined): number;
    /**
     * The function `subTreeSum` calculates the sum of a specified property in a binary tree or subtree.
     * @param {N | BinaryTreeNodeKey | null} subTreeRoot - The `subTreeRoot` parameter represents the root node of a binary
     * tree or the ID of a binary tree node. It can also be `null` if there is no subtree.
     * @param {BinaryTreeNodePropertyName} [propertyName] - propertyName is an optional parameter that specifies the
     * property of the binary tree node to use for calculating the sum. It can be either 'key' or 'val'. If propertyName is
     * not provided, it defaults to 'key'.
     * @returns a number, which is the sum of the values of the specified property in the subtree rooted at `subTreeRoot`.
     */
    subTreeSum(subTreeRoot: N | BinaryTreeNodeKey | null, propertyName?: BinaryTreeNodePropertyName): number;
    /**
     * The function `subTreeAdd` adds a delta value to a specified property of each node in a subtree.
     * @param {N | BinaryTreeNodeKey | null} subTreeRoot - The `subTreeRoot` parameter represents the root node of a binary
     * tree or the ID of a node in the binary tree. It can also be `null` if there is no subtree to add to.
     * @param {number} delta - The `delta` parameter is a number that represents the amount by which the property value of
     * each node in the subtree should be incremented.
     * @param {BinaryTreeNodePropertyName} [propertyName] - The `propertyName` parameter is an optional parameter that
     * specifies the property of the binary tree node that should be modified. If not provided, it defaults to 'key'.
     * @returns a boolean value.
     */
    subTreeAdd(subTreeRoot: N | BinaryTreeNodeKey | null, delta: number, propertyName?: BinaryTreeNodePropertyName): boolean;
    /**
     * Performs a breadth-first search (bfs) on a binary tree, accumulating properties of each node based on their 'key' property.
     * @returns An array of binary tree node IDs.
     */
    bfs(): BinaryTreeNodeKey[];
    /**
     * Performs a breadth-first search (bfs) on a binary tree, accumulating properties of each node based on the specified property name.
     * @param {'key'} nodeOrPropertyName - The name of the property to accumulate.
     * @returns An array of values corresponding to the specified property.
     */
    bfs(nodeOrPropertyName: 'key'): BinaryTreeNodeKey[];
    /**
     * Performs a breadth-first search (bfs) on a binary tree, accumulating the 'val' property of each node.
     * @param {'val'} nodeOrPropertyName - The name of the property to accumulate.
     * @returns An array of 'val' properties from each node.
     */
    bfs(nodeOrPropertyName: 'val'): N['val'][];
    /**
     * Performs a breadth-first search (bfs) on a binary tree, accumulating nodes themselves.
     * @param {'node'} nodeOrPropertyName - The name of the property to accumulate.
     * @returns An array of binary tree nodes.
     */
    bfs(nodeOrPropertyName: 'node'): N[];
    /**
     * Performs a depth-first search (dfs) traversal on a binary tree and accumulates properties of each node based on their 'key' property.
     * @returns An array of binary tree node IDs.
     */
    dfs(): BinaryTreeNodeKey[];
    /**
     * Performs a depth-first search (dfs) traversal on a binary tree and accumulates properties of each node based on the specified property name.
     * @param {'in' | 'pre' | 'post'} [pattern] - The traversal pattern: 'in' (in-order), 'pre' (pre-order), or 'post' (post-order).
     * @returns An array of values corresponding to the specified property.
     */
    dfs(pattern: DFSOrderPattern): BinaryTreeNodeKey[];
    /**
     * Performs a depth-first search (dfs) traversal on a binary tree and accumulates properties of each node based on the specified property name.
     * @param {'in' | 'pre' | 'post'} [pattern] - The traversal pattern: 'in' (in-order), 'pre' (pre-order), or 'post' (post-order).
     * @param {string} nodeOrPropertyName - The name of the property to accumulate.
     * @returns An array of values corresponding to the specified property.
     */
    dfs(pattern: DFSOrderPattern, nodeOrPropertyName: 'key'): BinaryTreeNodeKey[];
    /**
     * Performs a depth-first search (dfs) traversal on a binary tree and accumulates the 'val' property of each node.
     * @param {'in' | 'pre' | 'post'} [pattern] - The traversal pattern: 'in' (in-order), 'pre' (pre-order), or 'post' (post-order).
     * @param {'val'} nodeOrPropertyName - The name of the property to accumulate.
     * @returns An array of 'val' properties from each node.
     */
    dfs(pattern: DFSOrderPattern, nodeOrPropertyName: 'val'): N[];
    /**
     * Performs a depth-first search (dfs) traversal on a binary tree and accumulates nodes themselves.
     * @param {'in' | 'pre' | 'post'} [pattern] - The traversal pattern: 'in' (in-order), 'pre' (pre-order), or 'post' (post-order).
     * @param {'node'} nodeOrPropertyName - The name of the property to accumulate.
     * @returns An array of binary tree nodes.
     */
    dfs(pattern: DFSOrderPattern, nodeOrPropertyName: 'node'): N[];
    /**
     * Performs an iterative depth-first search (dfs) traversal on a binary tree and accumulates properties of each node based on their 'key' property.
     * @returns An array of binary tree node IDs.
     */
    dfsIterative(): BinaryTreeNodeKey[];
    /**
     * Performs an iterative depth-first search (dfs) traversal on a binary tree and accumulates properties of each node based on their 'key' property.
     * @param {'in' | 'pre' | 'post'} [pattern] - The traversal pattern: 'in' (in-order), 'pre' (pre-order), or 'post' (post-order).
     * @returns An array of values corresponding to the specified property.
     */
    dfsIterative(pattern: DFSOrderPattern): BinaryTreeNodeKey[];
    /**
     * Performs an iterative depth-first search (dfs) traversal on a binary tree and accumulates properties of each node based on the specified property name.
     * @param {'in' | 'pre' | 'post'} [pattern] - The traversal pattern: 'in' (in-order), 'pre' (pre-order), or 'post' (post-order).
     * @param {string} nodeOrPropertyName - The name of the property to accumulate.
     * @returns An array of values corresponding to the specified property.
     */
    dfsIterative(pattern: DFSOrderPattern, nodeOrPropertyName: 'key'): BinaryTreeNodeKey[];
    /**
     * Performs an iterative depth-first search (dfs) traversal on a binary tree and accumulates the 'val' property of each node.
     * @param {'in' | 'pre' | 'post'} [pattern] - The traversal pattern: 'in' (in-order), 'pre' (pre-order), or 'post' (post-order).
     * @param {'val'} nodeOrPropertyName - The name of the property to accumulate.
     * @returns An array of 'val' properties from each node.
     */
    dfsIterative(pattern: DFSOrderPattern, nodeOrPropertyName: 'val'): N['val'][];
    /**
     * Performs an iterative depth-first search (dfs) traversal on a binary tree and accumulates nodes themselves.
     * @param {'in' | 'pre' | 'post'} [pattern] - The traversal pattern: 'in' (in-order), 'pre' (pre-order), or 'post' (post-order).
     * @param {'node'} nodeOrPropertyName - The name of the property to accumulate.
     * @returns An array of binary tree nodes.
     */
    dfsIterative(pattern: DFSOrderPattern, nodeOrPropertyName: 'node'): N[];
    /**
     * Performs a level-order traversal on a binary tree starting from the specified node and accumulates properties of each node based on their 'key' property.
     * @returns An array of binary tree node IDs.
     */
    levelIterative(): BinaryTreeNodeKey[];
    /**
     * Performs a level-order traversal on a binary tree starting from the specified node and accumulates properties of each node based on their 'key' property.
     * @param {N | null} node - The starting node for the level order traversal. If null, the root node of the tree is used as the starting node.
     * @returns An array of binary tree node IDs.
     */
    levelIterative(node: N | null): BinaryTreeNodeKey[];
    /**
     * Performs a level-order traversal on a binary tree starting from the specified node and accumulates properties of each node based on the specified property name.
     * @param {N | null} node - The starting node for the level order traversal. If null, the root node of the tree is used as the starting node.
     * @param {string} nodeOrPropertyName - The name of the property to accumulate.
     * @returns An array of values corresponding to the specified property.
     */
    levelIterative(node: N | null, nodeOrPropertyName: 'key'): BinaryTreeNodeKey[];
    /**
     * Performs a level-order traversal on a binary tree starting from the specified node and accumulates the 'val' property of each node.
     * @param {N | null} node - The starting node for the level order traversal. If null, the root node of the tree is used as the starting node.
     * @param {'val'} nodeOrPropertyName - The name of the property to accumulate.
     * @returns An array of 'val' properties from each node.
     */
    levelIterative(node: N | null, nodeOrPropertyName: 'val'): N['val'][];
    /**
     * Performs a level-order traversal on a binary tree starting from the specified node and accumulates nodes themselves.
     * @param {N | null} node - The starting node for the level order traversal. If null, the root node of the tree is used as the starting node.
     * @param {'node'} nodeOrPropertyName - The name of the property to accumulate.
     * @returns An array of binary tree nodes.
     */
    levelIterative(node: N | null, nodeOrPropertyName: 'node'): N[];
    /**
     * Collects nodes from a binary tree by a specified property and organizes them into levels.
     * @returns A 2D array of AbstractBinaryTreeNodeProperty<N> objects.
     */
    listLevels(): BinaryTreeNodeKey[][];
    /**
     * Collects nodes from a binary tree by a specified property and organizes them into levels.
     * @param {N | null} node - The root node of the binary tree or null. If null, the function will use the root node of the current binary tree instance.
     * @returns A 2D array of AbstractBinaryTreeNodeProperty<N> objects.
     */
    listLevels(node: N | null): BinaryTreeNodeKey[][];
    /**
     * Collects nodes from a binary tree by a specified property and organizes them into levels.
     * @param {N | null} node - The root node of the binary tree or null. If null, the function will use the root node of the current binary tree instance.
     * @param {'key} nodeOrPropertyName - The property of the BinaryTreeNode object to collect at each level.
     * @returns A 2D array of values corresponding to the specified property.
     */
    listLevels(node: N | null, nodeOrPropertyName: 'key'): BinaryTreeNodeKey[][];
    /**
     * Collects nodes from a binary tree by a specified property and organizes them into levels.
     * @param {N | null} node - The root node of the binary tree or null. If null, the function will use the root node of the current binary tree instance.
     * @param {'val'} nodeOrPropertyName - The property of the BinaryTreeNode object to collect at each level.
     * @returns A 2D array of 'val' properties from each node.
     */
    listLevels(node: N | null, nodeOrPropertyName: 'val'): N['val'][][];
    /**
     * Collects nodes from a binary tree by a specified property and organizes them into levels.
     * @param {N | null} node - The root node of the binary tree or null. If null, the function will use the root node of the current binary tree instance.
     * @param {'node'} nodeOrPropertyName - The property of the BinaryTreeNode object to collect at each level.
     * @returns A 2D array of binary tree nodes.
     */
    listLevels(node: N | null, nodeOrPropertyName: 'node'): N[][];
    /**
     * The function returns the predecessor of a given node in a binary tree.
     * @param node - The parameter `node` is a BinaryTreeNode object, representing a node in a binary tree.
     * @returns the predecessor of the given node in a binary tree.
     */
    getPredecessor(node: N): N;
    /**
     * Time complexity is O(n)
     * Space complexity of Iterative dfs equals to recursive dfs which is O(n) because of the stack
     */
    /**
     * Performs an in-order, pre-order, or post-order traversal on a binary tree using the Morris traversal algorithm.
     * @returns An array of binary tree node IDs.
     */
    morris(): BinaryTreeNodeKey[];
    /**
     * Performs an in-order, pre-order, or post-order traversal on a binary tree using the Morris traversal algorithm and accumulates properties of each node based on the specified property name.
     * @param {'in' | 'pre' | 'post'} [pattern] - The traversal pattern: 'in' (in-order), 'pre' (pre-order), or 'post' (post-order).
     * @param {'key'} nodeOrPropertyName - The name of the property to accumulate.
     * @returns An array of values corresponding to the specified property.
     */
    morris(pattern: DFSOrderPattern, nodeOrPropertyName: 'key'): BinaryTreeNodeKey[];
    /**
     * Performs an in-order, pre-order, or post-order traversal on a binary tree using the Morris traversal algorithm and accumulates properties of each node based on the specified property name.
     * @param {'in' | 'pre' | 'post'} [pattern] - The traversal pattern: 'in' (in-order), 'pre' (pre-order), or 'post' (post-order).
     * @returns An array of values corresponding to the specified property.
     */
    morris(pattern: DFSOrderPattern): BinaryTreeNodeKey[];
    /**
     * Performs an in-order, pre-order, or post-order traversal on a binary tree using the Morris traversal algorithm and accumulates the 'val' property of each node.
     * @param {'in' | 'pre' | 'post'} [pattern] - The traversal pattern: 'in' (in-order), 'pre' (pre-order), or 'post' (post-order).
     * @param {'val'} nodeOrPropertyName - The property of the BinaryTreeNode object to collect at each level.
     * @returns An array of 'val' properties from each node.
     */
    morris(pattern: DFSOrderPattern, nodeOrPropertyName: 'val'): N[];
    /**
     * Performs an in-order, pre-order, or post-order traversal on a binary tree using the Morris traversal algorithm and accumulates nodes themselves.
     * @param {'in' | 'pre' | 'post'} [pattern] - The traversal pattern: 'in' (in-order), 'pre' (pre-order), or 'post' (post-order).
     * @param {'node'} nodeOrPropertyName - The property of the BinaryTreeNode object to collect at each level.
     * @returns An array of binary tree nodes.
     */
    morris(pattern: DFSOrderPattern, nodeOrPropertyName: 'node'): N[];
    /**
     * The function adds a new node to a binary tree if there is an available position.
     * @param {N | null} newNode - The `newNode` parameter is of type `N | null`, which means it can either be a node of
     * type `N` or `null`. It represents the node that you want to add to the binary tree.
     * @param {N} parent - The parent parameter is of type N, which represents a node in a binary tree.
     * @returns either the left or right child node of the parent node, depending on which child is available for adding
     * the new node. If a new node is added, the function also updates the size of the binary tree. If neither the left nor
     * right child is available, the function returns undefined. If the parent node is null, the function also returns
     * undefined.
     */
    protected _addTo(newNode: N | null, parent: N): N | null | undefined;
    /**
     * The function sets the loop type for a protected variable.
     * @param {LoopType} value - The value parameter is of type LoopType.
     */
    protected _setLoopType(value: LoopType): void;
    /**
     * The function sets the root property of an object to a given value, and if the value is not null, it also sets the
     * parent property of the value to undefined.
     * @param {N | null} v - The parameter `v` is of type `N | null`, which means it can either be of type `N` or `null`.
     */
    protected _setRoot(v: N | null): void;
    /**
     * The function sets the size of a protected variable.
     * @param {number} v - number
     */
    protected _setSize(v: number): void;
    /**
     * The function `_clearResults` resets the values of several arrays used for tracking visited nodes and their
     * properties.
     */
    protected _clearResults(): void;
    /**
     * The function checks if a given property of a binary tree node matches a specified value, and if so, adds the node to
     * a result array.
     * @param {N} cur - The current node being processed.
     * @param {(N | null | undefined)[]} result - An array that stores the matching nodes.
     * @param {BinaryTreeNodeKey | N} nodeProperty - The `nodeProperty` parameter is either a `BinaryTreeNodeKey` or a `N`
     * type. It represents the property value that we are comparing against in the switch statement.
     * @param {BinaryTreeNodePropertyName} [propertyName] - The `propertyName` parameter is an optional parameter that
     * specifies the property name to compare against when pushing nodes into the `result` array. It can be either `'key'`
     * or `'val'`. If it is not provided or is not equal to `'key'` or `'val'`, the
     * @param {boolean} [onlyOne] - The `onlyOne` parameter is an optional boolean parameter that determines whether to
     * stop after finding the first matching node or continue searching for all matching nodes. If `onlyOne` is set to
     * `true`, the function will stop after finding the first matching node and return `true`. If `onlyOne
     * @returns a boolean value indicating whether only one matching node should be pushed into the result array.
     */
    protected _pushByPropertyNameStopOrNot(cur: N, result: (N | null | undefined)[], nodeProperty: BinaryTreeNodeKey | N, propertyName?: BinaryTreeNodePropertyName, onlyOne?: boolean): boolean | undefined;
    /**
     * The function `_accumulatedByPropertyName` accumulates values from a given node based on the specified property name.
     * @param {N} node - The `node` parameter is of type `N`, which represents a node in a data structure.
     * @param {NodeOrPropertyName} [nodeOrPropertyName] - The `nodeOrPropertyName` parameter is an optional parameter that
     * can be either a string representing a property name or a reference to a `Node` object. If it is a string, it
     * specifies the property name to be used for accumulating values. If it is a `Node` object, it specifies
     */
    protected _accumulatedByPropertyName(node: N, nodeOrPropertyName?: NodeOrPropertyName): void;
    /**
     * The time complexity of Morris traversal is O(n), it may slower than others
     * The space complexity  Morris traversal is O(1) because no using stack
     */
    /**
     * The function `_getResultByPropertyName` returns the corresponding property value based on the given node or property
     * name.
     * @param {NodeOrPropertyName} [nodeOrPropertyName] - The parameter `nodeOrPropertyName` is an optional parameter that
     * can accept either a `NodeOrPropertyName` type or be undefined.
     * @returns The method `_getResultByPropertyName` returns an instance of `BinaryTreeNodeProperties<N>`.
     */
    protected _getResultByPropertyName(nodeOrPropertyName?: NodeOrPropertyName): BinaryTreeNodeProperties<N>;
}
